{"meta":{"title":"fishni","subtitle":"","description":"","author":"John Doe","url":"https://fishni.github.io","root":"/"},"pages":[{"title":"关于","date":"2020-03-30T02:58:09.190Z","updated":"2020-03-30T02:58:09.190Z","comments":true,"path":"about/index.html","permalink":"https://fishni.github.io/about/index.html","excerpt":"","text":"I’m fishmouse! xxxxxx"},{"title":"所有分类","date":"2020-03-30T05:12:13.734Z","updated":"2020-03-30T05:12:13.734Z","comments":true,"path":"categories/index.html","permalink":"https://fishni.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-03-30T05:13:30.921Z","updated":"2020-03-30T05:13:30.921Z","comments":true,"path":"tags/index.html","permalink":"https://fishni.github.io/tags/index.html","excerpt":"","text":""},{"title":"友邻","date":"2020-03-30T05:26:40.217Z","updated":"2020-03-30T05:26:40.217Z","comments":true,"path":"friends/index.html","permalink":"https://fishni.github.io/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。"}],"posts":[{"title":"python序列化数据之pickle详解","slug":"python序列化数据之pickle详解","date":"2020-03-14T16:00:00.000Z","updated":"2020-03-30T06:32:58.535Z","comments":true,"path":"2020/03/15/python序列化数据之pickle详解/","link":"","permalink":"https://fishni.github.io/2020/03/15/python%E5%BA%8F%E5%88%97%E5%8C%96%E6%95%B0%E6%8D%AE%E4%B9%8Bpickle%E8%AF%A6%E8%A7%A3/","excerpt":"学习python之pickle详解","text":"学习python之pickle详解 序列化和反序列化 便于存储（序列化过程：将文本信息转为==二进制数据流，易存储在硬盘中==） 反序列化从硬盘读取的数据，可得到原始数据 python程序运行中得到的字符串、列表等数据，要长久保存，方便之后使用（pickle模块可以将对象转换为已知可以传输或存储的格式） python中序列化和反序列化 将Python对象转换为二级制形式叫做序列化（Pickling） 将二进制数据流恢复为Python对象叫做反序列化（Unpickling） pickle 提供了一个简单的==持久化==功能，可以将对象以==文件==形式存放在磁盘上 只能在python中使用，可以序列化python中几乎所有的数据类型（列表、字典…） pickle序列化后的数据，可读性差 pickle序列化和反序列化示例 819pickling_unpickling_example.py 123456789101112131415161718192021222324252627282930313233import pickle# 定义类Partclass Part: number = 0 name = \"\" def __init__(self, number, name): self.number = number self.name = name def identify(self): print(\"Part Number: %d\"%(self.number)) print(\"Part Name: %s\"%(self.name)) # 实例化partpart1=Part(111, \"Spindle\");# Create a file to store the pickled object# 创建文件存储pickled对象objectRepository = open(\"ObjectFile.picl\", \"wb\"); # Pickle/serialize the python object and store the bytes into a binary file# 序列化Python对象并存储为二进制字节流pickle.dump(part1, objectRepository, protocol=pickle.HIGHEST_PROTOCOL)objectRepository.close() # Unpickle/de-serialize the python object and print the attributes of the object# 反序列化Python对象并打印对象属性objectRepository = open(\"ObjectFile.picl\", \"rb\",);reconstructedObject = pickle.load(objectRepository) # Print object attributes# 打印对象属性reconstructedObject.identify() 12 - 运行结果： (venv) yuhao@fishmouse:~/Envs/venv/project$ python 819pickling_unpickling_example.py Part Number: 111 Part Name: Spindle 12345678- 序列化的数据 &#96;&#96;&#96;python &gt;&gt;&gt; with open(&#39;ObjectFile.picl&#39;,&#39;rb&#39;) as f: ... f.read() ... b&#39;\\x80\\x04\\x959\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x08__main__\\x94\\x8c\\x04Part\\x94\\x93\\x94)\\x81\\x94&#125;\\x94(\\x8c\\x06number\\x94Ko\\x8c\\x04name\\x94\\x8c\\x07Spindle\\x94ub.&#39; ==序列化==语法 pickle.dump参考链接 pickle.dump(obj,file[,protocol]) 序列化对象，将结果数据流写入到文件对象或者buffer中 参数protocol是序列化模式，一共有5种不同的类型，即（0,1,2,3,4）； （0,1,2）早期的版本，默认值为0（表示以文本形式序列化），值为1或2（表示以二级制的形式序列化）； （3,4）则是python3之后的版本 查看（3,4） 12345&gt;&gt;&gt; import pickle&gt;&gt;&gt; pickle.HIGHEST_PROTOCOL4&gt;&gt;&gt; pickle.DEFAULT_PROTOCOL3 pickle.dump()：转换的字节流写入buffer中 示例：819pickle_dump_example.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import pickleimport io class Book: title = \"\" isbn = \"\" parts = None chapters = None def __init__(self, title, isbn, parts, chapters): self.title = title self.isbn = isbn self.parts = parts self.chapters = chapters def identify(self): print(\"Title of the book: %s\"%(self.title)) print(\"ISBN of the book: %s\"%(self.isbn)) print(\"Parts are:\") for part in self.parts: print(part) print(\"Chapters are:%s\"%(self.chapters))class Part: partName = \"\" beginChapter = -1 endChapter = -1 def __init__(self, partName, beginChapter, endChapter): self.partName = partName self.beginChapter = beginChapter self.endChapter = endChapter def __str__(self): stringRep = \"%s\"%(self.partName) return stringReppart1 = Part(\"Part 1\", 1, 3)part2 = Part(\"Part 2\", 4, 5) part3 = Part(\"Part 3\", 6, 7) bookTitle = \"Book yet to be written\";bookISBN = \"XXX-X-XX-XXXXXX-X\";bookParts = [part1, part2, part3]bookChapters = [\"Chapter 1\", \"Chapter 2\", \"Chapter 3\", \"Chapter 4\", \"Chapter 5\", \"Chapter 6\", \"Chapter 7\"];book = Book(bookTitle, bookISBN, bookParts, bookChapters)# 创建buffer存储pickle对象pickleBuffer = io.BytesIO()print(\"Pickling of the object into the memory buffer started\")# pickle.dump(book,pickleBuffer)print(\"Pickling of the object into the memory buffer ended\")print(\"Pickled buffer beginning address:\")print(pickleBuffer.getbuffer())print(\"Unpickling of the object from memory started\")#unpickledBook = pickle.loads(pickleBuffer.getbuffer())print(\"Unpickling of the object from memory ended\")print(\"Printing the attributes of unpickled object\")unpickledBook.identify() pickle.dumps()参数 pickle.dumps(obj, protocol=None,*,fix_imports=True) 与pickle.dump()区别，pickle.dumps()方法不需要写入文件中，他是直接返回一个序列化的bytes对象 ==反序列化==语法 pickle.load(file) 反序列化对象（将文件中数据解析为一个Python对象） ==注意==：load(file)时，要让Python能够找到类的定义,否则会报错 注意：参数file，必须是以二进制的形式进行操作（读取） 示例：819test_pickle.py 反序列方法pickle.loads() 参数如下： pickle.loads(bytes_object, *,fix_imports=True, encoding=”ASCII”. errors=”strict”) pickle.loads()方法是直接从bytes对象中读取序列化的信息，而非从文件中读取。示例如下： 12345&gt;&gt;&gt; import pickle&gt;&gt;&gt; pickle.dumps([1,2,3])b'\\x80\\x03]q\\x00(K\\x01K\\x02K\\x03e.'&gt;&gt;&gt; pickle.loads(_)[1, 2, 3] 1234567891011121314#load(file)时，要让Python能够找到类的定义,否则会报错import pickle class Person: def __init__(self,n,a): self.name=n self.age=a def show(self): print(self.name+\" \"+str(self.age)) aa = Person(\"JGood\", 2) aa.show() # del Personf=open('p.txt','wb') pickle.dump(aa,f,0) f.close() 123456 注释掉删除类对象操作，若未注释则会报错del Person f&#x3D;open(&#39;p.txt&#39;,&#39;rb&#39;) bb&#x3D;pickle.load(f) f.close() bb.show() 运行结果： 123(venv) yuhao@fishmouse:~&#x2F;Envs&#x2F;venv&#x2F;project$ python 819test_pickle.py JGood 2JGood 2 未注释结果： 1234567891011121314 (venv) yuhao@fishmouse:~&#x2F;Envs&#x2F;venv&#x2F;project$ python 819test_pickle.py JGood 2Traceback (most recent call last): File &quot;819test_pickle.py&quot;, line 15, in &lt;module&gt; bb&#x3D;pickle.load(f) AttributeError: Can&#39;t get attribute &#39;Person&#39; on &lt;module &#39;__main__&#39; from &#39;819test_pickle.py&#39;&gt; [p.txt](p.txt)文件中数据存储格式： &#96;&#96;&#96;python &gt;&gt;&gt; with open(&#39;p.txt&#39;,&#39;rb&#39;) as f: ... f.read() ... b&#39;ccopy_reg\\n_reconstructor\\np0\\n(c__main__\\nPerson\\np1\\nc__builtin__\\nobject\\np2\\nNtp3\\nRp4\\n(dp5\\nVname\\np6\\nVJGood\\np7\\nsVage\\np8\\nL2L\\nsb.&#39;","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"python网络编程","slug":"python/python网络编程","permalink":"https://fishni.github.io/categories/python/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"python网络编程","slug":"python网络编程","permalink":"https://fishni.github.io/tags/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"python网络编程01","slug":"python网络编程01-socket-udp-tcp-rsa加密的全双工聊天程序","date":"2020-03-14T05:55:42.000Z","updated":"2020-03-30T05:51:24.632Z","comments":true,"path":"2020/03/14/python网络编程01-socket-udp-tcp-rsa加密的全双工聊天程序/","link":"","permalink":"https://fishni.github.io/2020/03/14/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B01-socket-udp-tcp-rsa%E5%8A%A0%E5%AF%86%E7%9A%84%E5%85%A8%E5%8F%8C%E5%B7%A5%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/","excerpt":"学习内容 了解socket基本概念 利用socket类方法获取主机、网络及目标服务的信息 UDP、TCP客户端/服务器编写 案例：python SOCKET实现RSA加密的全双工聊天程序","text":"学习内容 了解socket基本概念 利用socket类方法获取主机、网络及目标服务的信息 UDP、TCP客户端/服务器编写 案例：python SOCKET实现RSA加密的全双工聊天程序 学习步骤构建python环境同时开发多个python应用程序（共用一个Python，不同版本的包不兼容会产生无用包），利用virtualenv创建“Python虚拟环境”（小型、独立的、隔离功能的Python环境），从而避免产生无用包 利用virtualenvwrapper管理virtualenv虚拟环境 mkvirtualenv venv ：创建虚拟环境venv workon ：查看当前已有虚拟环境目录 workon venv ：进入venv虚拟环境 deactivate ：退出虚拟环境 rmvirtualenv venv：删除虚拟环境venv socket概念 运行在不同机器上的进程通过套接字发送报文来进行通信，套接字充当了两个进程通信的“中间人”，观察下图（OSI模型中）： 套接字是个通信端点，操作系统使用整数来标识套接字，Python使用socket.socket对象表示套接字（该对象内部表示的是操作系统标识套接字的整数，可利用fileno()方法查看），调用socket.socket对象的方法请求使用套接字的系统调用是，该对象会自动使用内部维护的套接字整数标识符 socket.socket对象的fileno()方法 1234&gt;&gt;&gt; import socket&gt;&gt;&gt; s = socket.socket()&gt;&gt;&gt; s.fileno()3 IP地址、端口号 端口号（port）传输层协议内容、用来标识一个进程 一个端口号只能被一个进程占用 IP地址 + 端口号能标识网络上的某一台主机的某一个进程 套接字组成：IP地址和端口号就构成了一个网络中的唯一标识符，即套接字 套接字类型（常用的两种） 流套接字：创建socket对象时（用socket.SOCK_STREAM） 面向连接、可靠的数据传输服务。能够保证数据无差错、无重复、按顺序发送 数据包套接字：创建socket对象时，使用socket.SOCK_DGRAM 提供无连接服务。无需建立连接，只需将目的地址信息打包后发送；该服务使用UDP进行传输，延迟小且效率高，缺点不能保证数据传输的可靠性 利用socket类方法获取主机、网络及目标服务的信息 获取主机名、地址 12345&gt;&gt;&gt; import socket&gt;&gt;&gt; socket.gethostname()'fishmouse'&gt;&gt;&gt; socket.gethostbyname(_)'127.0.1.1' 获取远程设备IP地址（如获取：www.baidu.com） 12&gt;&gt;&gt; socket.gethostbyname('www.baidu.com')'14.215.177.38' 可看到socket.gethostbyname具有==域名解析的作用==，ping一下看通不通 12345(venv) yuhao@fishmouse:~&#x2F;Envs&#x2F;venv&#x2F;project$ ping 14.215.177.38PING 14.215.177.38 (14.215.177.38) 56(84) bytes of data.64 bytes from 14.215.177.38: icmp_seq&#x3D;1 ttl&#x3D;55 time&#x3D;37.9 ms64 bytes from 14.215.177.38: icmp_seq&#x3D;2 ttl&#x3D;55 time&#x3D;39.4 ms64 bytes from 14.215.177.38: icmp_seq&#x3D;3 ttl&#x3D;55 time&#x3D;34.8 ms IP地址格式转换（打包成32位二进制格式）：socket类方法inet_aton、inet_ntoa inet_aton()使用 123456&gt;&gt;&gt; ip_addr ='127.0.0.1'&gt;&gt;&gt; socket.inet_aton(ip_addr)b'\\x7f\\x00\\x00\\x01'&gt;&gt;&gt; import binascii&gt;&gt;&gt; binascii.hexlify(_)b'7f000001' 观察看到，转换后的32位二进制格式，并调用binasci.hexlify以16进制形式表示二进制数据 10进制结果，单个字节转换 123&gt;&gt;&gt;import struct&gt;&gt;&gt; struct.unpack('B',b'\\x7f')[0]127 inet_ntoa()使用：32位二进制包转换为IPv4地址 12345a的主机字节序----------网络字节序 ---------b的主机字节序&gt;&gt;&gt; ip_addr ='127.0.0.1'&gt;&gt;&gt; socket.inet_aton(ip_addr)b'\\x7f\\x00\\x00\\x01'&gt;&gt;&gt; socket.inet_ntoa(_)'127.0.0.1' 通过指定的端口和协议找到服务名 socket.getservbyport() 12345678910&gt;&gt;&gt; socket.getservbyport(80)'http'&gt;&gt;&gt; socket.getservbyport(53)'domain'&gt;&gt;&gt; socket.getservbyport(25)'smtp'&gt;&gt;&gt; socket.getservbyport(21)'ftp'&gt;&gt;&gt; socket.getservbyport(3306)'mysql' socket.getservbyname() ：通过服务名获取端口 1234&gt;&gt;&gt; socket.getservbyname('ssh')22&gt;&gt;&gt; socket.getservbyname('http')80 linux系统中，etc/services文件中可查看相关服务和端口 主机字节序和网络字节序之间的转换 不同主机a，b之间通信，数据格式需转换 a的固有数据存储——-标准化——–转化成b的固有格式 也即为： ==a的主机字节序———-网络字节序 ———b的主机字节序== 主机字节序 主机内部，内存中数据的处理方式，可以分为两种： 大端字节序：按照内存的增长方向，高位数据存储在高位内存中 小端字节序：按照内存的增长方向，高位数据存储在低位内存中 socket.ntohl()、socket.htonl()、ntohs()、htons() 1234567891011&gt;&gt;&gt; data = 1234&gt;&gt;&gt; socket.htonl(data)3523477504&gt;&gt;&gt; socket.htons(data)53764&gt;&gt;&gt; socket.ntohl(data)3523477504&gt;&gt;&gt; socket.ntohs(data)53764 &gt;&gt;&gt; socket.ntohs(53764)1234 设定并获取默认的套接字超时时间 socket.gettimeout()、socket.settimeout() 12345&gt;&gt;&gt; s = socket.socket()&gt;&gt;&gt; s.gettimeout()&gt;&gt;&gt; s.settimeout(100)&gt;&gt;&gt; s.gettimeout()100.0 默认套接字超时时间为0 套接字错误异常处理 try…except 套接字异常类型 as 参数… argparse：命令项选项与参数解析的模块 parser=argparse.ArgumentParser()：创建解析对象 parser.add_argument()：向对象中添加关注的命令行参数和选项 given_args = parser.parse_args()：对象解析 套接字发送和接收的缓冲区大小修改 socket中getsockopt()、setsockopt()方法 套接字阻塞模式和非阻塞模式 s= socket.socket() s.setblocking(1)：设为阻塞模式 s.setblocking(0)：设为非阻塞模式 默认情况下，TCP套接字处于阻塞模式 UDP 多路复用：允许多个会话共享同一介质或机制的一种解决方案 UDP支持多路复用：UDP协议提供端口号，用于对目标为同一机器上不同服务的多个数据包进行适当的多路分解 TCP：多路复用、可靠传输 UDP机制：仅使用IP地址和端口进行标识，以此将数据包发送至目标地址 使用自环接口的UDP服务器和 客户端 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# UDP client and server on localhost# 814udp_local.py import argparse, socketfrom datetime import datetimeMAX_BYTES = 65535# serverdef server(port): sock = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) sock.bind(('127.0.0.1',port)) # getsockname()返回sock示例对象的（地址，端口) print(\"Listening at &#123;&#125;\".format(sock.getsockname())) while True: data, address = sock.recvfrom(MAX_BYTES) text = data.decode('ascii') print(\"The client at &#123;&#125; says &#123;!r&#125;\".format(address,text)) text = 'Your data was &#123;&#125; bytes long '.format(len(data)) data = text.encode('ascii') sock.sendto(data,address)# 客户端def client(port): sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) text = 'The time is &#123;&#125;'.format(datetime.now()) data = text.encode('ascii') sock.sendto(data,('127.0.0.1',port)) # sock.getsockname()获取当前进程的（地址，端口）元组信息 print('The OS assigned me the address &#123;&#125;'.format(sock.getsockname())) data, address = sock.recvfrom(MAX_BYTES) text = data.decode() # format格式化字符串 print('The server &#123;&#125; replied &#123;!r&#125;'.format(address,text))if __name__ == '__main__': # 字典 choices = &#123;'client':client,'server':server&#125; # 创建参数解析对象 parser = argparse.ArgumentParser(description='Send and receive UDP locally') #添加要解析的参数 parser.add_argument('role',choices=choices,help ='which role to play') parser.add_argument('-p',metavar='PORT',type=int,default=1060,help='UDP port (default 1060)') # 参数解析 args = parser.parse_args() # 调用服务端或客户端函数 function = choices[args.role] function(args.p) 先运行服务端 python 814udp_local.py server 结果： Listening at (‘127.0.0.1’, 1060)The client at (‘127.0.0.1’, 60945) says ‘The time is 2019-08-16 16:34:56.276877’ 再运行客户端 python 814udp_local.py client The OS assigned me the address (‘0.0.0.0’, 60945)The server (‘127.0.0.1’, 1060) replied ‘Your data was 38 bytes long ‘ 混杂客户端与垃圾回复 814udp_local.py代码中，客户端程序存在安全隐患，如fg果服务端响应延迟一会，攻击者伪装成服务器的一个响应，客户端并没有检查是否是真正服务器的响应 先运行服务器，再将服务器暂停，创建一个快速发送信息的响应给客户端，再==fg命令==将暂停的服务器开启 客户端 观察到，客户端收到的数据实际上是伪装的数据，真正的服务器的响应没到客户端 混杂客户端 不考虑地址是否正确，接收并处理所有收到的数据包的网络监听客户端在技术上叫 作混杂( promiscuous )客户端 python SOCKET实现RSA加密的全双工聊天程序实现 题目背景 RSA加密解密是利用非对称秘钥解决传输过程中机密性的问题，将之用在聊天程序上，其中使用rsa模块，发送方生产公钥和私钥，然后使用公钥将信息加密后，利用pickle模块封装加密后的消息和私钥，然后发送给接收方，接收方同样通过pickle模块将消息进行解封，使用发送过来的私钥将消息解密，并将内容打印在屏幕上 题目要点 传输协议：TCP套接字创建客户端和服务端_ sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 数据传输格式：pickle序列化数据 pickle.dumps()序列化 pickle.loads()反序列化 1234567891011&gt;&gt;&gt; import pickle&gt;&gt;&gt; encryptdata = 'hello'&gt;&gt;&gt; key = 882321&gt;&gt;&gt; message = pickle.dumps([encryptdata,key])&gt;&gt;&gt; type(message)&lt;class 'bytes'&gt;&gt;&gt;&gt; messageb'\\x80\\x03]q\\x00(X\\x05\\x00\\x00\\x00helloq\\x01J\\x91v\\r\\x00e.'&gt;&gt;&gt; origndata = pickle.loads(message)&gt;&gt;&gt; origndata['hello', 882321] 数据加密方式：RSA加解密 123456789&gt;&gt;&gt;data = 'hello'&gt;&gt;&gt; import rsa&gt;&gt;&gt; (PubKey,PrivateKey) = rsa.newkeys(512)&gt;&gt;&gt; encryptdata = rsa.encrypt(data.encode(),PubKey)&gt;&gt;&gt; encryptdatab'=\\\\\\x1c\\x93]^(Z/\\xac\\x81\\xfd\\xffj!\\x0b:r\\xb0\\x1b\\xf9\\x97VZ\\xdf\\xe1\\x9e2\\xb4\\x05G4\\x01\\x9f\\xc8\\xfd\\x1e\\x00\\xa1\\xb7\\xbdU\\x98\\xbc\\x1e5\\xa1yy\\xee$\\xcd\\xf8\\x10\\xf4\\xba\\t\\x84\\xba\\x13\\x99hs\\x8d'&gt;&gt;&gt; decryptdata = rsa.decrypt(encryptdata,PrivateKey)&gt;&gt;&gt; decryptdatab'hello' 题目图解 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import rsaimport socketimport threadingimport pickle PORT = 4396BUFF = 1024 def RsaEncrypt(str): # 利用rsa产生公钥、私钥 (PubKey, PrivateKey) = rsa.newkeys(512) content = str.encode('utf8') # 使用公钥加密 Encrypt_Str = rsa.encrypt(content, PubKey) # 返回加密信息和私钥 return (Encrypt_Str, PrivateKey) def RsaDecrypt(str, pk): Decrypt_Str = rsa.decrypt(str, pk) Decrypt_Str_1 = Decrypt_Str.decode('utf8') return Decrypt_Str_1 def SendMessage(Sock, test): while True: SendData = input() # 加密要发送的数据 (encryptdata, PrivateKey) = RsaEncrypt(SendData) # 打印加密后的数据 print('encrypted data is ' + str(encryptdata)) # pickel封装加密后的数据和私钥 Message = pickle.dumps([encryptdata, PrivateKey]) if len(SendData) &gt; 0: Sock.send(Message) def RecvMessage(Sock, test): while True: # 接收数据 Message = Sock.recv(BUFF) # pickle解封数据 (recvdata, PrivateKey) = pickle.loads(Message) # 对加密的数据解密 decryptdata = RsaDecrypt(recvdata, PrivateKey) if len(Message)&gt;0: print(\"receive message:\" + decryptdata) def main(): type = input('please input server or client:') if type == 'server': # 创建套接字 ServerSock = socket.socket(socket.AF_INET,socket.SOCK_STREAM) # 端口绑定 ServerSock.bind(('127.0.0.1',PORT)) # 服务器允许连接的个数 ServerSock.listen(5) print(\"listening......\") while True: ConSock,addr = ServerSock.accept() print('connection succeed' + '\\n' + 'you can chat online') # 多线程运用 thread_1 = threading.Thread(target = SendMessage, args = (ConSock, None)) thread_2 = threading.Thread(target = RecvMessage, args = (ConSock, None)) thread_1.start() thread_2.start() elif type == 'client': ClientSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) ServerAddr = input(\"please input the server's ip address:\") ClientSock.connect((ServerAddr, PORT)) print('connection succeed, chat start!') thread_3 = threading.Thread(target = SendMessage, args = (ClientSock, None)) thread_4 = threading.Thread(target = RecvMessage, args = (ClientSock, None)) thread_3.start() thread_4.start() if __name__ == '__main__': main() 结果演示 先启动server进行监听 启动客户端连接server 客户端向服务器发送消息 服务器端接收到消息，并将消息打印在屏幕上 分析 综上，该程序利用的是TCP套接字保证了传输的可靠性，并利用多线程进行信息交互，pickle封装数据，rsa产生公钥、私钥、和加/解密等操作","categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"python网络编程","slug":"python/python网络编程","permalink":"https://fishni.github.io/categories/python/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"python网络编程","slug":"python网络编程","permalink":"https://fishni.github.io/tags/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]}],"categories":[{"name":"python","slug":"python","permalink":"https://fishni.github.io/categories/python/"},{"name":"python网络编程","slug":"python/python网络编程","permalink":"https://fishni.github.io/categories/python/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"python网络编程","slug":"python网络编程","permalink":"https://fishni.github.io/tags/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]}